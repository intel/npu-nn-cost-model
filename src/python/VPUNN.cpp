// File: VPUNN_0.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <type_traits> // std::integral_constant
#include <type_traits> // std::is_same
#include <utility> // std::pair

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_0(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // std::integral_constant file:type_traits line:57
		pybind11::class_<std::integral_constant<bool,true>, std::shared_ptr<std::integral_constant<bool,true>>> cl(M("std"), "integral_constant_bool_true_t", "");
		cl.def( pybind11::init( [](){ return new std::integral_constant<bool,true>(); } ) );
		cl.def( pybind11::init( [](std::integral_constant<bool,true> const &o){ return new std::integral_constant<bool,true>(o); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // std::integral_constant file:type_traits line:57
		pybind11::class_<std::integral_constant<bool,false>, std::shared_ptr<std::integral_constant<bool,false>>> cl(M("std"), "integral_constant_bool_false_t", "");
		cl.def( pybind11::init( [](){ return new std::integral_constant<bool,false>(); } ) );
		cl.def( pybind11::init( [](std::integral_constant<bool,false> const &o){ return new std::integral_constant<bool,false>(o); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // std::is_same file:type_traits line:1394
		pybind11::class_<std::is_same<std::string,std::string>, std::shared_ptr<std::is_same<std::string,std::string>>, std::integral_constant<bool,true>> cl(M("std"), "is_same_std_string_std_string_t", "");
		cl.def( pybind11::init( [](){ return new std::is_same<std::string,std::string>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // std::is_same file:type_traits line:1394
		pybind11::class_<std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>, std::shared_ptr<std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>>, std::integral_constant<bool,true>> cl(M("std"), "is_same_const_std_map_const_int_const_std_string_std_less_const_int_std_allocator_std_pair_const_int_const_std_string_&_const_std_map_const_int_const_std_string_std_less_const_int_std_allocator_std_pair_const_int_const_std_string_&_t", "");
		cl.def( pybind11::init( [](){ return new std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
}


// File: VPUNN_1.cpp

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_1(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::Dim::Grid file: line:20
	pybind11::enum_<VPUNN::Dim::Grid>(M("VPUNN::Dim"), "Grid", pybind11::arithmetic(), "")
		.value("W", VPUNN::Dim::W)
		.value("H", VPUNN::Dim::H)
		.export_values();

;

	// VPUNN::Dim::Act file: line:21
	pybind11::enum_<VPUNN::Dim::Act>(M("VPUNN::Dim"), "Act", pybind11::arithmetic(), "")
		.value("X", VPUNN::Dim::X)
		.value("Y", VPUNN::Dim::Y)
		.value("Z", VPUNN::Dim::Z)
		.value("B", VPUNN::Dim::B)
		.export_values();

;

	// VPUNN::Dim::Wt file: line:22
	pybind11::enum_<VPUNN::Dim::Wt>(M("VPUNN::Dim"), "Wt", pybind11::arithmetic(), "")
		.value("K", VPUNN::Dim::K)
		.value("C", VPUNN::Dim::C)
		.value("Ky", VPUNN::Dim::Ky)
		.value("Kx", VPUNN::Dim::Kx)
		.export_values();

;

	// VPUNN::Dim::Padding file: line:23
	pybind11::enum_<VPUNN::Dim::Padding>(M("VPUNN::Dim"), "Padding", pybind11::arithmetic(), "")
		.value("TOP", VPUNN::Dim::TOP)
		.value("BOTTOM", VPUNN::Dim::BOTTOM)
		.value("LEFT", VPUNN::Dim::LEFT)
		.value("RIGHT", VPUNN::Dim::RIGHT)
		.export_values();

;

}


// File: VPUNN_2.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::ActivationFunction
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::DataType
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::ExecutionMode
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::Layout
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::MemoryLocation
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::Operation
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::Swizzling
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::VPUDevice
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::VPUSubsystem
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ActivationFunction
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::DataType
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ExecutionMode
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ISIStrategy
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Layout
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::MemoryLocation
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Operation
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Swizzling
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::VPUDevice
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::VPUSubsystem
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::DataType
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::ExecutionMode
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::Layout
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::Operation

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_2(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::link(const enum VPUNN::VPUDevice &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::VPUDevice &, const char *)) &VPUNN::link<VPUNN::VPUDevice>, "C++: VPUNN::link(const enum VPUNN::VPUDevice &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::DataType &, const char *)) &VPUNN::link<VPUNN::DataType>, "C++: VPUNN::link(const enum VPUNN::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::Operation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::Operation &, const char *)) &VPUNN::link<VPUNN::Operation>, "C++: VPUNN::link(const enum VPUNN::Operation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::ActivationFunction &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::ActivationFunction &, const char *)) &VPUNN::link<VPUNN::ActivationFunction>, "C++: VPUNN::link(const enum VPUNN::ActivationFunction &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::Swizzling &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::Swizzling &, const char *)) &VPUNN::link<VPUNN::Swizzling>, "C++: VPUNN::link(const enum VPUNN::Swizzling &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::ExecutionMode &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::ExecutionMode &, const char *)) &VPUNN::link<VPUNN::ExecutionMode>, "C++: VPUNN::link(const enum VPUNN::ExecutionMode &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::Layout &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::Layout &, const char *)) &VPUNN::link<VPUNN::Layout>, "C++: VPUNN::link(const enum VPUNN::Layout &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::ISIStrategy &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::ISIStrategy &, const char *)) &VPUNN::link<VPUNN::ISIStrategy>, "C++: VPUNN::link(const enum VPUNN::ISIStrategy &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::VPUSubsystem &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::VPUSubsystem &, const char *)) &VPUNN::link<VPUNN::VPUSubsystem>, "C++: VPUNN::link(const enum VPUNN::VPUSubsystem &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::CostSourceHint &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::CostSourceHint &, const char *)) &VPUNN::link<VPUNN::CostSourceHint>, "C++: VPUNN::link(const enum VPUNN::CostSourceHint &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::ProfilingServiceBackend &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::ProfilingServiceBackend &, const char *)) &VPUNN::link<VPUNN::ProfilingServiceBackend>, "C++: VPUNN::link(const enum VPUNN::ProfilingServiceBackend &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::MPEEngine &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::MPEEngine &, const char *)) &VPUNN::link<VPUNN::MPEEngine>, "C++: VPUNN::link(const enum VPUNN::MPEEngine &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::MemoryLocation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::MemoryLocation &, const char *)) &VPUNN::link<VPUNN::MemoryLocation>, "C++: VPUNN::link(const enum VPUNN::MemoryLocation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::MemoryDirection &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::MemoryDirection &, const char *)) &VPUNN::link<VPUNN::MemoryDirection>, "C++: VPUNN::link(const enum VPUNN::MemoryDirection &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::Num_DMA_Engine &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::Num_DMA_Engine &, const char *)) &VPUNN::link<VPUNN::Num_DMA_Engine>, "C++: VPUNN::link(const enum VPUNN::Num_DMA_Engine &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::VPUTilingStrategy &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::VPUTilingStrategy &, const char *)) &VPUNN::link<VPUNN::VPUTilingStrategy>, "C++: VPUNN::link(const enum VPUNN::VPUTilingStrategy &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::VPUDevice &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::VPUDevice &, const char *)) &VPUNN::link<VPUNN::intf_01::VPUDevice>, "C++: VPUNN::link(const enum VPUNN::intf_01::VPUDevice &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::DataType &, const char *)) &VPUNN::link<VPUNN::intf_01::DataType>, "C++: VPUNN::link(const enum VPUNN::intf_01::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::Operation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::Operation &, const char *)) &VPUNN::link<VPUNN::intf_01::Operation>, "C++: VPUNN::link(const enum VPUNN::intf_01::Operation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::ActivationFunction &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::ActivationFunction &, const char *)) &VPUNN::link<VPUNN::intf_01::ActivationFunction>, "C++: VPUNN::link(const enum VPUNN::intf_01::ActivationFunction &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::Swizzling &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::Swizzling &, const char *)) &VPUNN::link<VPUNN::intf_01::Swizzling>, "C++: VPUNN::link(const enum VPUNN::intf_01::Swizzling &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::ExecutionMode &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::ExecutionMode &, const char *)) &VPUNN::link<VPUNN::intf_01::ExecutionMode>, "C++: VPUNN::link(const enum VPUNN::intf_01::ExecutionMode &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::Layout &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::Layout &, const char *)) &VPUNN::link<VPUNN::intf_01::Layout>, "C++: VPUNN::link(const enum VPUNN::intf_01::Layout &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::MemoryLocation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::MemoryLocation &, const char *)) &VPUNN::link<VPUNN::intf_01::MemoryLocation>, "C++: VPUNN::link(const enum VPUNN::intf_01::MemoryLocation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_01::VPUSubsystem &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_01::VPUSubsystem &, const char *)) &VPUNN::link<VPUNN::intf_01::VPUSubsystem>, "C++: VPUNN::link(const enum VPUNN::intf_01::VPUSubsystem &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::VPUDevice &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::VPUDevice &, const char *)) &VPUNN::link<VPUNN::intf_11::VPUDevice>, "C++: VPUNN::link(const enum VPUNN::intf_11::VPUDevice &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::DataType &, const char *)) &VPUNN::link<VPUNN::intf_11::DataType>, "C++: VPUNN::link(const enum VPUNN::intf_11::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::Operation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::Operation &, const char *)) &VPUNN::link<VPUNN::intf_11::Operation>, "C++: VPUNN::link(const enum VPUNN::intf_11::Operation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::ActivationFunction &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::ActivationFunction &, const char *)) &VPUNN::link<VPUNN::intf_11::ActivationFunction>, "C++: VPUNN::link(const enum VPUNN::intf_11::ActivationFunction &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::Swizzling &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::Swizzling &, const char *)) &VPUNN::link<VPUNN::intf_11::Swizzling>, "C++: VPUNN::link(const enum VPUNN::intf_11::Swizzling &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::ExecutionMode &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::ExecutionMode &, const char *)) &VPUNN::link<VPUNN::intf_11::ExecutionMode>, "C++: VPUNN::link(const enum VPUNN::intf_11::ExecutionMode &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::Layout &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::Layout &, const char *)) &VPUNN::link<VPUNN::intf_11::Layout>, "C++: VPUNN::link(const enum VPUNN::intf_11::Layout &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::ISIStrategy &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::ISIStrategy &, const char *)) &VPUNN::link<VPUNN::intf_11::ISIStrategy>, "C++: VPUNN::link(const enum VPUNN::intf_11::ISIStrategy &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::MemoryLocation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::MemoryLocation &, const char *)) &VPUNN::link<VPUNN::intf_11::MemoryLocation>, "C++: VPUNN::link(const enum VPUNN::intf_11::MemoryLocation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_11::VPUSubsystem &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_11::VPUSubsystem &, const char *)) &VPUNN::link<VPUNN::intf_11::VPUSubsystem>, "C++: VPUNN::link(const enum VPUNN::intf_11::VPUSubsystem &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_12::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_12::DataType &, const char *)) &VPUNN::link<VPUNN::intf_12::DataType>, "C++: VPUNN::link(const enum VPUNN::intf_12::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_12::Operation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_12::Operation &, const char *)) &VPUNN::link<VPUNN::intf_12::Operation>, "C++: VPUNN::link(const enum VPUNN::intf_12::Operation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_12::ExecutionMode &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_12::ExecutionMode &, const char *)) &VPUNN::link<VPUNN::intf_12::ExecutionMode>, "C++: VPUNN::link(const enum VPUNN::intf_12::ExecutionMode &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_12::Layout &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_12::Layout &, const char *)) &VPUNN::link<VPUNN::intf_12::Layout>, "C++: VPUNN::link(const enum VPUNN::intf_12::Layout &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

}


// File: VPUNN_3.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types13.h> // VPUNN::intf_13::DataType
#include <vpu/compatibility/types14.h> // VPUNN::intf_14::DataType
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::DataType
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::ExecutionMode

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_3(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::link(const enum VPUNN::intf_13::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_13::DataType &, const char *)) &VPUNN::link<VPUNN::intf_13::DataType>, "C++: VPUNN::link(const enum VPUNN::intf_13::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_14::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_14::DataType &, const char *)) &VPUNN::link<VPUNN::intf_14::DataType>, "C++: VPUNN::link(const enum VPUNN::intf_14::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_15::DataType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_15::DataType &, const char *)) &VPUNN::link<VPUNN::intf_15::DataType>, "C++: VPUNN::link(const enum VPUNN::intf_15::DataType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_15::ExecutionMode &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_15::ExecutionMode &, const char *)) &VPUNN::link<VPUNN::intf_15::ExecutionMode>, "C++: VPUNN::link(const enum VPUNN::intf_15::ExecutionMode &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::SoftmaxEquationType &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::SoftmaxEquationType &, const char *)) &VPUNN::link<VPUNN::SoftmaxEquationType>, "C++: VPUNN::link(const enum VPUNN::SoftmaxEquationType &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_dma_01x::MemoryLocation &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_dma_01x::MemoryLocation &, const char *)) &VPUNN::link<VPUNN::intf_dma_01x::MemoryLocation>, "C++: VPUNN::link(const enum VPUNN::intf_dma_01x::MemoryLocation &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_dma_01x::MemoryDirection &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_dma_01x::MemoryDirection &, const char *)) &VPUNN::link<VPUNN::intf_dma_01x::MemoryDirection>, "C++: VPUNN::link(const enum VPUNN::intf_dma_01x::MemoryDirection &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::link(const enum VPUNN::intf_dma_01x::Num_DMA_Engine &, const char *) file: line:29
	M("VPUNN").def("link", (struct std::pair<const int, const std::string > (*)(const enum VPUNN::intf_dma_01x::Num_DMA_Engine &, const char *)) &VPUNN::link<VPUNN::intf_dma_01x::Num_DMA_Engine>, "C++: VPUNN::link(const enum VPUNN::intf_dma_01x::Num_DMA_Engine &, const char *) --> struct std::pair<const int, const std::string >", pybind11::arg("enum_val"), pybind11::arg("name"));

	// VPUNN::createInverseMap(const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &) file: line:37
	M("VPUNN").def("createInverseMap", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > (*)(const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &)) &VPUNN::createInverseMap, "creates and inverse map given a direct map (EnumMap)\n\nC++: VPUNN::createInverseMap(const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &) --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > >", pybind11::arg("direct_map"));

	// VPUNN::link_logical(const std::string, const std::string) file: line:48
	M("VPUNN").def("link_logical", (struct std::pair<const std::string, const std::string > (*)(const std::string, const std::string)) &VPUNN::link_logical, "creates a pair to be added to the EnumTextLogicalMap\n\nC++: VPUNN::link_logical(const std::string, const std::string) --> struct std::pair<const std::string, const std::string >", pybind11::arg("name"), pybind11::arg("mapped_name"));

	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<std::string,void>, std::shared_ptr<VPUNN::has_mapToText<std::string,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_std_string_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<std::string,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::Num_DMA_Engine,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::Num_DMA_Engine,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_Num_DMA_Engine_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::Num_DMA_Engine,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::MemoryDirection,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::MemoryDirection,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_MemoryDirection_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::MemoryDirection,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<unsigned int,void>, std::shared_ptr<VPUNN::has_mapToText<unsigned int,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_unsigned_int_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<unsigned int,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::VPUDevice,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::VPUDevice,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_VPUDevice_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::VPUDevice,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::DataType,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::DataType,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_DataType_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::DataType,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::Layout,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::Layout,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_Layout_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::Layout,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<bool,void>, std::shared_ptr<VPUNN::has_mapToText<bool,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_bool_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<bool,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<int,void>, std::shared_ptr<VPUNN::has_mapToText<int,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_int_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<int,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<float,void>, std::shared_ptr<VPUNN::has_mapToText<float,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_float_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<float,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<const unsigned int,void>, std::shared_ptr<VPUNN::has_mapToText<const unsigned int,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_const_unsigned_int_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<const unsigned int,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<long long,void>, std::shared_ptr<VPUNN::has_mapToText<long long,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_long_long_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<long long,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::ISIStrategy,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::ISIStrategy,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_ISIStrategy_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::ISIStrategy,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::ExecutionMode,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::ExecutionMode,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_ExecutionMode_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::ExecutionMode,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::ActivationFunction,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::ActivationFunction,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_ActivationFunction_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::ActivationFunction,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::Swizzling,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::Swizzling,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_Swizzling_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::Swizzling,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::Operation,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::Operation,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_Operation_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::Operation,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
}


// File: VPUNN_4.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_4(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<const unsigned int &,void>, std::shared_ptr<VPUNN::has_mapToText<const unsigned int &,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_const_unsigned_int_&_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<const unsigned int &,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:82
		pybind11::class_<VPUNN::has_mapToText<unsigned long,void>, std::shared_ptr<VPUNN::has_mapToText<unsigned long,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_mapToText_unsigned_long_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<unsigned long,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_mapToText file: line:85
		pybind11::class_<VPUNN::has_mapToText<VPUNN::VPUTilingStrategy,void>, std::shared_ptr<VPUNN::has_mapToText<VPUNN::VPUTilingStrategy,void>>, std::is_same<const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &,const std::map<const int, const std::string, std::less<const int>, std::allocator<std::pair<const int, const std::string > > > &>> cl(M("VPUNN"), "has_mapToText_VPUNN_VPUTilingStrategy_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_mapToText<VPUNN::VPUTilingStrategy,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::Num_DMA_Engine,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::Num_DMA_Engine,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_Num_DMA_Engine_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::Num_DMA_Engine,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::MemoryDirection,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::MemoryDirection,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_MemoryDirection_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::MemoryDirection,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<unsigned int,void>, std::shared_ptr<VPUNN::has_enumName<unsigned int,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_unsigned_int_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<unsigned int,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::VPUDevice,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::VPUDevice,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_VPUDevice_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::VPUDevice,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<std::string,void>, std::shared_ptr<VPUNN::has_enumName<std::string,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_std_string_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<std::string,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::DataType,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::DataType,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_DataType_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::DataType,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::Layout,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::Layout,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_Layout_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::Layout,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<bool,void>, std::shared_ptr<VPUNN::has_enumName<bool,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_bool_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<bool,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<int,void>, std::shared_ptr<VPUNN::has_enumName<int,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_int_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<int,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<float,void>, std::shared_ptr<VPUNN::has_enumName<float,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_float_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<float,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<const unsigned int,void>, std::shared_ptr<VPUNN::has_enumName<const unsigned int,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_const_unsigned_int_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<const unsigned int,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<long long,void>, std::shared_ptr<VPUNN::has_enumName<long long,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_long_long_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<long long,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::ISIStrategy,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::ISIStrategy,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_ISIStrategy_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::ISIStrategy,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::ExecutionMode,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::ExecutionMode,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_ExecutionMode_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::ExecutionMode,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::ActivationFunction,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::ActivationFunction,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_ActivationFunction_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::ActivationFunction,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::Swizzling,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::Swizzling,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_Swizzling_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::Swizzling,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::Operation,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::Operation,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_Operation_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::Operation,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<const unsigned int &,void>, std::shared_ptr<VPUNN::has_enumName<const unsigned int &,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_const_unsigned_int_&_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<const unsigned int &,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:89
		pybind11::class_<VPUNN::has_enumName<unsigned long,void>, std::shared_ptr<VPUNN::has_enumName<unsigned long,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_enumName_unsigned_long_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<unsigned long,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	{ // VPUNN::has_enumName file: line:92
		pybind11::class_<VPUNN::has_enumName<VPUNN::VPUTilingStrategy,void>, std::shared_ptr<VPUNN::has_enumName<VPUNN::VPUTilingStrategy,void>>, std::is_same<std::string,std::string>> cl(M("VPUNN"), "has_enumName_VPUNN_VPUTilingStrategy_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_enumName<VPUNN::VPUTilingStrategy,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	// VPUNN::VPUDevice file: line:106
	pybind11::enum_<VPUNN::VPUDevice>(M("VPUNN"), "VPUDevice", "VPU IP generations\n\n ")
		.value("VPU_2_0", VPUNN::VPUDevice::VPU_2_0)
		.value("VPU_2_1", VPUNN::VPUDevice::VPU_2_1)
		.value("VPU_2_7", VPUNN::VPUDevice::VPU_2_7)
		.value("VPU_4_0", VPUNN::VPUDevice::VPU_4_0)
		.value("NPU_5_0", VPUNN::VPUDevice::NPU_5_0)
		.value("NPU_RESERVED", VPUNN::VPUDevice::NPU_RESERVED)
		.value("NPU_RESERVED_1", VPUNN::VPUDevice::NPU_RESERVED_1)
		.value("__size", VPUNN::VPUDevice::__size);

;

	// VPUNN::mapToText() file: line:112
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::VPUDevice>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:117
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::VPUDevice>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::DataType file: line:125
	pybind11::enum_<VPUNN::DataType>(M("VPUNN"), "DataType", "Supported Datatypes\n\n ")
		.value("UINT8", VPUNN::DataType::UINT8)
		.value("INT8", VPUNN::DataType::INT8)
		.value("FLOAT16", VPUNN::DataType::FLOAT16)
		.value("BFLOAT16", VPUNN::DataType::BFLOAT16)
		.value("BF8", VPUNN::DataType::BF8)
		.value("HF8", VPUNN::DataType::HF8)
		.value("UINT4", VPUNN::DataType::UINT4)
		.value("INT4", VPUNN::DataType::INT4)
		.value("UINT2", VPUNN::DataType::UINT2)
		.value("INT2", VPUNN::DataType::INT2)
		.value("UINT1", VPUNN::DataType::UINT1)
		.value("INT1", VPUNN::DataType::INT1)
		.value("INT32", VPUNN::DataType::INT32)
		.value("FLOAT32", VPUNN::DataType::FLOAT32)
		.value("UINT16", VPUNN::DataType::UINT16)
		.value("INT16", VPUNN::DataType::INT16)
		.value("FLOAT4", VPUNN::DataType::FLOAT4)
		.value("__size", VPUNN::DataType::__size);

;

	// VPUNN::mapToText() file: line:154
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::DataType>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:159
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::DataType>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::Operation file: line:167
	pybind11::enum_<VPUNN::Operation>(M("VPUNN"), "Operation", "HW operations\n\n ")
		.value("CONVOLUTION", VPUNN::Operation::CONVOLUTION)
		.value("DW_CONVOLUTION", VPUNN::Operation::DW_CONVOLUTION)
		.value("ELTWISE", VPUNN::Operation::ELTWISE)
		.value("MAXPOOL", VPUNN::Operation::MAXPOOL)
		.value("AVEPOOL", VPUNN::Operation::AVEPOOL)
		.value("CM_CONVOLUTION", VPUNN::Operation::CM_CONVOLUTION)
		.value("LAYER_NORM", VPUNN::Operation::LAYER_NORM)
		.value("ELTWISE_MUL", VPUNN::Operation::ELTWISE_MUL)
		.value("__size", VPUNN::Operation::__size);

;

	// VPUNN::mapToText() file: line:186
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::Operation>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

}


// File: VPUNN_5.cpp
#include <array> // std::array
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_5(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::enumName() file: line:191
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::Operation>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::ActivationFunction file: line:199
	pybind11::enum_<VPUNN::ActivationFunction>(M("VPUNN"), "ActivationFunction", "Supported activation functions\n\n ")
		.value("NONE", VPUNN::ActivationFunction::NONE)
		.value("RELU", VPUNN::ActivationFunction::RELU)
		.value("LRELU", VPUNN::ActivationFunction::LRELU)
		.value("ADD", VPUNN::ActivationFunction::ADD)
		.value("SUB", VPUNN::ActivationFunction::SUB)
		.value("MULT", VPUNN::ActivationFunction::MULT)
		.value("__size", VPUNN::ActivationFunction::__size);

;

	// VPUNN::mapToText() file: line:206
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::ActivationFunction>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:211
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::ActivationFunction>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::Swizzling file: line:219
	pybind11::enum_<VPUNN::Swizzling>(M("VPUNN"), "Swizzling", "Swizzling keys\n\n ")
		.value("KEY_0", VPUNN::Swizzling::KEY_0)
		.value("KEY_1", VPUNN::Swizzling::KEY_1)
		.value("KEY_2", VPUNN::Swizzling::KEY_2)
		.value("KEY_3", VPUNN::Swizzling::KEY_3)
		.value("KEY_4", VPUNN::Swizzling::KEY_4)
		.value("KEY_5", VPUNN::Swizzling::KEY_5)
		.value("__size", VPUNN::Swizzling::__size);

;

	// VPUNN::mapToText() file: line:225
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::Swizzling>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:230
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::Swizzling>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::ExecutionMode file: line:237
	pybind11::enum_<VPUNN::ExecutionMode>(M("VPUNN"), "ExecutionMode", "DPU execution modes")
		.value("VECTOR", VPUNN::ExecutionMode::VECTOR)
		.value("MATRIX", VPUNN::ExecutionMode::MATRIX)
		.value("VECTOR_FP16", VPUNN::ExecutionMode::VECTOR_FP16)
		.value("CUBOID_16x16", VPUNN::ExecutionMode::CUBOID_16x16)
		.value("CUBOID_8x16", VPUNN::ExecutionMode::CUBOID_8x16)
		.value("CUBOID_4x16", VPUNN::ExecutionMode::CUBOID_4x16)
		.value("dCIM_32x128", VPUNN::ExecutionMode::dCIM_32x128)
		.value("__size", VPUNN::ExecutionMode::__size);

;

	// VPUNN::mapToText() file: line:254
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::ExecutionMode>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:259
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::ExecutionMode>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::Layout file: line:280
	pybind11::enum_<VPUNN::Layout>(M("VPUNN"), "Layout", "Data layout\n\n ZMAJOR and CMAJOR are coming from VPU2.0, legacy layouts\n\n  XYZ, XZY, YXZ, YZX, ZXY, ZYX  were introduced for 2.7\n They are to interpreted as from  innermost(contiguous) to outermost dimension of the tensor\n eg: XYZ  is NCHW;   N=Batch is always outermost,  then channels (Z), height (Y), width (X)\n\n INVALID is first usage is exposure to VPUNN in some cases where Layout does not matter, is neither good Like (for\n input_1 when MAXPOOL).\n\n Equivalence legacy to xyz permutations:\n ZMAJOR is Z,X,Y\n CMAJOR is X,Y,Z\n\n ")
		.value("ZMAJOR", VPUNN::Layout::ZMAJOR)
		.value("CMAJOR", VPUNN::Layout::CMAJOR)
		.value("XYZ", VPUNN::Layout::XYZ)
		.value("XZY", VPUNN::Layout::XZY)
		.value("YXZ", VPUNN::Layout::YXZ)
		.value("YZX", VPUNN::Layout::YZX)
		.value("ZXY", VPUNN::Layout::ZXY)
		.value("ZYX", VPUNN::Layout::ZYX)
		.value("INVALID", VPUNN::Layout::INVALID)
		.value("__size", VPUNN::Layout::__size);

;

	// VPUNN::mapToText() file: line:287
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::Layout>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:292
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::Layout>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::ISIStrategy file: line:297
	pybind11::enum_<VPUNN::ISIStrategy>(M("VPUNN"), "ISIStrategy", "ISI_Strategy")
		.value("CLUSTERING", VPUNN::ISIStrategy::CLUSTERING)
		.value("SPLIT_OVER_H", VPUNN::ISIStrategy::SPLIT_OVER_H)
		.value("SPLIT_OVER_K", VPUNN::ISIStrategy::SPLIT_OVER_K)
		.value("__size", VPUNN::ISIStrategy::__size);

;

	// VPUNN::mapToText() file: line:304
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::ISIStrategy>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:309
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::ISIStrategy>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::VPUSubsystem file: line:317
	pybind11::enum_<VPUNN::VPUSubsystem>(M("VPUNN"), "VPUSubsystem", "VPU Hw subsystem\n\n ")
		.value("VPU_DPU", VPUNN::VPUSubsystem::VPU_DPU)
		.value("VPU_SHV", VPUNN::VPUSubsystem::VPU_SHV)
		.value("VPU_DMA", VPUNN::VPUSubsystem::VPU_DMA)
		.value("VPU_CPU", VPUNN::VPUSubsystem::VPU_CPU)
		.value("VPU_CMX", VPUNN::VPUSubsystem::VPU_CMX)
		.value("__size", VPUNN::VPUSubsystem::__size);

;

	// VPUNN::mapToText() file: line:324
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::VPUSubsystem>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:329
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::VPUSubsystem>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::CostSourceHint file: line:334
	pybind11::enum_<VPUNN::CostSourceHint>(M("VPUNN"), "CostSourceHint", "")
		.value("AUTO", VPUNN::CostSourceHint::AUTO)
		.value("NN", VPUNN::CostSourceHint::NN)
		.value("PROFILING_SERVICE", VPUNN::CostSourceHint::PROFILING_SERVICE)
		.value("THEORETICAL", VPUNN::CostSourceHint::THEORETICAL)
		.value("__size", VPUNN::CostSourceHint::__size);

;

	// VPUNN::mapToText() file: line:343
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::CostSourceHint>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:348
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::CostSourceHint>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::ProfilingServiceBackend file: line:352
	pybind11::enum_<VPUNN::ProfilingServiceBackend>(M("VPUNN"), "ProfilingServiceBackend", "")
		.value("SILICON", VPUNN::ProfilingServiceBackend::SILICON)
		.value("VPUEM", VPUNN::ProfilingServiceBackend::VPUEM)
		.value("__size", VPUNN::ProfilingServiceBackend::__size);

;

	// VPUNN::mapToText() file: line:358
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::ProfilingServiceBackend>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:363
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::ProfilingServiceBackend>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::MPEEngine file: line:371
	pybind11::enum_<VPUNN::MPEEngine>(M("VPUNN"), "MPEEngine", "MPE Engine types\n\n ")
		.value("SCL", VPUNN::MPEEngine::SCL)
		.value("DCIM", VPUNN::MPEEngine::DCIM)
		.value("__size", VPUNN::MPEEngine::__size);

;

	// VPUNN::mapToText() file: line:374
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::MPEEngine>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:378
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::MPEEngine>, "C++: VPUNN::enumName() --> std::string");

	{ // VPUNN::is_mapFromText_callable file: line:388
		pybind11::class_<VPUNN::is_mapFromText_callable<std::string,void>, std::shared_ptr<VPUNN::is_mapFromText_callable<std::string,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "is_mapFromText_callable_std_string_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::is_mapFromText_callable<std::string,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	// VPUNN::dtype_to_bytes(const enum VPUNN::DataType) file: line:28
	M("VPUNN").def("dtype_to_bytes", (int (*)(const enum VPUNN::DataType)) &VPUNN::dtype_to_bytes, "Get the size of the dtype\n\n \n a DataType object\n \n\n size in bytes if valid dtypes, else return -1 for invalid types\n\nC++: VPUNN::dtype_to_bytes(const enum VPUNN::DataType) --> int", pybind11::arg("dtype"));

	// VPUNN::dtype_to_bits(const enum VPUNN::DataType) file: line:64
	M("VPUNN").def("dtype_to_bits", (int (*)(const enum VPUNN::DataType)) &VPUNN::dtype_to_bits, "Get the size of the dtype in bits\n\n \n a DataType object\n \n\n size in bits if dtype valid, else return -1 for invalid types\n\nC++: VPUNN::dtype_to_bits(const enum VPUNN::DataType) --> int", pybind11::arg("dtype"));

	// VPUNN::types_per_byte(const enum VPUNN::DataType) file: line:107
	M("VPUNN").def("types_per_byte", (int (*)(const enum VPUNN::DataType)) &VPUNN::types_per_byte, "Get how many elements that have the data type given as a parameter fit in a byte\n types that do not fit in 1 byte are returning zero\n\n :\n if datatype is INT4 =>2 elements per one byte\n if datatype is INT6 =>1 elements per one byte\n : one byte is 8 bits\n\n \n to be analyzed\n \n\n the number of elements of datatype that can be stored in a byte\n\nC++: VPUNN::types_per_byte(const enum VPUNN::DataType) --> int", pybind11::arg("datatype"));

	// VPUNN::is_same_datatype_footprint(const enum VPUNN::DataType, const enum VPUNN::DataType) file: line:125
	M("VPUNN").def("is_same_datatype_footprint", (bool (*)(const enum VPUNN::DataType, const enum VPUNN::DataType)) &VPUNN::is_same_datatype_footprint, "true if the footprint of the 2 data types are the same (at bitlevel)\n\nC++: VPUNN::is_same_datatype_footprint(const enum VPUNN::DataType, const enum VPUNN::DataType) --> bool", pybind11::arg("d1"), pybind11::arg("d2"));

	// VPUNN::layout_to_order(enum VPUNN::Layout) file: line:137
	M("VPUNN").def("layout_to_order", (struct std::array<unsigned int, 4> (*)(enum VPUNN::Layout)) &VPUNN::layout_to_order, "Get the tensor serial order given a layout\n\n \n a Tensor Layout\n \n\n std::array<unsigned int, 4>, order of dimensions from innermost to outermost. values represent Dim::Act\n\n Invalid will be mapped to the default one : ZMAJOR/ZXY\n\nC++: VPUNN::layout_to_order(enum VPUNN::Layout) --> struct std::array<unsigned int, 4>", pybind11::arg("layout"));

	// VPUNN::mpe_mode_to_grid(enum VPUNN::ExecutionMode) file: line:172
	M("VPUNN").def("mpe_mode_to_grid", (class std::vector<unsigned int, class std::allocator<unsigned int> > (*)(enum VPUNN::ExecutionMode)) &VPUNN::mpe_mode_to_grid, "Return grid in X, Y, Z, B format (alignments?)\n Note: potentially OBSOLETE, since it does not depend on Device\n\n \n a DPUWorkload ExecutionMode\n \n\n std::vector<unsigned int>\n\nC++: VPUNN::mpe_mode_to_grid(enum VPUNN::ExecutionMode) --> class std::vector<unsigned int, class std::allocator<unsigned int> >", pybind11::arg("mode"));

	// VPUNN::mpe_mode_to_nthw_ntk_grid(enum VPUNN::ExecutionMode) file: line:190
	M("VPUNN").def("mpe_mode_to_nthw_ntk_grid", (class std::vector<unsigned int, class std::allocator<unsigned int> > (*)(enum VPUNN::ExecutionMode)) &VPUNN::mpe_mode_to_nthw_ntk_grid, "Return the NTHW/NTK grid in X, Y, Z, B format\n Note: potentially OBSOLETE, since it does not depend on Device\n\n \n a DPUWorkload ExecutionMode\n \n\n std::vector<unsigned int>\n\nC++: VPUNN::mpe_mode_to_nthw_ntk_grid(enum VPUNN::ExecutionMode) --> class std::vector<unsigned int, class std::allocator<unsigned int> >", pybind11::arg("mode"));

	// VPUNN::getDefaultLayout() file: line:20
	M("VPUNN").def("getDefaultLayout", (enum VPUNN::Layout (*)()) &VPUNN::getDefaultLayout, "default Layout that is equivalent with legacy ZMAJOR\n\nC++: VPUNN::getDefaultLayout() --> enum VPUNN::Layout");

	// VPUNN::default_init_swizzling() file: line:24
	M("VPUNN").def("default_init_swizzling", (enum VPUNN::Swizzling (*)()) &VPUNN::default_init_swizzling, "C++: VPUNN::default_init_swizzling() --> enum VPUNN::Swizzling");

	// VPUNN::out_terminator() file: line:28
	M("VPUNN").def("out_terminator", (std::string (*)()) &VPUNN::out_terminator, "C++: VPUNN::out_terminator() --> std::string");

	{ // VPUNN::HaloWorkload file: line:40
		pybind11::class_<VPUNN::HaloWorkload, std::shared_ptr<VPUNN::HaloWorkload>> cl(M("VPUNN"), "HaloWorkload", "halo information for a workload\n halo information: halo values are zero or positive and represent elements that are read from or written to the\n other tiles. Exception is input halo negative that models more memory tensor versus compute tensor.\n halo values make sense only when padding is zero. If padding is not zero halo is irrelevant (for inputs).\n\n Input0 Memory tensor= Input_0 (the compute tensor) minus  input_halo.  If input_halo is negative the memory\n tensor is larger (VPU40).\n  Output0 Memory Tensor = Output0 plus inbound_halo   (= Output Overlapped tensor , SplitOverlapped for next Layer\n  input)\n Split Overlapped input (eg SOHO) has input halo=0 by definition!\n\n SOHK aspects:\n fist step is arranging the input in SOHO on first 2 tiles identical,  and second 2 tiles identical\n first T (T0)  will produce half K  (SOK on a quarter) and write them to T0 and T1 (OWT =2), but will write also\n with HALO (the bottom rows) to Tiles2&3\n  also first T will be written in its output as inbound halo: Half of K from T1, and bottom row ad inbound halo\n  from T2(K/2 ch) and T3(K/2 channels)");
		cl.def( pybind11::init( [](){ return new VPUNN::HaloWorkload(); } ) );
		cl.def( pybind11::init( [](VPUNN::HaloWorkload const &o){ return new VPUNN::HaloWorkload(o); } ) );
		cl.def_readwrite("input_0_halo", &VPUNN::HaloWorkload::input_0_halo);
		cl.def_readwrite("output_0_halo", &VPUNN::HaloWorkload::output_0_halo);
		cl.def_readwrite("output_0_halo_broadcast_cnt", &VPUNN::HaloWorkload::output_0_halo_broadcast_cnt);
		cl.def_readwrite("output_0_inbound_halo", &VPUNN::HaloWorkload::output_0_inbound_halo);
		cl.def("__eq__", (bool (VPUNN::HaloWorkload::*)(const class VPUNN::HaloWorkload &) const) &VPUNN::HaloWorkload::operator==, "C++: VPUNN::HaloWorkload::operator==(const class VPUNN::HaloWorkload &) const --> bool", pybind11::arg("b"));
		cl.def("setVerticalNoHalo", (void (VPUNN::HaloWorkload::*)()) &VPUNN::HaloWorkload::setVerticalNoHalo, "C++: VPUNN::HaloWorkload::setVerticalNoHalo() --> void");
		cl.def("setHorizontalNoHalo", (void (VPUNN::HaloWorkload::*)()) &VPUNN::HaloWorkload::setHorizontalNoHalo, "C++: VPUNN::HaloWorkload::setHorizontalNoHalo() --> void");
		cl.def("setInboudHaloVerticalForBradcastAll", (void (VPUNN::HaloWorkload::*)(const unsigned int, const unsigned int, const unsigned int)) &VPUNN::HaloWorkload::setInboudHaloVerticalForBradcastAll, "C++: VPUNN::HaloWorkload::setInboudHaloVerticalForBradcastAll(const unsigned int, const unsigned int, const unsigned int) --> void", pybind11::arg("full_output_size"), pybind11::arg("output_remaining_to_process"), pybind11::arg("output_tile_dim"));
		cl.def("setInboudHaloHorizontalForBradcastAll", (void (VPUNN::HaloWorkload::*)(const unsigned int, const unsigned int, const unsigned int)) &VPUNN::HaloWorkload::setInboudHaloHorizontalForBradcastAll, "C++: VPUNN::HaloWorkload::setInboudHaloHorizontalForBradcastAll(const unsigned int, const unsigned int, const unsigned int) --> void", pybind11::arg("full_output_size"), pybind11::arg("output_remaining_to_process"), pybind11::arg("output_tile_dim"));
		cl.def("assign", (class VPUNN::HaloWorkload & (VPUNN::HaloWorkload::*)(const class VPUNN::HaloWorkload &)) &VPUNN::HaloWorkload::operator=, "C++: VPUNN::HaloWorkload::operator=(const class VPUNN::HaloWorkload &) --> class VPUNN::HaloWorkload &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::HaloWorkload const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );

		{ // VPUNN::HaloWorkload::HaloInfoHW file: line:43
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::HaloWorkload::HaloInfoHW, std::shared_ptr<VPUNN::HaloWorkload::HaloInfoHW>> cl(enclosing_class, "HaloInfoHW", "HW 2D dimension attributes of each dimension ends");
			cl.def( pybind11::init( [](){ return new VPUNN::HaloWorkload::HaloInfoHW(); } ) );
			cl.def( pybind11::init<int, int, int, int>(), pybind11::arg("top"), pybind11::arg("bottom"), pybind11::arg("left"), pybind11::arg("right") );

			cl.def( pybind11::init( [](VPUNN::HaloWorkload::HaloInfoHW const &o){ return new VPUNN::HaloWorkload::HaloInfoHW(o); } ) );
			cl.def_readwrite("top", &VPUNN::HaloWorkload::HaloInfoHW::top);
			cl.def_readwrite("bottom", &VPUNN::HaloWorkload::HaloInfoHW::bottom);
			cl.def_readwrite("left", &VPUNN::HaloWorkload::HaloInfoHW::left);
			cl.def_readwrite("right", &VPUNN::HaloWorkload::HaloInfoHW::right);
			cl.def("__eq__", (bool (VPUNN::HaloWorkload::HaloInfoHW::*)(const struct VPUNN::HaloWorkload::HaloInfoHW &) const) &VPUNN::HaloWorkload::HaloInfoHW::operator==, "C++: VPUNN::HaloWorkload::HaloInfoHW::operator==(const struct VPUNN::HaloWorkload::HaloInfoHW &) const --> bool", pybind11::arg("b"));
			cl.def("setVerticalNoHalo", (void (VPUNN::HaloWorkload::HaloInfoHW::*)()) &VPUNN::HaloWorkload::HaloInfoHW::setVerticalNoHalo, "C++: VPUNN::HaloWorkload::HaloInfoHW::setVerticalNoHalo() --> void");
			cl.def("setHorizontalNoHalo", (void (VPUNN::HaloWorkload::HaloInfoHW::*)()) &VPUNN::HaloWorkload::HaloInfoHW::setHorizontalNoHalo, "C++: VPUNN::HaloWorkload::HaloInfoHW::setHorizontalNoHalo() --> void");
			cl.def("assign", (struct VPUNN::HaloWorkload::HaloInfoHW & (VPUNN::HaloWorkload::HaloInfoHW::*)(const struct VPUNN::HaloWorkload::HaloInfoHW &)) &VPUNN::HaloWorkload::HaloInfoHW::operator=, "C++: VPUNN::HaloWorkload::HaloInfoHW::operator=(const struct VPUNN::HaloWorkload::HaloInfoHW &) --> struct VPUNN::HaloWorkload::HaloInfoHW &", pybind11::return_value_policy::reference, pybind11::arg(""));

			cl.def("__str__", [](VPUNN::HaloWorkload::HaloInfoHW const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
		}

		{ // VPUNN::HaloWorkload::HaloInfoHWC file: line:77
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::HaloWorkload::HaloInfoHWC, std::shared_ptr<VPUNN::HaloWorkload::HaloInfoHWC>, VPUNN::HaloWorkload::HaloInfoHW> cl(enclosing_class, "HaloInfoHWC", "HWC 3 dimension attributes of each dimension ends");
			cl.def( pybind11::init( [](){ return new VPUNN::HaloWorkload::HaloInfoHWC(); } ) );
			cl.def( pybind11::init<int, int, int, int, int, int>(), pybind11::arg("top"), pybind11::arg("bottom"), pybind11::arg("left"), pybind11::arg("right"), pybind11::arg("front"), pybind11::arg("back") );

			cl.def( pybind11::init<int, int, int, int>(), pybind11::arg("top"), pybind11::arg("bottom"), pybind11::arg("left"), pybind11::arg("right") );

			cl.def( pybind11::init( [](VPUNN::HaloWorkload::HaloInfoHWC const &o){ return new VPUNN::HaloWorkload::HaloInfoHWC(o); } ) );
			cl.def_readwrite("bottom", &VPUNN::HaloWorkload::HaloInfoHWC::bottom);
			cl.def_readwrite("left", &VPUNN::HaloWorkload::HaloInfoHWC::left);
			cl.def_readwrite("right", &VPUNN::HaloWorkload::HaloInfoHWC::right);
			cl.def_readwrite("top", &VPUNN::HaloWorkload::HaloInfoHWC::top);
			cl.def_readwrite("front", &VPUNN::HaloWorkload::HaloInfoHWC::front);
			cl.def_readwrite("back", &VPUNN::HaloWorkload::HaloInfoHWC::back);
			cl.def("setVerticalNoHalo", [](VPUNN::HaloWorkload::HaloInfoHWC &o) -> void { return o.setVerticalNoHalo(); }, "");
			cl.def("__eq__", (bool (VPUNN::HaloWorkload::HaloInfoHWC::*)(const class VPUNN::HaloWorkload::HaloInfoHWC &) const) &VPUNN::HaloWorkload::HaloInfoHWC::operator==, "C++: VPUNN::HaloWorkload::HaloInfoHWC::operator==(const class VPUNN::HaloWorkload::HaloInfoHWC &) const --> bool", pybind11::arg("b"));
			cl.def("isAllPositive", (bool (VPUNN::HaloWorkload::HaloInfoHWC::*)() const) &VPUNN::HaloWorkload::HaloInfoHWC::isAllPositive, "this function checks if all the halo data is positive (TBLRFB)\n\nC++: VPUNN::HaloWorkload::HaloInfoHWC::isAllPositive() const --> bool");
			cl.def("assign", (class VPUNN::HaloWorkload::HaloInfoHWC & (VPUNN::HaloWorkload::HaloInfoHWC::*)(const class VPUNN::HaloWorkload::HaloInfoHWC &)) &VPUNN::HaloWorkload::HaloInfoHWC::operator=, "C++: VPUNN::HaloWorkload::HaloInfoHWC::operator=(const class VPUNN::HaloWorkload::HaloInfoHWC &) --> class VPUNN::HaloWorkload::HaloInfoHWC &", pybind11::return_value_policy::reference, pybind11::arg(""));

			cl.def("__str__", [](VPUNN::HaloWorkload::HaloInfoHWC const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
		}

	}
}


// File: VPUNN_6.cpp
#include <sstream> // __str__
#include <vpu/cycles_interface_types.h> // VPUNN::Cycles

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_6(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Cycles file:vpu/cycles_interface_types.h line:57
		pybind11::class_<VPUNN::Cycles, std::shared_ptr<VPUNN::Cycles>> cl(M("VPUNN"), "Cycles", "helper class for CyclesInterfaceType");
		cl.def( pybind11::init( [](){ return new VPUNN::Cycles(); } ) );
		cl.def_static("toCycleInterfaceType", (unsigned int (*)(float)) &VPUNN::Cycles::toCycleInterfaceType<float,void>, "C++: VPUNN::Cycles::toCycleInterfaceType(float) --> unsigned int", pybind11::arg("conversion_number"));
		cl.def_static("toCycleInterfaceType", (unsigned int (*)(int)) &VPUNN::Cycles::toCycleInterfaceType<int,void>, "C++: VPUNN::Cycles::toCycleInterfaceType(int) --> unsigned int", pybind11::arg("conversion_number"));
		cl.def_static("toCycleInterfaceType", (unsigned int (*)(double)) &VPUNN::Cycles::toCycleInterfaceType<double,void>, "C++: VPUNN::Cycles::toCycleInterfaceType(double) --> unsigned int", pybind11::arg("conversion_number"));
		cl.def_static("isErrorCode", (bool (*)(const unsigned int &)) &VPUNN::Cycles::isErrorCode, "true if v has a value that can be an error code\n\n \n the value to be interpreted.\n \n\n true if the value is large enough to be mapped to an error code (error code might exist or not)\n\nC++: VPUNN::Cycles::isErrorCode(const unsigned int &) --> bool", pybind11::arg("v"));
		cl.def_static("toErrorText", (const char * (*)(const unsigned int &)) &VPUNN::Cycles::toErrorText, "provides a text if the value is an error or zero\n\n \n the value to be interpreted. normally 0-reasonable values means cycles, and values close to max limit\n are error codes\n \n\n a plain text with error name or \"UNKNOWN\"\n\nC++: VPUNN::Cycles::toErrorText(const unsigned int &) --> const char *", pybind11::return_value_policy::automatic_reference, pybind11::arg("v"));
		cl.def_static("cost_adder", (unsigned int (*)(const unsigned int, const unsigned int)) &VPUNN::Cycles::cost_adder, "safe sum of cycles considering also the error handling situations and overflow\n If the sum of the valid numbers gets in the error area , it will result Cycles::EROOR_SUM_TOO_LARGE\n If one of the terms is already an error, the error is kept as result (first term has priority of both are errors)\n\n \n left term\n \n\n right term\n\n \n the sum of lhs with rhs or the specific error in case that we have a sum\n too large or with error in terms\n\nC++: VPUNN::Cycles::cost_adder(const unsigned int, const unsigned int) --> unsigned int", pybind11::arg("lhs"), pybind11::arg("rhs"));
		cl.def_static("toCycleInterfaceType", (unsigned int (*)(unsigned int)) &VPUNN::Cycles::toCycleInterfaceType, "This method is an overload because if we got a CycleInterfaceType in this conversion method we want to\n propagate the error that already was assigned and not to change it to ERROR_INVALID_CONVERSION_TO_CYCLES\n\n \n number we are trying to convert\n \n\n the same number because it is already in CyclesInterfaceType\n\nC++: VPUNN::Cycles::toCycleInterfaceType(unsigned int) --> unsigned int", pybind11::arg("conversion_number"));
	}
}


// File: VPUNN_7.cpp
#include <array> // std::array
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::char_traits
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_7(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::dpu_schedule(const unsigned int, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int) file: line:56
	M("VPUNN").def("dpu_schedule", [](const unsigned int & a0, const class std::vector<unsigned int, class std::allocator<unsigned int> > & a1) -> unsigned int { return VPUNN::dpu_schedule(a0, a1); }, "", pybind11::arg("n_procesors"), pybind11::arg("tasks_cost"));
	M("VPUNN").def("dpu_schedule", (unsigned int (*)(const unsigned int, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int)) &VPUNN::dpu_schedule<unsigned int>, "C++: VPUNN::dpu_schedule(const unsigned int, const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const unsigned int) --> unsigned int", pybind11::arg("n_procesors"), pybind11::arg("tasks_cost"), pybind11::arg("runtime_overhead"));

	// VPUNN::multiply_vector(const struct std::array<unsigned int, 4> &) file: line:88
	M("VPUNN").def("multiply_vector", (unsigned int (*)(const struct std::array<unsigned int, 4> &)) &VPUNN::multiply_vector<unsigned int,4>, "C++: VPUNN::multiply_vector(const struct std::array<unsigned int, 4> &) --> unsigned int", pybind11::arg("vec"));

	// VPUNN::multiply_vector(const struct std::array<unsigned int, 2> &) file: line:88
	M("VPUNN").def("multiply_vector", (unsigned int (*)(const struct std::array<unsigned int, 2> &)) &VPUNN::multiply_vector<unsigned int,2>, "C++: VPUNN::multiply_vector(const struct std::array<unsigned int, 2> &) --> unsigned int", pybind11::arg("vec"));

	// VPUNN::ceil_division(unsigned int, unsigned int) file: line:113
	M("VPUNN").def("ceil_division", (unsigned int (*)(unsigned int, unsigned int)) &VPUNN::ceil_division<unsigned int>, "C++: VPUNN::ceil_division(unsigned int, unsigned int) --> unsigned int", pybind11::arg("a"), pybind11::arg("b"));

	// VPUNN::ceil_division(int, int) file: line:113
	M("VPUNN").def("ceil_division", (int (*)(int, int)) &VPUNN::ceil_division<int>, "C++: VPUNN::ceil_division(int, int) --> int", pybind11::arg("a"), pybind11::arg("b"));

	// VPUNN::ceil_division(unsigned long, unsigned long) file: line:113
	M("VPUNN").def("ceil_division", (unsigned long (*)(unsigned long, unsigned long)) &VPUNN::ceil_division<unsigned long>, "C++: VPUNN::ceil_division(unsigned long, unsigned long) --> unsigned long", pybind11::arg("a"), pybind11::arg("b"));

	// VPUNN::round_up(int, int) file: line:126
	M("VPUNN").def("round_up", (int (*)(int, int)) &VPUNN::round_up<int>, "C++: VPUNN::round_up(int, int) --> int", pybind11::arg("a"), pybind11::arg("b"));

	// VPUNN::round_up(unsigned int, unsigned int) file: line:126
	M("VPUNN").def("round_up", (unsigned int (*)(unsigned int, unsigned int)) &VPUNN::round_up<unsigned int>, "C++: VPUNN::round_up(unsigned int, unsigned int) --> unsigned int", pybind11::arg("a"), pybind11::arg("b"));

	// VPUNN::divide_and_multiply_vectors(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &) file: line:137
	M("VPUNN").def("divide_and_multiply_vectors", (unsigned int (*)(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &)) &VPUNN::divide_and_multiply_vectors, "Perform an elementwise ceil division and then multiply the results together\n\n \n\n \n\n\n \n\n unsigned int\n\nC++: VPUNN::divide_and_multiply_vectors(const class std::vector<unsigned int, class std::allocator<unsigned int> > &, const class std::vector<unsigned int, class std::allocator<unsigned int> > &) --> unsigned int", pybind11::arg("v1"), pybind11::arg("v2"));

	// VPUNN::helper_input_dim(unsigned int, unsigned int, unsigned int, unsigned int) file: line:156
	M("VPUNN").def("helper_input_dim", (unsigned int (*)(unsigned int, unsigned int, unsigned int, unsigned int)) &VPUNN::helper_input_dim, "Compute an input tensor dimension from the output dimension and the operation parameters\n\n \n the output dimension\n \n\n the kernel size\n \n\n the total padding\n \n\n the kernel stride\n \n\n unsigned int the input dimension\n\nC++: VPUNN::helper_input_dim(unsigned int, unsigned int, unsigned int, unsigned int) --> unsigned int", pybind11::arg("output"), pybind11::arg("kernel"), pybind11::arg("total_padding"), pybind11::arg("stride"));

	{ // VPUNN::WHCBTensorShape file: line:27
		pybind11::class_<VPUNN::WHCBTensorShape, std::shared_ptr<VPUNN::WHCBTensorShape>> cl(M("VPUNN"), "WHCBTensorShape", "");
		cl.def( pybind11::init<unsigned int, unsigned int, unsigned int, unsigned int>(), pybind11::arg("w"), pybind11::arg("h"), pybind11::arg("c"), pybind11::arg("b") );

		cl.def( pybind11::init( [](VPUNN::WHCBTensorShape const &o){ return new VPUNN::WHCBTensorShape(o); } ) );
		cl.def("x", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::x, "Get the x dimension\n\nC++: VPUNN::WHCBTensorShape::x() const --> unsigned int");
		cl.def("y", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::y, "Get the y dimension\n\nC++: VPUNN::WHCBTensorShape::y() const --> unsigned int");
		cl.def("z", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::z, "Get the z dimension\n\nC++: VPUNN::WHCBTensorShape::z() const --> unsigned int");
		cl.def("b", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::b, "Get the batch dimension\n\nC++: VPUNN::WHCBTensorShape::b() const --> unsigned int");
		cl.def("height", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::height, "Get the height\n\nC++: VPUNN::WHCBTensorShape::height() const --> unsigned int");
		cl.def("width", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::width, "Get the width\n\nC++: VPUNN::WHCBTensorShape::width() const --> unsigned int");
		cl.def("channels", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::channels, "Get the channels\n\nC++: VPUNN::WHCBTensorShape::channels() const --> unsigned int");
		cl.def("batches", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::batches, "Get the batches dimension\n\nC++: VPUNN::WHCBTensorShape::batches() const --> unsigned int");
		cl.def("set_width", (void (VPUNN::WHCBTensorShape::*)(unsigned int)) &VPUNN::WHCBTensorShape::set_width, "Set the width dimension\n\nC++: VPUNN::WHCBTensorShape::set_width(unsigned int) --> void", pybind11::arg("w"));
		cl.def("set_height", (void (VPUNN::WHCBTensorShape::*)(unsigned int)) &VPUNN::WHCBTensorShape::set_height, "Set the height dimension\n\nC++: VPUNN::WHCBTensorShape::set_height(unsigned int) --> void", pybind11::arg("h"));
		cl.def("set_channels", (void (VPUNN::WHCBTensorShape::*)(unsigned int)) &VPUNN::WHCBTensorShape::set_channels, "Set the channels dimension\n\nC++: VPUNN::WHCBTensorShape::set_channels(unsigned int) --> void", pybind11::arg("c"));
		cl.def("set_batches", (void (VPUNN::WHCBTensorShape::*)(unsigned int)) &VPUNN::WHCBTensorShape::set_batches, "Set the batches dimension\n\nC++: VPUNN::WHCBTensorShape::set_batches(unsigned int) --> void", pybind11::arg("b"));
		cl.def("numberOfElements", (unsigned int (VPUNN::WHCBTensorShape::*)() const) &VPUNN::WHCBTensorShape::numberOfElements, "Get the size in samples\n \n\n how many elements are in this tensor shape\n\nC++: VPUNN::WHCBTensorShape::numberOfElements() const --> unsigned int");
		cl.def("__eq__", (bool (VPUNN::WHCBTensorShape::*)(const class VPUNN::WHCBTensorShape &) const) &VPUNN::WHCBTensorShape::operator==, "equality test operator\n\nC++: VPUNN::WHCBTensorShape::operator==(const class VPUNN::WHCBTensorShape &) const --> bool", pybind11::arg("b"));
		cl.def("assign", (class VPUNN::WHCBTensorShape & (VPUNN::WHCBTensorShape::*)(const class VPUNN::WHCBTensorShape &)) &VPUNN::WHCBTensorShape::operator=, "C++: VPUNN::WHCBTensorShape::operator=(const class VPUNN::WHCBTensorShape &) --> class VPUNN::WHCBTensorShape &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::WHCBTensorShape const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::SEPModeInfo file: line:105
		pybind11::class_<VPUNN::SEPModeInfo, std::shared_ptr<VPUNN::SEPModeInfo>> cl(M("VPUNN"), "SEPModeInfo", "");
		cl.def( pybind11::init( [](){ return new VPUNN::SEPModeInfo(); } ) );
		cl.def( pybind11::init( [](VPUNN::SEPModeInfo const &o){ return new VPUNN::SEPModeInfo(o); } ) );
		cl.def_readwrite("sep_activators", &VPUNN::SEPModeInfo::sep_activators);
		cl.def_readwrite("storage_elements_pointers", &VPUNN::SEPModeInfo::storage_elements_pointers);
		cl.def_readwrite("actual_activators_input", &VPUNN::SEPModeInfo::actual_activators_input);
		cl.def_readwrite("no_sparse_map", &VPUNN::SEPModeInfo::no_sparse_map);
		cl.def("isEnabled", (bool (VPUNN::SEPModeInfo::*)() const) &VPUNN::SEPModeInfo::isEnabled, "C++: VPUNN::SEPModeInfo::isEnabled() const --> bool");
		cl.def("__eq__", (bool (VPUNN::SEPModeInfo::*)(const class VPUNN::SEPModeInfo &) const) &VPUNN::SEPModeInfo::operator==, "C++: VPUNN::SEPModeInfo::operator==(const class VPUNN::SEPModeInfo &) const --> bool", pybind11::arg("b"));
		cl.def("assign", (class VPUNN::SEPModeInfo & (VPUNN::SEPModeInfo::*)(const class VPUNN::SEPModeInfo &)) &VPUNN::SEPModeInfo::operator=, "C++: VPUNN::SEPModeInfo::operator=(const class VPUNN::SEPModeInfo &) --> class VPUNN::SEPModeInfo &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::SEPModeInfo const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	// VPUNN::compute_size_in_bytes(const long long, const enum VPUNN::DataType &) file: line:30
	M("VPUNN").def("compute_size_in_bytes", (long long (*)(const long long, const enum VPUNN::DataType &)) &VPUNN::compute_size_in_bytes<long long>, "C++: VPUNN::compute_size_in_bytes(const long long, const enum VPUNN::DataType &) --> long long", pybind11::arg("elements_count"), pybind11::arg("datatype"));

	// VPUNN::compute_size_in_bytes(const long, const enum VPUNN::DataType &) file: line:30
	M("VPUNN").def("compute_size_in_bytes", (long (*)(const long, const enum VPUNN::DataType &)) &VPUNN::compute_size_in_bytes<long>, "C++: VPUNN::compute_size_in_bytes(const long, const enum VPUNN::DataType &) --> long", pybind11::arg("elements_count"), pybind11::arg("datatype"));

	// VPUNN::compute_elements_count_from_bytes(const long, const enum VPUNN::DataType &) file: line:57
	M("VPUNN").def("compute_elements_count_from_bytes", (long (*)(const long, const enum VPUNN::DataType &)) &VPUNN::compute_elements_count_from_bytes, "compute the number of elements when we have their size in bytes and their type\n\n \n size in bytes of elements number we want to compute\n \n\n elements DataType\n \n\n a long that represent number of elements\n\nC++: VPUNN::compute_elements_count_from_bytes(const long, const enum VPUNN::DataType &) --> long", pybind11::arg("size_in_bytes"), pybind11::arg("datatype"));

	{ // VPUNN::VPUTensor file: line:33
		pybind11::class_<VPUNN::VPUTensor, std::shared_ptr<VPUNN::VPUTensor>> cl(M("VPUNN"), "VPUTensor", "Cost model tensor class\n\n ");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUTensor(); } ), "doc" );
		cl.def( pybind11::init( [](const struct std::array<unsigned int, 4> & a0){ return new VPUNN::VPUTensor(a0); } ), "doc" , pybind11::arg("shape"));
		cl.def( pybind11::init( [](const struct std::array<unsigned int, 4> & a0, enum VPUNN::DataType const & a1){ return new VPUNN::VPUTensor(a0, a1); } ), "doc" , pybind11::arg("shape"), pybind11::arg("dtype"));
		cl.def( pybind11::init( [](const struct std::array<unsigned int, 4> & a0, enum VPUNN::DataType const & a1, enum VPUNN::Layout const & a2){ return new VPUNN::VPUTensor(a0, a1, a2); } ), "doc" , pybind11::arg("shape"), pybind11::arg("dtype"), pybind11::arg("layout"));
		cl.def( pybind11::init<const struct std::array<unsigned int, 4> &, enum VPUNN::DataType, enum VPUNN::Layout, bool>(), pybind11::arg("shape"), pybind11::arg("dtype"), pybind11::arg("layout"), pybind11::arg("sparsity") );

		cl.def( pybind11::init( [](unsigned int const & a0, unsigned int const & a1, unsigned int const & a2, unsigned int const & a3, enum VPUNN::DataType const & a4){ return new VPUNN::VPUTensor(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("width"), pybind11::arg("height"), pybind11::arg("channels"), pybind11::arg("batch"), pybind11::arg("dtype"));
		cl.def( pybind11::init( [](unsigned int const & a0, unsigned int const & a1, unsigned int const & a2, unsigned int const & a3, enum VPUNN::DataType const & a4, enum VPUNN::Layout const & a5){ return new VPUNN::VPUTensor(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("width"), pybind11::arg("height"), pybind11::arg("channels"), pybind11::arg("batch"), pybind11::arg("dtype"), pybind11::arg("layout"));
		cl.def( pybind11::init<unsigned int, unsigned int, unsigned int, unsigned int, enum VPUNN::DataType, enum VPUNN::Layout, bool>(), pybind11::arg("width"), pybind11::arg("height"), pybind11::arg("channels"), pybind11::arg("batch"), pybind11::arg("dtype"), pybind11::arg("layout"), pybind11::arg("sparsity") );

		cl.def( pybind11::init<const struct std::array<unsigned int, 4> &, const class VPUNN::VPUTensor &>(), pybind11::arg("shape_"), pybind11::arg("rest") );

		cl.def( pybind11::init( [](VPUNN::VPUTensor const &o){ return new VPUNN::VPUTensor(o); } ) );
		cl.def("x", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::x, "Get the x dimension\n\nC++: VPUNN::VPUTensor::x() const --> unsigned int");
		cl.def("y", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::y, "Get the y dimension\n\nC++: VPUNN::VPUTensor::y() const --> unsigned int");
		cl.def("z", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::z, "Get the z dimension\n\nC++: VPUNN::VPUTensor::z() const --> unsigned int");
		cl.def("b", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::b, "Get the batch dimension\n\nC++: VPUNN::VPUTensor::b() const --> unsigned int");
		cl.def("height", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::height, "Get the height\n\nC++: VPUNN::VPUTensor::height() const --> unsigned int");
		cl.def("width", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::width, "Get the width\n\nC++: VPUNN::VPUTensor::width() const --> unsigned int");
		cl.def("channels", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::channels, "Get the channels\n\nC++: VPUNN::VPUTensor::channels() const --> unsigned int");
		cl.def("batches", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::batches, "Get the batches dimension\n\nC++: VPUNN::VPUTensor::batches() const --> unsigned int");
		cl.def("volume", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::volume, "Get the volume in number of samples (values)\n \n\n number of samples\n\nC++: VPUNN::VPUTensor::volume() const --> unsigned int");
		cl.def("is_any_float", (bool (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::is_any_float, "Check if the tensor is floating point\n \n\n true if floating point type\n\nC++: VPUNN::VPUTensor::is_any_float() const --> bool");
		cl.def("is_fp16family", (bool (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::is_fp16family, "Determines if tensor data type activates power circuits for fp16 or not. Is used for adjustment factors of power modeling\n and performance prediction etc.\n \n\n: make more robust mechanism to check for data types coverage, where each key of DataType have properties that \n        give more insights about the type, like: is_float, is_integer, is_signed, size_in_bytes, is_fp16family,\n        is_fp8family, is_i8family\n\nC++: VPUNN::VPUTensor::is_fp16family() const --> bool");
		cl.def("is_fp8family", (bool (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::is_fp8family, "C++: VPUNN::VPUTensor::is_fp8family() const --> bool");
		cl.def("is_i8family", (bool (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::is_i8family, "Determines if tensor data type activates power circuits for int8 or not. Is used for adjustment factors of power\n modeling and performance prediction etc.\n\nC++: VPUNN::VPUTensor::is_i8family() const --> bool");
		cl.def("is_any_int", (bool (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::is_any_int, "Check if the tensor is integer\n \n\n true if integer type\n\nC++: VPUNN::VPUTensor::is_any_int() const --> bool");
		cl.def("get_shape", (const struct std::array<unsigned int, 4> & (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::get_shape, "Get the shape\n \n\n a 4 vector containing the shape in convention XYZB\n\nC++: VPUNN::VPUTensor::get_shape() const --> const struct std::array<unsigned int, 4> &", pybind11::return_value_policy::reference);
		cl.def("set_shape", (void (VPUNN::VPUTensor::*)(struct std::array<unsigned int, 4>)) &VPUNN::VPUTensor::set_shape, "Set the VPUTensor shape\n \n\n in convention XYZB\n\nC++: VPUNN::VPUTensor::set_shape(struct std::array<unsigned int, 4>) --> void", pybind11::arg("in_shape"));
		cl.def("get_dtype", (enum VPUNN::DataType (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::get_dtype, "Get the datatype\n\nC++: VPUNN::VPUTensor::get_dtype() const --> enum VPUNN::DataType");
		cl.def("change_datatype_superficial", (enum VPUNN::DataType (VPUNN::VPUTensor::*)(enum VPUNN::DataType)) &VPUNN::VPUTensor::change_datatype_superficial, "changes the underlying data type only if same size new vs old\n \n\n newly set type.\n\nC++: VPUNN::VPUTensor::change_datatype_superficial(enum VPUNN::DataType) --> enum VPUNN::DataType", pybind11::arg("new_datatype"));
		cl.def("get_layout", (enum VPUNN::Layout (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::get_layout, "Get the layout\n\nC++: VPUNN::VPUTensor::get_layout() const --> enum VPUNN::Layout");
		cl.def("set_if_same_layout", (bool (VPUNN::VPUTensor::*)(enum VPUNN::Layout)) &VPUNN::VPUTensor::set_if_same_layout, "changes the layout type if new one has the same structure as old\n this change must not affect the shape or strides\n \n\n the desired layout\n \n\n true if new layout set, false otherwise\n\nC++: VPUNN::VPUTensor::set_if_same_layout(enum VPUNN::Layout) --> bool", pybind11::arg("new_layout"));
		cl.def("get_sparsity", (bool (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::get_sparsity, "Get the sparsity flag\n\nC++: VPUNN::VPUTensor::get_sparsity() const --> bool");
		cl.def("set_sparsity", (void (VPUNN::VPUTensor::*)(bool)) &VPUNN::VPUTensor::set_sparsity, "sets the sparsity flag\n\nC++: VPUNN::VPUTensor::set_sparsity(bool) --> void", pybind11::arg("sparsity_new"));
		cl.def("size", (unsigned int (VPUNN::VPUTensor::*)() const) &VPUNN::VPUTensor::size, "Get the size in bytes based on packmode\n \n\n size in bytes\n\nC++: VPUNN::VPUTensor::size() const --> unsigned int");
		cl.def("__eq__", (bool (VPUNN::VPUTensor::*)(const class VPUNN::VPUTensor &) const) &VPUNN::VPUTensor::operator==, "equality test operator\n\nC++: VPUNN::VPUTensor::operator==(const class VPUNN::VPUTensor &) const --> bool", pybind11::arg("b"));
		cl.def("assign", (class VPUNN::VPUTensor & (VPUNN::VPUTensor::*)(const class VPUNN::VPUTensor &)) &VPUNN::VPUTensor::operator=, "C++: VPUNN::VPUTensor::operator=(const class VPUNN::VPUTensor &) --> class VPUNN::VPUTensor &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::VPUTensor const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
}


// File: VPUNN_8.cpp
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_8(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::DPUWorkload file: line:30
		pybind11::class_<VPUNN::DPUWorkload, std::shared_ptr<VPUNN::DPUWorkload>> cl(M("VPUNN"), "DPUWorkload", "The base structure that encodes a DPU workloads\n Normally the tensors in/out that describe the operation are expected to be the compute tensors");
		cl.def( pybind11::init( [](VPUNN::DPUWorkload const &o){ return new VPUNN::DPUWorkload(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DPUWorkload(); } ) );
		cl.def_readwrite("device", &VPUNN::DPUWorkload::device);
		cl.def_readwrite("op", &VPUNN::DPUWorkload::op);
		cl.def_readwrite("inputs", &VPUNN::DPUWorkload::inputs);
		cl.def_readwrite("outputs", &VPUNN::DPUWorkload::outputs);
		cl.def_readwrite("kernels", &VPUNN::DPUWorkload::kernels);
		cl.def_readwrite("strides", &VPUNN::DPUWorkload::strides);
		cl.def_readwrite("padding", &VPUNN::DPUWorkload::padding);
		cl.def_readwrite("execution_order", &VPUNN::DPUWorkload::execution_order);
		cl.def_readwrite("activation_function", &VPUNN::DPUWorkload::activation_function);
		cl.def_readwrite("act_sparsity", &VPUNN::DPUWorkload::act_sparsity);
		cl.def_readwrite("weight_sparsity", &VPUNN::DPUWorkload::weight_sparsity);
		cl.def_readwrite("input_swizzling", &VPUNN::DPUWorkload::input_swizzling);
		cl.def_readwrite("output_swizzling", &VPUNN::DPUWorkload::output_swizzling);
		cl.def_readwrite("output_write_tiles", &VPUNN::DPUWorkload::output_write_tiles);
		cl.def_readwrite("offsets", &VPUNN::DPUWorkload::offsets);
		cl.def_readwrite("isi_strategy", &VPUNN::DPUWorkload::isi_strategy);
		cl.def_readwrite("weight_sparsity_enabled", &VPUNN::DPUWorkload::weight_sparsity_enabled);
		cl.def_readwrite("halo", &VPUNN::DPUWorkload::halo);
		cl.def_readwrite("sep_activators", &VPUNN::DPUWorkload::sep_activators);
		cl.def_readwrite("weight_type", &VPUNN::DPUWorkload::weight_type);
		cl.def_readwrite("layer_info", &VPUNN::DPUWorkload::layer_info);
		cl.def_readwrite("weightless_operation", &VPUNN::DPUWorkload::weightless_operation);
		cl.def_readwrite("in_place_output_memory", &VPUNN::DPUWorkload::in_place_output_memory);
		cl.def_readwrite("superdense_memory", &VPUNN::DPUWorkload::superdense_memory);
		cl.def_readwrite("input_autopad", &VPUNN::DPUWorkload::input_autopad);
		cl.def_readwrite("output_autopad", &VPUNN::DPUWorkload::output_autopad);
		cl.def_readwrite("cost_source_hint", &VPUNN::DPUWorkload::cost_source_hint);
		cl.def_readwrite("profiling_service_backend_hint", &VPUNN::DPUWorkload::profiling_service_backend_hint);
		cl.def_readwrite("mpe_engine", &VPUNN::DPUWorkload::mpe_engine);
		cl.def("get_layer_info", (std::string (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::get_layer_info, "C++: VPUNN::DPUWorkload::get_layer_info() const --> std::string");
		cl.def("set_layer_info", (void (VPUNN::DPUWorkload::*)(const std::string &)) &VPUNN::DPUWorkload::set_layer_info, "C++: VPUNN::DPUWorkload::set_layer_info(const std::string &) --> void", pybind11::arg("layer_info_name"));
		cl.def("set_inplace_input1", (void (VPUNN::DPUWorkload::*)(bool)) &VPUNN::DPUWorkload::set_inplace_input1, "C++: VPUNN::DPUWorkload::set_inplace_input1(bool) --> void", pybind11::arg("in_place"));
		cl.def("set_inplace_output", (void (VPUNN::DPUWorkload::*)(bool)) &VPUNN::DPUWorkload::set_inplace_output, "C++: VPUNN::DPUWorkload::set_inplace_output(bool) --> void", pybind11::arg("in_place"));
		cl.def("set_inplace_output_memory", (void (VPUNN::DPUWorkload::*)(bool)) &VPUNN::DPUWorkload::set_inplace_output_memory, "C++: VPUNN::DPUWorkload::set_inplace_output_memory(bool) --> void", pybind11::arg("in_place"));
		cl.def("is_inplace_output_memory", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_inplace_output_memory, "C++: VPUNN::DPUWorkload::is_inplace_output_memory() const --> bool");
		cl.def("is_inplace_output", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_inplace_output, "alias of is_inplace_output_memory\n\nC++: VPUNN::DPUWorkload::is_inplace_output() const --> bool");
		cl.def("is_weightless_operation", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_weightless_operation, "C++: VPUNN::DPUWorkload::is_weightless_operation() const --> bool");
		cl.def("is_inplace_input1", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_inplace_input1, "alias for is_weightless_operation\n\nC++: VPUNN::DPUWorkload::is_inplace_input1() const --> bool");
		cl.def("is_elementwise_like_operation", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_elementwise_like_operation, "detect if operation is elementwise fammily\n\nC++: VPUNN::DPUWorkload::is_elementwise_like_operation() const --> bool");
		cl.def("set_superdense", (void (VPUNN::DPUWorkload::*)(bool)) &VPUNN::DPUWorkload::set_superdense, "superdense setter. becomes with value\n\nC++: VPUNN::DPUWorkload::set_superdense(bool) --> void", pybind11::arg("superdense"));
		cl.def("is_superdense", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_superdense, "superdense getter\n\nC++: VPUNN::DPUWorkload::is_superdense() const --> bool");
		cl.def("is_input_autopad", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_input_autopad, "in autopad getter\n\nC++: VPUNN::DPUWorkload::is_input_autopad() const --> bool");
		cl.def("is_output_autopad", (bool (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::is_output_autopad, "out autopad getter\n\nC++: VPUNN::DPUWorkload::is_output_autopad() const --> bool");
		cl.def("set_input_autopad", (void (VPUNN::DPUWorkload::*)(bool)) &VPUNN::DPUWorkload::set_input_autopad, "in autopad setter\n\nC++: VPUNN::DPUWorkload::set_input_autopad(bool) --> void", pybind11::arg("autopad"));
		cl.def("set_output_autopad", (void (VPUNN::DPUWorkload::*)(bool)) &VPUNN::DPUWorkload::set_output_autopad, "out autopad setter\n\nC++: VPUNN::DPUWorkload::set_output_autopad(bool) --> void", pybind11::arg("autopad"));
		cl.def("set_all_swizzlings", (void (VPUNN::DPUWorkload::*)(enum VPUNN::Swizzling)) &VPUNN::DPUWorkload::set_all_swizzlings, "C++: VPUNN::DPUWorkload::set_all_swizzlings(enum VPUNN::Swizzling) --> void", pybind11::arg("toSet"));
		cl.def("get_weight_type", (enum VPUNN::DataType (VPUNN::DPUWorkload::*)() const) &VPUNN::DPUWorkload::get_weight_type, "gets the type of the weight tensor, considering also input type in case not set\n\nC++: VPUNN::DPUWorkload::get_weight_type() const --> enum VPUNN::DataType");
		cl.def("__eq__", (bool (VPUNN::DPUWorkload::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::DPUWorkload::operator==, "equality test operator\n\nC++: VPUNN::DPUWorkload::operator==(const struct VPUNN::DPUWorkload &) const --> bool", pybind11::arg("b"));
		cl.def("assign", (struct VPUNN::DPUWorkload & (VPUNN::DPUWorkload::*)(const struct VPUNN::DPUWorkload &)) &VPUNN::DPUWorkload::operator=, "C++: VPUNN::DPUWorkload::operator=(const struct VPUNN::DPUWorkload &) --> struct VPUNN::DPUWorkload &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::DPUWorkload const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
}


// File: VPUNN_9.cpp
#include <chrono> // std::chrono::_V2::system_clock
#include <chrono> // std::chrono::duration
#include <chrono> // std::chrono::time_point
#include <ratio> // std::ratio
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_9(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // std::chrono::duration file:chrono line:421
		pybind11::class_<std::chrono::duration<long,std::ratio<1, 1000000000>>, std::shared_ptr<std::chrono::duration<long,std::ratio<1, 1000000000>>>> cl(M("std::chrono"), "duration_long_std_ratio_1_1000000000_t", "");
		cl.def( pybind11::init( [](){ return new std::chrono::duration<long,std::ratio<1, 1000000000>>(); } ) );
		cl.def( pybind11::init( [](std::chrono::duration<long,std::ratio<1, 1000000000>> const &o){ return new std::chrono::duration<long,std::ratio<1, 1000000000>>(o); } ) );
		cl.def("assign", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator=, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator=(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference, pybind11::arg(""));
		cl.def("count", (long (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)() const) &std::chrono::duration<long, std::ratio<1, 1000000000> >::count, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::count() const --> long");
		cl.def("__pos__", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)() const) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator+, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator+() const --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >");
		cl.def("__neg__", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)() const) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator-, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator-() const --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >");
		cl.def("pre_increment", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)()) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator++, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator++() --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference);
		cl.def("post_increment", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(int)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator++, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator++(int) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >", pybind11::arg(""));
		cl.def("pre_decrement", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)()) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator--, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator--() --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference);
		cl.def("post_decrement", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(int)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator--, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator--(int) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >", pybind11::arg(""));
		cl.def("__iadd__", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator+=, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator+=(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference, pybind11::arg("__d"));
		cl.def("__isub__", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator-=, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator-=(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference, pybind11::arg("__d"));
		cl.def("__imul__", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(const long &)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator*=, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator*=(const long &) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference, pybind11::arg("__rhs"));
		cl.def("__itruediv__", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > & (std::chrono::duration<long,std::ratio<1, 1000000000>>::*)(const long &)) &std::chrono::duration<long, std::ratio<1, 1000000000> >::operator/=, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::operator/=(const long &) --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &", pybind11::return_value_policy::reference, pybind11::arg("__rhs"));
		cl.def_static("zero", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (*)()) &std::chrono::duration<long, std::ratio<1, 1000000000> >::zero, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::zero() --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >");
		cl.def_static("min", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (*)()) &std::chrono::duration<long, std::ratio<1, 1000000000> >::min, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::min() --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >");
		cl.def_static("max", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (*)()) &std::chrono::duration<long, std::ratio<1, 1000000000> >::max, "C++: std::chrono::duration<long, std::ratio<1, 1000000000> >::max() --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >");
	}
	{ // std::chrono::time_point file:chrono line:812
		pybind11::class_<std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>, std::shared_ptr<std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>>> cl(M("std::chrono"), "time_point_std_chrono__V2_system_clock_std_chrono_duration_long_std_ratio_1_1000000000_t", "");
		cl.def( pybind11::init( [](){ return new std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>(); } ) );
		cl.def( pybind11::init<const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &>(), pybind11::arg("__dur") );

		cl.def( pybind11::init( [](std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >> const &o){ return new std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>(o); } ) );
		cl.def("time_since_epoch", (struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > (std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>::*)() const) &std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::time_since_epoch, "C++: std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::time_since_epoch() const --> struct std::chrono::duration<long, struct std::ratio<1, 1000000000> >");
		cl.def("__iadd__", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > & (std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>::*)(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &)) &std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::operator+=, "C++: std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::operator+=(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &) --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > &", pybind11::return_value_policy::reference, pybind11::arg("__dur"));
		cl.def("__isub__", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > & (std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>::*)(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &)) &std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::operator-=, "C++: std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::operator-=(const struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > &) --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > &", pybind11::return_value_policy::reference, pybind11::arg("__dur"));
		cl.def_static("min", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > (*)()) &std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::min, "C++: std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::min() --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >");
		cl.def_static("max", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > (*)()) &std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::max, "C++: std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::max() --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >");
		cl.def("assign", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > & (std::chrono::time_point<std::chrono::_V2::system_clock,std::chrono::duration<long, std::ratio<1, 1000000000> >>::*)(const struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > &)) &std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::operator=, "C++: std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1, 1000000000> > >::operator=(const struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > &) --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_10.cpp
#include <functional> // std::equal_to
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <stdexcept> // std::runtime_error
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <unordered_map> // std::__detail::_Node_const_iterator
#include <unordered_map> // std::__detail::_Node_iterator
#include <unordered_map> // std::unordered_map
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_10(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::set_env_var(const std::string &, const std::string &) file: line:27
	M("VPUNN").def("set_env_var", (void (*)(const std::string &, const std::string &)) &VPUNN::set_env_var, "C++: VPUNN::set_env_var(const std::string &, const std::string &) --> void", pybind11::arg("name"), pybind11::arg("value"));

	// VPUNN::get_env_vars(const class std::vector<std::string, class std::allocator<std::string > > &) file: line:37
	M("VPUNN").def("get_env_vars", (class std::unordered_map<std::string, std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<struct std::pair<const std::string, std::string > > > (*)(const class std::vector<std::string, class std::allocator<std::string > > &)) &VPUNN::get_env_vars, "C++: VPUNN::get_env_vars(const class std::vector<std::string, class std::allocator<std::string > > &) --> class std::unordered_map<std::string, std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<struct std::pair<const std::string, std::string > > >", pybind11::arg("variables"));

	{ // VPUNN::ThreadSafeMap file: line:66
		pybind11::class_<VPUNN::ThreadSafeMap<unsigned int,float>, std::shared_ptr<VPUNN::ThreadSafeMap<unsigned int,float>>> cl(M("VPUNN"), "ThreadSafeMap_unsigned_int_float_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ThreadSafeMap<unsigned int,float>(); } ) );
		cl.def( pybind11::init( [](VPUNN::ThreadSafeMap<unsigned int,float> const &o){ return new VPUNN::ThreadSafeMap<unsigned int,float>(o); } ) );
		cl.def("assign", (class VPUNN::ThreadSafeMap<unsigned int, float> & (VPUNN::ThreadSafeMap<unsigned int,float>::*)(const class VPUNN::ThreadSafeMap<unsigned int, float> &)) &VPUNN::ThreadSafeMap<unsigned int, float>::operator=, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::operator=(const class VPUNN::ThreadSafeMap<unsigned int, float> &) --> class VPUNN::ThreadSafeMap<unsigned int, float> &", pybind11::return_value_policy::reference, pybind11::arg("other"));
		cl.def("contains", (bool (VPUNN::ThreadSafeMap<unsigned int,float>::*)(const unsigned int &) const) &VPUNN::ThreadSafeMap<unsigned int, float>::contains, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::contains(const unsigned int &) const --> bool", pybind11::arg("key"));
		cl.def("find", (bool (VPUNN::ThreadSafeMap<unsigned int,float>::*)(const unsigned int &, float &) const) &VPUNN::ThreadSafeMap<unsigned int, float>::find, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::find(const unsigned int &, float &) const --> bool", pybind11::arg("key"), pybind11::arg("value"));
		cl.def("size", (unsigned long (VPUNN::ThreadSafeMap<unsigned int,float>::*)() const) &VPUNN::ThreadSafeMap<unsigned int, float>::size, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::size() const --> unsigned long");
		cl.def("empty", (bool (VPUNN::ThreadSafeMap<unsigned int,float>::*)() const) &VPUNN::ThreadSafeMap<unsigned int, float>::empty, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::empty() const --> bool");
		cl.def("keys", (class std::vector<unsigned int, class std::allocator<unsigned int> > (VPUNN::ThreadSafeMap<unsigned int,float>::*)() const) &VPUNN::ThreadSafeMap<unsigned int, float>::keys, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::keys() const --> class std::vector<unsigned int, class std::allocator<unsigned int> >");
		cl.def("values", (class std::vector<float, class std::allocator<float> > (VPUNN::ThreadSafeMap<unsigned int,float>::*)() const) &VPUNN::ThreadSafeMap<unsigned int, float>::values, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::values() const --> class std::vector<float, class std::allocator<float> >");
		cl.def("insert", (void (VPUNN::ThreadSafeMap<unsigned int,float>::*)(const unsigned int &, const float &)) &VPUNN::ThreadSafeMap<unsigned int, float>::insert, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::insert(const unsigned int &, const float &) --> void", pybind11::arg("key"), pybind11::arg("value"));
		cl.def("remove", (bool (VPUNN::ThreadSafeMap<unsigned int,float>::*)(const unsigned int &)) &VPUNN::ThreadSafeMap<unsigned int, float>::remove, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::remove(const unsigned int &) --> bool", pybind11::arg("key"));
		cl.def("clear", (void (VPUNN::ThreadSafeMap<unsigned int,float>::*)()) &VPUNN::ThreadSafeMap<unsigned int, float>::clear, "C++: VPUNN::ThreadSafeMap<unsigned int, float>::clear() --> void");
	}
	// VPUNN::vec2int_str(const class std::vector<float, class std::allocator<float> > &) file: line:155
	M("VPUNN").def("vec2int_str", (const std::string (*)(const class std::vector<float, class std::allocator<float> > &)) &VPUNN::vec2int_str<float>, "C++: VPUNN::vec2int_str(const class std::vector<float, class std::allocator<float> > &) --> const std::string", pybind11::arg("vec"));

	// VPUNN::vec2int_str(const class std::vector<int, class std::allocator<int> > &) file: line:176
	M("VPUNN").def("vec2int_str", (const std::string (*)(const class std::vector<int, class std::allocator<int> > &)) &VPUNN::vec2int_str<int>, "C++: VPUNN::vec2int_str(const class std::vector<int, class std::allocator<int> > &) --> const std::string", pybind11::arg("vec"));

	// VPUNN::fnv1a_hash(const std::string &) file: line:194
	M("VPUNN").def("fnv1a_hash", (unsigned int (*)(const std::string &)) &VPUNN::fnv1a_hash, "C++: VPUNN::fnv1a_hash(const std::string &) --> unsigned int", pybind11::arg("str"));

	// VPUNN::fnv1a_hash(const class std::vector<float, class std::allocator<float> > &, const bool) file: line:207
	M("VPUNN").def("fnv1a_hash", [](const class std::vector<float, class std::allocator<float> > & a0) -> unsigned int { return VPUNN::fnv1a_hash(a0); }, "", pybind11::arg("vec"));
	M("VPUNN").def("fnv1a_hash", (unsigned int (*)(const class std::vector<float, class std::allocator<float> > &, const bool)) &VPUNN::fnv1a_hash, "C++: VPUNN::fnv1a_hash(const class std::vector<float, class std::allocator<float> > &, const bool) --> unsigned int", pybind11::arg("vec"), pybind11::arg("force_fractional_rescale"));

	{ // VPUNN::has_hash file: line:235
		pybind11::class_<VPUNN::has_hash<VPUNN::SHAVEWorkload,void>, std::shared_ptr<VPUNN::has_hash<VPUNN::SHAVEWorkload,void>>, std::integral_constant<bool,true>> cl(M("VPUNN"), "has_hash_VPUNN_SHAVEWorkload_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_hash<VPUNN::SHAVEWorkload,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::has_hash file: line:232
		pybind11::class_<VPUNN::has_hash<std::vector<float, std::allocator<float> >,void>, std::shared_ptr<VPUNN::has_hash<std::vector<float, std::allocator<float> >,void>>, std::integral_constant<bool,false>> cl(M("VPUNN"), "has_hash_std_vector_float_std_allocator_float_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_hash<std::vector<float, std::allocator<float> >,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,false>::*)() const) &std::integral_constant<bool, false>::operator(), "C++: std::integral_constant<bool, false>::operator()() const --> bool");
	}
	// VPUNN::trim_csv_str(const std::string &) file: line:253
	M("VPUNN").def("trim_csv_str", (std::string (*)(const std::string &)) &VPUNN::trim_csv_str, "C++: VPUNN::trim_csv_str(const std::string &) --> std::string", pybind11::arg("str"));

	{ // VPUNN::SHAVEWorkload file: line:31
		pybind11::class_<VPUNN::SHAVEWorkload, std::shared_ptr<VPUNN::SHAVEWorkload>> cl(M("VPUNN"), "SHAVEWorkload", "describes a Software layer (SHAVE) request");
		cl.def( pybind11::init( [](const std::string & a0, const enum VPUNN::VPUDevice & a1, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a2, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a3){ return new VPUNN::SHAVEWorkload(a0, a1, a2, a3); } ), "doc" , pybind11::arg("operation_name"), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("outputs"));
		cl.def( pybind11::init( [](const std::string & a0, const enum VPUNN::VPUDevice & a1, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a2, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a3, const class std::vector<class std::variant<int, float, std::string, bool>, class std::allocator<class std::variant<int, float, std::string, bool> > > & a4){ return new VPUNN::SHAVEWorkload(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("operation_name"), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("params"));
		cl.def( pybind11::init( [](const std::string & a0, const enum VPUNN::VPUDevice & a1, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a2, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a3, const class std::vector<class std::variant<int, float, std::string, bool>, class std::allocator<class std::variant<int, float, std::string, bool> > > & a4, const class std::map<std::string, class std::variant<int, float, std::string, bool>, struct std::less<std::string >, class std::allocator<struct std::pair<const std::string, class std::variant<int, float, std::string, bool> > > > & a5){ return new VPUNN::SHAVEWorkload(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("operation_name"), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("params"), pybind11::arg("extra_param"));
		cl.def( pybind11::init<const std::string &, const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class std::variant<int, float, std::string, bool>, class std::allocator<class std::variant<int, float, std::string, bool> > > &, const class std::map<std::string, class std::variant<int, float, std::string, bool>, struct std::less<std::string >, class std::allocator<struct std::pair<const std::string, class std::variant<int, float, std::string, bool> > > > &, const std::string &>(), pybind11::arg("operation_name"), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("params"), pybind11::arg("extra_param"), pybind11::arg("loc_name") );

		cl.def( pybind11::init( [](VPUNN::SHAVEWorkload const &o){ return new VPUNN::SHAVEWorkload(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::SHAVEWorkload(); } ) );
		cl.def("assign", (class VPUNN::SHAVEWorkload & (VPUNN::SHAVEWorkload::*)(const class VPUNN::SHAVEWorkload &)) &VPUNN::SHAVEWorkload::operator=, "C++: VPUNN::SHAVEWorkload::operator=(const class VPUNN::SHAVEWorkload &) --> class VPUNN::SHAVEWorkload &", pybind11::return_value_policy::reference, pybind11::arg(""));
		cl.def("get_name", (std::string (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_name, "C++: VPUNN::SHAVEWorkload::get_name() const --> std::string");
		cl.def("get_device", (enum VPUNN::VPUDevice (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_device, "C++: VPUNN::SHAVEWorkload::get_device() const --> enum VPUNN::VPUDevice");
		cl.def("get_inputs", (const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_inputs, "C++: VPUNN::SHAVEWorkload::get_inputs() const --> const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &", pybind11::return_value_policy::reference);
		cl.def("get_outputs", (const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_outputs, "C++: VPUNN::SHAVEWorkload::get_outputs() const --> const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &", pybind11::return_value_policy::reference);
		cl.def("get_params", (const class std::vector<class std::variant<int, float, std::string, bool>, class std::allocator<class std::variant<int, float, std::string, bool> > > & (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_params, "C++: VPUNN::SHAVEWorkload::get_params() const --> const class std::vector<class std::variant<int, float, std::string, bool>, class std::allocator<class std::variant<int, float, std::string, bool> > > &", pybind11::return_value_policy::reference);
		cl.def("get_extra_params", (const class std::map<std::string, class std::variant<int, float, std::string, bool>, struct std::less<std::string >, class std::allocator<struct std::pair<const std::string, class std::variant<int, float, std::string, bool> > > > & (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_extra_params, "C++: VPUNN::SHAVEWorkload::get_extra_params() const --> const class std::map<std::string, class std::variant<int, float, std::string, bool>, struct std::less<std::string >, class std::allocator<struct std::pair<const std::string, class std::variant<int, float, std::string, bool> > > > &", pybind11::return_value_policy::reference);
		cl.def("get_loc_name", (const std::string & (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::get_loc_name, "C++: VPUNN::SHAVEWorkload::get_loc_name() const --> const std::string &", pybind11::return_value_policy::reference);
		cl.def("hash", (unsigned int (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::hash, "C++: VPUNN::SHAVEWorkload::hash() const --> unsigned int");
		cl.def("toString", (std::string (VPUNN::SHAVEWorkload::*)() const) &VPUNN::SHAVEWorkload::toString, "C++: VPUNN::SHAVEWorkload::toString() const --> std::string");

		cl.def("__str__", [](VPUNN::SHAVEWorkload const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	// VPUNN::LogLevel file: line:27
	pybind11::enum_<VPUNN::LogLevel>(M("VPUNN"), "LogLevel", "Logger verbosity levels (same as VPUX)\n\n ")
		.value("None", VPUNN::LogLevel::None)
		.value("Fatal", VPUNN::LogLevel::Fatal)
		.value("Error", VPUNN::LogLevel::Error)
		.value("Warning", VPUNN::LogLevel::Warning)
		.value("Info", VPUNN::LogLevel::Info)
		.value("Debug", VPUNN::LogLevel::Debug)
		.value("Trace", VPUNN::LogLevel::Trace);

;

	// VPUNN::toString(enum VPUNN::LogLevel) file: line:48
	M("VPUNN").def("toString", (const std::string (*)(enum VPUNN::LogLevel)) &VPUNN::toString, "Convert a LegLevel to an uppercase string\n\n \n\n \n\n const std::string\n\nC++: VPUNN::toString(enum VPUNN::LogLevel) --> const std::string", pybind11::arg("level"));

	// VPUNN::throw_error(std::string) file: line:248
	M("VPUNN").def("throw_error", (void (*)(std::string)) &VPUNN::throw_error<std::runtime_error>, "C++: VPUNN::throw_error(std::string) --> void", pybind11::arg("msg"));

}


// File: VPUNN_11.cpp
#include <array> // std::array
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_11(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::MemoryLocation file: line:55
	pybind11::enum_<VPUNN::MemoryLocation>(M("VPUNN"), "MemoryLocation", "Memory locations\n\n ")
		.value("DRAM", VPUNN::MemoryLocation::DRAM)
		.value("CMX", VPUNN::MemoryLocation::CMX)
		.value("CSRAM", VPUNN::MemoryLocation::CSRAM)
		.value("UPA", VPUNN::MemoryLocation::UPA)
		.value("__size", VPUNN::MemoryLocation::__size);

;

	// VPUNN::mapToText() file: line:63
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::MemoryLocation>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:68
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::MemoryLocation>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::MemoryDirection file: line:77
	pybind11::enum_<VPUNN::MemoryDirection>(M("VPUNN"), "MemoryDirection", "Memory directions DDR <> CMX.\n Applies to DMA transfers\n\n ")
		.value("DDR2CMX", VPUNN::MemoryDirection::DDR2CMX)
		.value("CMX2CMX", VPUNN::MemoryDirection::CMX2CMX)
		.value("CMX2DDR", VPUNN::MemoryDirection::CMX2DDR)
		.value("DDR2DDR", VPUNN::MemoryDirection::DDR2DDR)
		.value("__size", VPUNN::MemoryDirection::__size);

;

	// VPUNN::mapToText() file: line:85
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::MemoryDirection>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:90
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::MemoryDirection>, "C++: VPUNN::enumName() --> std::string");

	// VPUNN::Num_DMA_Engine file: line:97
	pybind11::enum_<VPUNN::Num_DMA_Engine>(M("VPUNN"), "Num_DMA_Engine", "Number of DMA engine used")
		.value("Num_Engine_1", VPUNN::Num_DMA_Engine::Num_Engine_1)
		.value("Num_Engine_2", VPUNN::Num_DMA_Engine::Num_Engine_2)
		.value("__size", VPUNN::Num_DMA_Engine::__size);

;

	// VPUNN::mapToText() file: line:104
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::Num_DMA_Engine>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:109
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::Num_DMA_Engine>, "C++: VPUNN::enumName() --> std::string");

	{ // VPUNN::DMAWorkload file: line:117
		pybind11::class_<VPUNN::DMAWorkload, std::shared_ptr<VPUNN::DMAWorkload>> cl(M("VPUNN"), "DMAWorkload", "The base structure that encodes a DMA workloads\n \n\n Will be removed in next releases");
		cl.def( pybind11::init( [](){ return new VPUNN::DMAWorkload(); } ) );
		cl.def( pybind11::init( [](VPUNN::DMAWorkload const &o){ return new VPUNN::DMAWorkload(o); } ) );
		cl.def_readwrite("device", &VPUNN::DMAWorkload::device);
		cl.def_readwrite("input", &VPUNN::DMAWorkload::input);
		cl.def_readwrite("output", &VPUNN::DMAWorkload::output);
		cl.def_readwrite("input_location", &VPUNN::DMAWorkload::input_location);
		cl.def_readwrite("output_location", &VPUNN::DMAWorkload::output_location);
		cl.def_readwrite("output_write_tiles", &VPUNN::DMAWorkload::output_write_tiles);

		cl.def("__str__", [](VPUNN::DMAWorkload const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::DMANNWorkload_NPU27 file: line:135
		pybind11::class_<VPUNN::DMANNWorkload_NPU27, std::shared_ptr<VPUNN::DMANNWorkload_NPU27>> cl(M("VPUNN"), "DMANNWorkload_NPU27", "The structure that encodes a DMA workloads for DMA NN\n\n This is particular for NPU2.7.");
		cl.def( pybind11::init( [](){ return new VPUNN::DMANNWorkload_NPU27(); } ) );
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1, int const & a2, int const & a3, int const & a4, int const & a5, int const & a6, int const & a7, int const & a8, enum VPUNN::MemoryDirection const & a9){ return new VPUNN::DMANNWorkload_NPU27(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_num_planes"), pybind11::arg("_length"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_src_stride"), pybind11::arg("_dst_stride"), pybind11::arg("_src_plane_stride"), pybind11::arg("_dst_plane_stride"), pybind11::arg("_transfer_direction"));
		cl.def( pybind11::init<enum VPUNN::VPUDevice, int, int, int, int, int, int, int, int, enum VPUNN::MemoryDirection, std::string>(), pybind11::arg("_device"), pybind11::arg("_num_planes"), pybind11::arg("_length"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_src_stride"), pybind11::arg("_dst_stride"), pybind11::arg("_src_plane_stride"), pybind11::arg("_dst_plane_stride"), pybind11::arg("_transfer_direction"), pybind11::arg("_loc_name") );

		cl.def( pybind11::init( [](VPUNN::DMANNWorkload_NPU27 const &o){ return new VPUNN::DMANNWorkload_NPU27(o); } ) );
		cl.def_readwrite("device", &VPUNN::DMANNWorkload_NPU27::device);
		cl.def_readwrite("num_planes", &VPUNN::DMANNWorkload_NPU27::num_planes);
		cl.def_readwrite("length", &VPUNN::DMANNWorkload_NPU27::length);
		cl.def_readwrite("src_width", &VPUNN::DMANNWorkload_NPU27::src_width);
		cl.def_readwrite("dst_width", &VPUNN::DMANNWorkload_NPU27::dst_width);
		cl.def_readwrite("src_stride", &VPUNN::DMANNWorkload_NPU27::src_stride);
		cl.def_readwrite("dst_stride", &VPUNN::DMANNWorkload_NPU27::dst_stride);
		cl.def_readwrite("src_plane_stride", &VPUNN::DMANNWorkload_NPU27::src_plane_stride);
		cl.def_readwrite("dst_plane_stride", &VPUNN::DMANNWorkload_NPU27::dst_plane_stride);
		cl.def_readwrite("transfer_direction", &VPUNN::DMANNWorkload_NPU27::transfer_direction);
		cl.def_readwrite("loc_name", &VPUNN::DMANNWorkload_NPU27::loc_name);
		cl.def_readonly("_member_map", &VPUNN::DMANNWorkload_NPU27::_member_map);
		cl.def("getAccessedBytes", (int (VPUNN::DMANNWorkload_NPU27::*)() const) &VPUNN::DMANNWorkload_NPU27::getAccessedBytes, "C++: VPUNN::DMANNWorkload_NPU27::getAccessedBytes() const --> int");
		cl.def_static("get_wl_name", (const std::string (*)()) &VPUNN::DMANNWorkload_NPU27::get_wl_name, "C++: VPUNN::DMANNWorkload_NPU27::get_wl_name() --> const std::string");
		cl.def_static("_get_member_names", (const class std::vector<std::string, class std::allocator<std::string > > (*)()) &VPUNN::DMANNWorkload_NPU27::_get_member_names, "C++: VPUNN::DMANNWorkload_NPU27::_get_member_names() --> const class std::vector<std::string, class std::allocator<std::string > >");

		cl.def("__str__", [](VPUNN::DMANNWorkload_NPU27 const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::DMANNWorkload_NPU40_50 file: line:256
		pybind11::class_<VPUNN::DMANNWorkload_NPU40_50, std::shared_ptr<VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "DMANNWorkload_NPU40_50", "placeholder/reserved name\n DMA descriptor for NPU4.0++\n 6D addressing mode");
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0){ return new VPUNN::DMANNWorkload_NPU40_50(a0); } ), "doc" , pybind11::arg("_device"));
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1){ return new VPUNN::DMANNWorkload_NPU40_50(a0, a1); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_src_width"));
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1, int const & a2){ return new VPUNN::DMANNWorkload_NPU40_50(a0, a1, a2); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"));
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1, int const & a2, int const & a3){ return new VPUNN::DMANNWorkload_NPU40_50(a0, a1, a2, a3); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_num_dim"));
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1, int const & a2, int const & a3, struct std::array<struct VPUNN::DMANNWorkload_NPU40_50::SizeStride, 5> const & a4){ return new VPUNN::DMANNWorkload_NPU40_50(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_num_dim"), pybind11::arg("_e_dim"));
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1, int const & a2, int const & a3, struct std::array<struct VPUNN::DMANNWorkload_NPU40_50::SizeStride, 5> const & a4, enum VPUNN::Num_DMA_Engine const & a5){ return new VPUNN::DMANNWorkload_NPU40_50(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_num_dim"), pybind11::arg("_e_dim"), pybind11::arg("_num_engine"));
		cl.def( pybind11::init( [](enum VPUNN::VPUDevice const & a0, int const & a1, int const & a2, int const & a3, struct std::array<struct VPUNN::DMANNWorkload_NPU40_50::SizeStride, 5> const & a4, enum VPUNN::Num_DMA_Engine const & a5, enum VPUNN::MemoryDirection const & a6){ return new VPUNN::DMANNWorkload_NPU40_50(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("_device"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_num_dim"), pybind11::arg("_e_dim"), pybind11::arg("_num_engine"), pybind11::arg("_transfer_direction"));
		cl.def( pybind11::init<enum VPUNN::VPUDevice, int, int, int, struct std::array<struct VPUNN::DMANNWorkload_NPU40_50::SizeStride, 5>, enum VPUNN::Num_DMA_Engine, enum VPUNN::MemoryDirection, std::string>(), pybind11::arg("_device"), pybind11::arg("_src_width"), pybind11::arg("_dst_width"), pybind11::arg("_num_dim"), pybind11::arg("_e_dim"), pybind11::arg("_num_engine"), pybind11::arg("_transfer_direction"), pybind11::arg("_loc_name") );

		cl.def( pybind11::init( [](){ return new VPUNN::DMANNWorkload_NPU40_50(); } ) );
		cl.def( pybind11::init( [](VPUNN::DMANNWorkload_NPU40_50 const &o){ return new VPUNN::DMANNWorkload_NPU40_50(o); } ) );
		cl.def_readwrite("device", &VPUNN::DMANNWorkload_NPU40_50::device);
		cl.def_readwrite("src_width", &VPUNN::DMANNWorkload_NPU40_50::src_width);
		cl.def_readwrite("dst_width", &VPUNN::DMANNWorkload_NPU40_50::dst_width);
		cl.def_readwrite("num_dim", &VPUNN::DMANNWorkload_NPU40_50::num_dim);
		cl.def_readwrite("e_dim", &VPUNN::DMANNWorkload_NPU40_50::e_dim);
		cl.def_readwrite("num_engine", &VPUNN::DMANNWorkload_NPU40_50::num_engine);
		cl.def_readwrite("transfer_direction", &VPUNN::DMANNWorkload_NPU40_50::transfer_direction);
		cl.def_readwrite("loc_name", &VPUNN::DMANNWorkload_NPU40_50::loc_name);
		cl.def_readonly("_member_map", &VPUNN::DMANNWorkload_NPU40_50::_member_map);
		cl.def("getAccessedBytes", (int (VPUNN::DMANNWorkload_NPU40_50::*)() const) &VPUNN::DMANNWorkload_NPU40_50::getAccessedBytes, "How many bytes are being transferred read and written\n\nC++: VPUNN::DMANNWorkload_NPU40_50::getAccessedBytes() const --> int");
		cl.def_static("get_wl_name", (const std::string (*)()) &VPUNN::DMANNWorkload_NPU40_50::get_wl_name, "C++: VPUNN::DMANNWorkload_NPU40_50::get_wl_name() --> const std::string");
		cl.def_static("_get_member_names", (const class std::vector<std::string, class std::allocator<std::string > > (*)()) &VPUNN::DMANNWorkload_NPU40_50::_get_member_names, "C++: VPUNN::DMANNWorkload_NPU40_50::_get_member_names() --> const class std::vector<std::string, class std::allocator<std::string > >");

		cl.def("__str__", [](VPUNN::DMANNWorkload_NPU40_50 const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );

		{ // VPUNN::DMANNWorkload_NPU40_50::SizeStride file: line:268
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::DMANNWorkload_NPU40_50::SizeStride, std::shared_ptr<VPUNN::DMANNWorkload_NPU40_50::SizeStride>> cl(enclosing_class, "SizeStride", "");
			cl.def( pybind11::init( [](){ return new VPUNN::DMANNWorkload_NPU40_50::SizeStride(); } ) );
			cl.def( pybind11::init( [](VPUNN::DMANNWorkload_NPU40_50::SizeStride const &o){ return new VPUNN::DMANNWorkload_NPU40_50::SizeStride(o); } ) );
			cl.def_readwrite("src_stride", &VPUNN::DMANNWorkload_NPU40_50::SizeStride::src_stride);
			cl.def_readwrite("dst_stride", &VPUNN::DMANNWorkload_NPU40_50::SizeStride::dst_stride);
			cl.def_readwrite("src_dim_size", &VPUNN::DMANNWorkload_NPU40_50::SizeStride::src_dim_size);
			cl.def_readwrite("dst_dim_size", &VPUNN::DMANNWorkload_NPU40_50::SizeStride::dst_dim_size);
			cl.def("assign", (struct VPUNN::DMANNWorkload_NPU40_50::SizeStride & (VPUNN::DMANNWorkload_NPU40_50::SizeStride::*)(const struct VPUNN::DMANNWorkload_NPU40_50::SizeStride &)) &VPUNN::DMANNWorkload_NPU40_50::SizeStride::operator=, "C++: VPUNN::DMANNWorkload_NPU40_50::SizeStride::operator=(const struct VPUNN::DMANNWorkload_NPU40_50::SizeStride &) --> struct VPUNN::DMANNWorkload_NPU40_50::SizeStride &", pybind11::return_value_policy::reference, pybind11::arg(""));
		}

	}
	// VPUNN::create_DMANNWorkload_NPU40() file: line:404
	M("VPUNN").def("create_DMANNWorkload_NPU40", (const struct VPUNN::DMANNWorkload_NPU40_50 (*)()) &VPUNN::create_DMANNWorkload_NPU40, "C++: VPUNN::create_DMANNWorkload_NPU40() --> const struct VPUNN::DMANNWorkload_NPU40_50");

	// VPUNN::create_DMANNWorkload_NPU50() file: line:408
	M("VPUNN").def("create_DMANNWorkload_NPU50", (const struct VPUNN::DMANNWorkload_NPU40_50 (*)()) &VPUNN::create_DMANNWorkload_NPU50, "C++: VPUNN::create_DMANNWorkload_NPU50() --> const struct VPUNN::DMANNWorkload_NPU40_50");

	// VPUNN::create_DMANNWorkload_NPU_RESERVED() file: line:412
	M("VPUNN").def("create_DMANNWorkload_NPU_RESERVED", (const struct VPUNN::DMANNWorkload_NPU40_50 (*)()) &VPUNN::create_DMANNWorkload_NPU_RESERVED, "C++: VPUNN::create_DMANNWorkload_NPU_RESERVED() --> const struct VPUNN::DMANNWorkload_NPU40_50");

	{ // VPUNN::DMATransfer1D file: line:420
		pybind11::class_<VPUNN::DMATransfer1D, std::shared_ptr<VPUNN::DMATransfer1D>> cl(M("VPUNN"), "DMATransfer1D", "Encodes a simple 1D DMA transfer\n\n ");
		cl.def( pybind11::init( [](){ return new VPUNN::DMATransfer1D(); } ) );
		cl.def( pybind11::init( [](VPUNN::DMATransfer1D const &o){ return new VPUNN::DMATransfer1D(o); } ) );
		cl.def_readwrite("device", &VPUNN::DMATransfer1D::device);
		cl.def_readwrite("transfer_length_bytes", &VPUNN::DMATransfer1D::transfer_length_bytes);
		cl.def_readwrite("memory_direction", &VPUNN::DMATransfer1D::memory_direction);
	}
	// VPUNN::FileFormat file: line:39
	pybind11::enum_<VPUNN::FileFormat>(M("VPUNN"), "FileFormat", "")
		.value("TEXT", VPUNN::FileFormat::TEXT)
		.value("CSV", VPUNN::FileFormat::CSV)
		.value("FLATBUFFERS", VPUNN::FileFormat::FLATBUFFERS);

;

	// VPUNN::FileMode file: line:42
	pybind11::enum_<VPUNN::FileMode>(M("VPUNN"), "FileMode", "")
		.value("READONLY", VPUNN::FileMode::READONLY)
		.value("WRITE", VPUNN::FileMode::WRITE)
		.value("APPEND", VPUNN::FileMode::APPEND)
		.value("READ_WRITE", VPUNN::FileMode::READ_WRITE);

;

	// VPUNN::get_extension(const enum VPUNN::FileFormat &) file: line:45
	M("VPUNN").def("get_extension", (const std::string (*)(const enum VPUNN::FileFormat &)) &VPUNN::get_extension, "Get the extension of a file format\n\nC++: VPUNN::get_extension(const enum VPUNN::FileFormat &) --> const std::string", pybind11::arg("fmt"));

	{ // VPUNN::has_member_map file: line:91
		pybind11::class_<VPUNN::has_member_map<VPUNN::DPUOperation,void>, std::shared_ptr<VPUNN::has_member_map<VPUNN::DPUOperation,void>>, std::integral_constant<bool,true>> cl(M("VPUNN"), "has_member_map_VPUNN_DPUOperation_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_member_map<VPUNN::DPUOperation,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
}


// File: VPUNN_12.cpp
#include <array> // std::array
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IOperationDynamicConstraints file: line:23
struct PyCallBack_VPUNN_IOperationDynamicConstraints : public VPUNN::IOperationDynamicConstraints {
	using VPUNN::IOperationDynamicConstraints::IOperationDynamicConstraints;

	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::input_1_volume\"");
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::deduce_input_1_shape_and_layout\"");
	}
	long long input_1_aligned_size_bytes(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "input_1_aligned_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::input_1_aligned_size_bytes\"");
	}
	long long input_1_contiguous_size_bytes(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "input_1_contiguous_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::input_1_contiguous_size_bytes\"");
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::input_0_volume\"");
	}
	long long input_0_aligned_size_bytes(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "input_0_aligned_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::input_0_aligned_size_bytes\"");
	}
	long long input_0_contiguous_size_bytes(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "input_0_contiguous_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::input_0_contiguous_size_bytes\"");
	}
	long long output_0_aligned_size_bytes(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "output_0_aligned_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::output_0_aligned_size_bytes\"");
	}
	long long output_0_contiguous_size_bytes(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "output_0_contiguous_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::output_0_contiguous_size_bytes\"");
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::check_input_output_tensor_corelation\"");
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicConstraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::check_sparsity_rules\"");
	}
};

void bind_VPUNN_12(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::has_member_map file: line:91
		pybind11::class_<VPUNN::has_member_map<const VPUNN::DPUOperation,void>, std::shared_ptr<VPUNN::has_member_map<const VPUNN::DPUOperation,void>>, std::integral_constant<bool,true>> cl(M("VPUNN"), "has_member_map_const_VPUNN_DPUOperation_void_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::has_member_map<const VPUNN::DPUOperation,void>(); } ) );
		cl.def("__call__", (bool (std::integral_constant<bool,true>::*)() const) &std::integral_constant<bool, true>::operator(), "C++: std::integral_constant<bool, true>::operator()() const --> bool");
	}
	{ // VPUNN::TensorInfo file: line:37
		pybind11::class_<VPUNN::TensorInfo, std::shared_ptr<VPUNN::TensorInfo>> cl(M("VPUNN"), "TensorInfo", "holds info for a tensor.");
		cl.def( pybind11::init<const class VPUNN::VPUTensor &>(), pybind11::arg("t") );

		cl.def( pybind11::init( [](){ return new VPUNN::TensorInfo(); } ) );
		cl.def( pybind11::init( [](VPUNN::TensorInfo const &o){ return new VPUNN::TensorInfo(o); } ) );
		cl.def_readwrite("height", &VPUNN::TensorInfo::height);
		cl.def_readwrite("width", &VPUNN::TensorInfo::width);
		cl.def_readwrite("channels", &VPUNN::TensorInfo::channels);
		cl.def_readwrite("batch", &VPUNN::TensorInfo::batch);
		cl.def_readwrite("datatype", &VPUNN::TensorInfo::datatype);
		cl.def_readwrite("layout", &VPUNN::TensorInfo::layout);
		cl.def_readwrite("sparsity", &VPUNN::TensorInfo::sparsity);
		cl.def_readwrite("sparsity_enabled", &VPUNN::TensorInfo::sparsity_enabled);
		cl.def_readwrite("swizzling", &VPUNN::TensorInfo::swizzling);
		cl.def("numberOfElements", (long long (VPUNN::TensorInfo::*)() const) &VPUNN::TensorInfo::numberOfElements, "Get the size in samples\n \n\n how many elements are in this tensor shape\n\nC++: VPUNN::TensorInfo::numberOfElements() const --> long long");
		cl.def("tensor_size_B", (unsigned int (VPUNN::TensorInfo::*)() const) &VPUNN::TensorInfo::tensor_size_B, "Get the size in bytes based on packmode\n \n\n size in bytes\n\nC++: VPUNN::TensorInfo::tensor_size_B() const --> unsigned int");
		cl.def("assign", (struct VPUNN::TensorInfo & (VPUNN::TensorInfo::*)(const struct VPUNN::TensorInfo &)) &VPUNN::TensorInfo::operator=, "C++: VPUNN::TensorInfo::operator=(const struct VPUNN::TensorInfo &) --> struct VPUNN::TensorInfo &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::TensorInfo const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::KernelInfo file: line:78
		pybind11::class_<VPUNN::KernelInfo, std::shared_ptr<VPUNN::KernelInfo>> cl(M("VPUNN"), "KernelInfo", "kernel related informations, including stride and padding");
		cl.def( pybind11::init<const struct VPUNN::DPUWorkload &>(), pybind11::arg("w") );

		cl.def( pybind11::init( [](){ return new VPUNN::KernelInfo(); } ) );
		cl.def( pybind11::init( [](VPUNN::KernelInfo const &o){ return new VPUNN::KernelInfo(o); } ) );
		cl.def_readwrite("height", &VPUNN::KernelInfo::height);
		cl.def_readwrite("width", &VPUNN::KernelInfo::width);
		cl.def_readwrite("pad_bottom", &VPUNN::KernelInfo::pad_bottom);
		cl.def_readwrite("pad_left", &VPUNN::KernelInfo::pad_left);
		cl.def_readwrite("pad_right", &VPUNN::KernelInfo::pad_right);
		cl.def_readwrite("pad_top", &VPUNN::KernelInfo::pad_top);
		cl.def_readwrite("stride_height", &VPUNN::KernelInfo::stride_height);
		cl.def_readwrite("stride_width", &VPUNN::KernelInfo::stride_width);
		cl.def("assign", (struct VPUNN::KernelInfo & (VPUNN::KernelInfo::*)(const struct VPUNN::KernelInfo &)) &VPUNN::KernelInfo::operator=, "C++: VPUNN::KernelInfo::operator=(const struct VPUNN::KernelInfo &) --> struct VPUNN::KernelInfo &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::KernelInfo const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::DPUOperation file: line:107
		pybind11::class_<VPUNN::DPUOperation, std::shared_ptr<VPUNN::DPUOperation>> cl(M("VPUNN"), "DPUOperation", "local type describing a workload\n easy to change and adapt without touching the DPUWorkload interface");
		cl.def( pybind11::init<const struct VPUNN::DPUWorkload &>(), pybind11::arg("w") );

		cl.def( pybind11::init( [](){ return new VPUNN::DPUOperation(); } ) );
		cl.def( pybind11::init( [](VPUNN::DPUOperation const &o){ return new VPUNN::DPUOperation(o); } ) );
		cl.def( pybind11::init<const struct VPUNN::DPUWorkload &, const class VPUNN::IDeviceValidValues &>(), pybind11::arg("w"), pybind11::arg("config") );

		cl.def_readwrite("device", &VPUNN::DPUOperation::device);
		cl.def_readwrite("operation", &VPUNN::DPUOperation::operation);
		cl.def_readwrite("input_0", &VPUNN::DPUOperation::input_0);
		cl.def_readwrite("input_1", &VPUNN::DPUOperation::input_1);
		cl.def_readwrite("output_0", &VPUNN::DPUOperation::output_0);
		cl.def_readwrite("execution_order", &VPUNN::DPUOperation::execution_order);
		cl.def_readwrite("kernel", &VPUNN::DPUOperation::kernel);
		cl.def_readwrite("activation_function", &VPUNN::DPUOperation::activation_function);
		cl.def_readwrite("output_write_tiles", &VPUNN::DPUOperation::output_write_tiles);
		cl.def_readwrite("isi_strategy", &VPUNN::DPUOperation::isi_strategy);
		cl.def_readwrite("halo", &VPUNN::DPUOperation::halo);
		cl.def_readwrite("input_0_memory_dense", &VPUNN::DPUOperation::input_0_memory_dense);
		cl.def_readwrite("output_0_memory_dense", &VPUNN::DPUOperation::output_0_memory_dense);
		cl.def_readwrite("sep_activators", &VPUNN::DPUOperation::sep_activators);
		cl.def_readwrite("weightless_operation", &VPUNN::DPUOperation::weightless_operation);
		cl.def_readwrite("in_place_output_memory", &VPUNN::DPUOperation::in_place_output_memory);
		cl.def_readwrite("superdense", &VPUNN::DPUOperation::superdense);
		cl.def_readwrite("input_autopad", &VPUNN::DPUOperation::input_autopad);
		cl.def_readwrite("output_autopad", &VPUNN::DPUOperation::output_autopad);
		cl.def_readwrite("cost_source_hint", &VPUNN::DPUOperation::cost_source_hint);
		cl.def_readwrite("profiling_service_backend_hint", &VPUNN::DPUOperation::profiling_service_backend_hint);
		cl.def_readwrite("mpe_engine", &VPUNN::DPUOperation::mpe_engine);
		cl.def_readonly("_member_map", &VPUNN::DPUOperation::_member_map);
		cl.def("set_intended_split", (void (VPUNN::DPUOperation::*)(enum VPUNN::ISIStrategy, unsigned int)) &VPUNN::DPUOperation::set_intended_split, "C++: VPUNN::DPUOperation::set_intended_split(enum VPUNN::ISIStrategy, unsigned int) --> void", pybind11::arg("strategy"), pybind11::arg("nTiles"));
		cl.def("clone_as_DPUWorkload", (struct VPUNN::DPUWorkload (VPUNN::DPUOperation::*)() const) &VPUNN::DPUOperation::clone_as_DPUWorkload, "C++: VPUNN::DPUOperation::clone_as_DPUWorkload() const --> struct VPUNN::DPUWorkload");
		cl.def_static("compute_dense_input_memory_tensor", (struct VPUNN::TensorInfo (*)(const struct VPUNN::TensorInfo &, const class VPUNN::HaloWorkload &)) &VPUNN::DPUOperation::compute_dense_input_memory_tensor, "knowing input compute tensor and halo will calculate the input memory tensor, without considering sparsity\n or other indirection like SEP. Is like what would be the memory tensor if dense and no SEP (pointer\n indirection) tricks\n\nC++: VPUNN::DPUOperation::compute_dense_input_memory_tensor(const struct VPUNN::TensorInfo &, const class VPUNN::HaloWorkload &) --> struct VPUNN::TensorInfo", pybind11::arg("compute_t"), pybind11::arg("halo"));
		cl.def_static("compute_dense_output_memory_tensor", (struct VPUNN::TensorInfo (*)(const struct VPUNN::TensorInfo &, const class VPUNN::HaloWorkload &)) &VPUNN::DPUOperation::compute_dense_output_memory_tensor, "knowing output compute tensor and halo will calculate the output memory tensor, without considering sparsity\n or other indirection\n\nC++: VPUNN::DPUOperation::compute_dense_output_memory_tensor(const struct VPUNN::TensorInfo &, const class VPUNN::HaloWorkload &) --> struct VPUNN::TensorInfo", pybind11::arg("compute_t"), pybind11::arg("halo"));
		cl.def("resyncronize_memory_tensors", (void (VPUNN::DPUOperation::*)()) &VPUNN::DPUOperation::resyncronize_memory_tensors, "update memory tensors in accordance with compute tensors and Halo\n\nC++: VPUNN::DPUOperation::resyncronize_memory_tensors() --> void");
		cl.def_static("_get_member_names", (const class std::vector<std::string, class std::allocator<std::string > > & (*)()) &VPUNN::DPUOperation::_get_member_names, "C++: VPUNN::DPUOperation::_get_member_names() --> const class std::vector<std::string, class std::allocator<std::string > > &", pybind11::return_value_policy::reference);
		cl.def("hash", (unsigned long (VPUNN::DPUOperation::*)() const) &VPUNN::DPUOperation::hash, "C++: VPUNN::DPUOperation::hash() const --> unsigned long");
		cl.def("is_elementwise_like_operation", (bool (VPUNN::DPUOperation::*)() const) &VPUNN::DPUOperation::is_elementwise_like_operation, "detect if operation is elementwise fammily\n\nC++: VPUNN::DPUOperation::is_elementwise_like_operation() const --> bool");

		cl.def("__str__", [](VPUNN::DPUOperation const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::IOperationDynamicConstraints file: line:23
		pybind11::class_<VPUNN::IOperationDynamicConstraints, VPUNN::IOperationDynamicConstraints*, PyCallBack_VPUNN_IOperationDynamicConstraints> cl(M("VPUNN"), "IOperationDynamicConstraints", "Interface class for constraints/behaviors that are specific to operations\n It enforces dynamically the workload setup. Derived classes will implement specific rules based on the operation");
		cl.def(pybind11::init<PyCallBack_VPUNN_IOperationDynamicConstraints const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IOperationDynamicConstraints(); } ) );
		cl.def("input_1_volume", (long long (VPUNN::IOperationDynamicConstraints::*)(const struct VPUNN::TensorInfo &) const) &VPUNN::IOperationDynamicConstraints::input_1_volume, "computes size of weights (input_1) in elements not bytes. SPecific for some operations\n\nC++: VPUNN::IOperationDynamicConstraints::input_1_volume(const struct VPUNN::TensorInfo &) const --> long long", pybind11::arg("w"));
		cl.def("deduce_input_1_shape_and_layout", (void (VPUNN::IOperationDynamicConstraints::*)(const struct VPUNN::TensorInfo &, const struct VPUNN::TensorInfo &, const class VPUNN::IDeviceValidValues &, const struct VPUNN::KernelInfo &, struct VPUNN::TensorInfo &) const) &VPUNN::IOperationDynamicConstraints::deduce_input_1_shape_and_layout, "deduce input_1 based on input_0 and output_0,\n deduce the weights  shape and layoput. The datatype is already filled in.\n This should be a natural continuation of constructor of DPUOperation, keep the call close to it so we have fast a\n valid object\n\nC++: VPUNN::IOperationDynamicConstraints::deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo &, const struct VPUNN::TensorInfo &, const class VPUNN::IDeviceValidValues &, const struct VPUNN::KernelInfo &, struct VPUNN::TensorInfo &) const --> void", pybind11::arg("in_0"), pybind11::arg("out_0"), pybind11::arg("config"), pybind11::arg("kernel"), pybind11::arg("w"));
		cl.def("input_1_aligned_size_bytes", (long long (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::input_1_aligned_size_bytes, "computes the aligned size in bytes for weights of a workload\n\nC++: VPUNN::IOperationDynamicConstraints::input_1_aligned_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("input_1_contiguous_size_bytes", (long long (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::input_1_contiguous_size_bytes, "computes the non CMX aligned/contiguous  size in bytes for the weights\n\nC++: VPUNN::IOperationDynamicConstraints::input_1_contiguous_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("input_0_volume", (long long (VPUNN::IOperationDynamicConstraints::*)(const struct VPUNN::TensorInfo &) const) &VPUNN::IOperationDynamicConstraints::input_0_volume, "computes size of activators (input_0) in elements not bytes. Specific for some operations\n. Does not consider halo, but based on operation, the w content might be adjusted\n\nC++: VPUNN::IOperationDynamicConstraints::input_0_volume(const struct VPUNN::TensorInfo &) const --> long long", pybind11::arg("w"));
		cl.def("input_0_aligned_size_bytes", (long long (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::input_0_aligned_size_bytes, "computes the aligned size in bytes for activators of a workload. the actual memory occupied considering\n SEP or sparsity.\n\nC++: VPUNN::IOperationDynamicConstraints::input_0_aligned_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("input_0_contiguous_size_bytes", (long long (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::input_0_contiguous_size_bytes, "computes the non CMX aligned/contiguous  size in bytes for the activators\n\nC++: VPUNN::IOperationDynamicConstraints::input_0_contiguous_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("output_0_aligned_size_bytes", (long long (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::output_0_aligned_size_bytes, "computes the aligned size in bytes for  output activators of a workload. the actual memory occupied\n considering sparsity map\n\nC++: VPUNN::IOperationDynamicConstraints::output_0_aligned_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("output_0_contiguous_size_bytes", (long long (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::output_0_contiguous_size_bytes, "computes the non CMX aligned/contiguous  size in bytes for the output. the actual memory occupied\n considering sparsity map\n\nC++: VPUNN::IOperationDynamicConstraints::output_0_contiguous_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("filter_ISI_Strategy_Options", (class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > (VPUNN::IOperationDynamicConstraints::*)(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > &) const) &VPUNN::IOperationDynamicConstraints::filter_ISI_Strategy_Options, "a filtered strategy container that has the invalid ones eliminated. Operation dependent.\n\nC++: VPUNN::IOperationDynamicConstraints::filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > &) const --> class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >", pybind11::arg("strategies"));
		cl.def("filter_output_write_tile_Options", (class std::vector<int, class std::allocator<int> > (VPUNN::IOperationDynamicConstraints::*)(const class std::vector<int, class std::allocator<int> > &) const) &VPUNN::IOperationDynamicConstraints::filter_output_write_tile_Options, "a output_write_tile container that has the invalid ones eliminated. Operation dependent.\n\nC++: VPUNN::IOperationDynamicConstraints::filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("output_write_tile_variants"));
		cl.def("normalize_kernel_dimension", (bool (VPUNN::IOperationDynamicConstraints::*)(const enum VPUNN::ISIStrategy &, struct VPUNN::KernelInfo &) const) &VPUNN::IOperationDynamicConstraints::normalize_kernel_dimension, "changes kernels in case a stricter constraint must be used\n \n\n true if normalization was done (kernel changed)\n\nC++: VPUNN::IOperationDynamicConstraints::normalize_kernel_dimension(const enum VPUNN::ISIStrategy &, struct VPUNN::KernelInfo &) const --> bool", pybind11::arg(""), pybind11::arg(""));
		cl.def("limit_sparsity", (void (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicConstraints::limit_sparsity, "@ reduces/adjusts sparsity  according to context\n\nC++: VPUNN::IOperationDynamicConstraints::limit_sparsity(const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const --> void", pybind11::arg(""), pybind11::arg(""));
		cl.def("check_input_output_tensor_corelation", (bool (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const) &VPUNN::IOperationDynamicConstraints::check_input_output_tensor_corelation, "checks that the sizes of inputs and output tensors are good given the operation.\n\nC++: VPUNN::IOperationDynamicConstraints::check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const --> bool", pybind11::arg("config"), pybind11::arg("dpu"), pybind11::arg("info"));
		cl.def("check_sparsity_rules", (bool (VPUNN::IOperationDynamicConstraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const) &VPUNN::IOperationDynamicConstraints::check_sparsity_rules, "checks that the sparsity respects operation constraints\n\nC++: VPUNN::IOperationDynamicConstraints::check_sparsity_rules(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const --> bool", pybind11::arg("config"), pybind11::arg("dpu"), pybind11::arg("info"));
	}
}


// File: VPUNN_13.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <memory> // std::allocator
#include <optional> // std::nullopt_t
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IContainer_OperationsDynamicBehavior file: line:98
struct PyCallBack_VPUNN_IContainer_OperationsDynamicBehavior : public VPUNN::IContainer_OperationsDynamicBehavior {
	using VPUNN::IContainer_OperationsDynamicBehavior::IContainer_OperationsDynamicBehavior;

	const class VPUNN::IOperationDynamicConstraints & get_operation_specific_behaviour(const enum VPUNN::Operation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IContainer_OperationsDynamicBehavior *>(this), "get_operation_specific_behaviour");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IOperationDynamicConstraints &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IOperationDynamicConstraints &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IOperationDynamicConstraints &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IOperationDynamicConstraints &>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour\"");
	}
};

// VPUNN::IDeviceValidValues file: line:71
struct PyCallBack_VPUNN_IDeviceValidValues : public VPUNN::IDeviceValidValues {
	using VPUNN::IDeviceValidValues::IDeviceValidValues;

	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceValidValues::get_input_channels_restriction\"");
	}
	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceValidValues::get_output_channels_restriction\"");
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceValidValues::get_batch_restrictions\"");
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IDeviceValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceValidValues::adapt_device_comaptible_tensor_layout\"");
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceValidValues::adapt_device_comaptible_swizzling\"");
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

void bind_VPUNN_13(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::IContainer_OperationsDynamicBehavior file: line:98
		pybind11::class_<VPUNN::IContainer_OperationsDynamicBehavior, VPUNN::IContainer_OperationsDynamicBehavior*, PyCallBack_VPUNN_IContainer_OperationsDynamicBehavior> cl(M("VPUNN"), "IContainer_OperationsDynamicBehavior", "interface to a container of IOperationDynamicConstraints associated 1-1 to operations");
		cl.def(pybind11::init<PyCallBack_VPUNN_IContainer_OperationsDynamicBehavior const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IContainer_OperationsDynamicBehavior(); } ) );
		cl.def("get_operation_specific_behaviour", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::IContainer_OperationsDynamicBehavior::*)(const enum VPUNN::Operation) const) &VPUNN::IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour, "C++: VPUNN::IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("assign", (class VPUNN::IContainer_OperationsDynamicBehavior & (VPUNN::IContainer_OperationsDynamicBehavior::*)(const class VPUNN::IContainer_OperationsDynamicBehavior &)) &VPUNN::IContainer_OperationsDynamicBehavior::operator=, "C++: VPUNN::IContainer_OperationsDynamicBehavior::operator=(const class VPUNN::IContainer_OperationsDynamicBehavior &) --> class VPUNN::IContainer_OperationsDynamicBehavior &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::SmartRanges file: line:26
		pybind11::class_<VPUNN::SmartRanges, std::shared_ptr<VPUNN::SmartRanges>> cl(M("VPUNN"), "SmartRanges", "");
		cl.def( pybind11::init( [](int const & a0, int const & a1){ return new VPUNN::SmartRanges(a0, a1); } ), "doc" , pybind11::arg("lowerBound_"), pybind11::arg("upperBound_"));
		cl.def( pybind11::init( [](int const & a0, int const & a1, int const & a2){ return new VPUNN::SmartRanges(a0, a1, a2); } ), "doc" , pybind11::arg("lowerBound_"), pybind11::arg("upperBound_"), pybind11::arg("divisor_"));
		cl.def( pybind11::init<int, int, int, class std::optional<int>>(), pybind11::arg("lowerBound_"), pybind11::arg("upperBound_"), pybind11::arg("divisor_"), pybind11::arg("second_div") );

		cl.def( pybind11::init<int, int, int, int>(), pybind11::arg("lowerBound_"), pybind11::arg("upperBound_"), pybind11::arg("divisor_"), pybind11::arg("second_div") );

		cl.def( pybind11::init( [](VPUNN::SmartRanges const &o){ return new VPUNN::SmartRanges(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::SmartRanges(); } ) );
		cl.def("assign", (class VPUNN::SmartRanges & (VPUNN::SmartRanges::*)(const class VPUNN::SmartRanges &)) &VPUNN::SmartRanges::operator=, "C++: VPUNN::SmartRanges::operator=(const class VPUNN::SmartRanges &) --> class VPUNN::SmartRanges &", pybind11::return_value_policy::reference, pybind11::arg("other"));
		cl.def("is_in", (bool (VPUNN::SmartRanges::*)(int, std::string &) const) &VPUNN::SmartRanges::is_in, ": here we verify if a value respect all the range requirements\n \n\n the value we want to verify\n \n\n a string with information when value does not respect all the requirements\n \n\n true if value respect all the requirements, false if not\n\nC++: VPUNN::SmartRanges::is_in(int, std::string &) const --> bool", pybind11::arg("value"), pybind11::arg("text"));
		cl.def("is_in", (bool (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::is_in, "C++: VPUNN::SmartRanges::is_in(int) const --> bool", pybind11::arg("value"));
		cl.def("is_roundToNextLarger", (bool (VPUNN::SmartRanges::*)(int &) const) &VPUNN::SmartRanges::is_roundToNextLarger, "C++: VPUNN::SmartRanges::is_roundToNextLarger(int &) const --> bool", pybind11::arg("value"));
		cl.def("roundToNextLarger", (class std::optional<int> (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::roundToNextLarger, "C++: VPUNN::SmartRanges::roundToNextLarger(int) const --> class std::optional<int>", pybind11::arg("value"));
		cl.def("betweenLimits", (bool (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::betweenLimits, "C++: VPUNN::SmartRanges::betweenLimits(int) const --> bool", pybind11::arg("value"));
		cl.def("multiply_upper", (class VPUNN::SmartRanges (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::multiply_upper, "multiplies the upper bound of the range by the given value\n \n\n used to adjust the range upper bound\n\n \n a new SmartRanges with the upper bound of the range updated based on the multiplier\n\nC++: VPUNN::SmartRanges::multiply_upper(int) const --> class VPUNN::SmartRanges", pybind11::arg("multiplier"));
		cl.def("multiply_lower", (class VPUNN::SmartRanges (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::multiply_lower, "multiplies the lower bound of the range by the given value\n \n\n used to adjust the range lower bound\n\n \n a new SmartRanges with the lower bound of the range updated based on the multiplier\n\nC++: VPUNN::SmartRanges::multiply_lower(int) const --> class VPUNN::SmartRanges", pybind11::arg("multiplier"));
		cl.def("add_upper", (class VPUNN::SmartRanges (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::add_upper, "increase or decrease (by adding a negative value) the upper bound of the range by the given value\n \n\n used to adjust the range upper bound\n\n \n a new SmartRanges with the upper bound of the range updated based on the added_term\n\nC++: VPUNN::SmartRanges::add_upper(int) const --> class VPUNN::SmartRanges", pybind11::arg("added_term"));
		cl.def("add_lower", (class VPUNN::SmartRanges (VPUNN::SmartRanges::*)(int) const) &VPUNN::SmartRanges::add_lower, "increase or decrease (by adding a negative value) the lower bound of the range by the given value\n \n\n used to adjust the range lower bound\n\n \n a new SmartRanges with the lower bound of the range updated based on the added_term\n\nC++: VPUNN::SmartRanges::add_lower(int) const --> class VPUNN::SmartRanges", pybind11::arg("added_term"));
		cl.def("getUpperBound", (int (VPUNN::SmartRanges::*)() const) &VPUNN::SmartRanges::getUpperBound, "C++: VPUNN::SmartRanges::getUpperBound() const --> int");
		cl.def("getLowerBound", (int (VPUNN::SmartRanges::*)() const) &VPUNN::SmartRanges::getLowerBound, "C++: VPUNN::SmartRanges::getLowerBound() const --> int");
	}
	{ // VPUNN::MultiSmartRanges file: line:247
		pybind11::class_<VPUNN::MultiSmartRanges, std::shared_ptr<VPUNN::MultiSmartRanges>> cl(M("VPUNN"), "MultiSmartRanges", "");
		cl.def( pybind11::init<const class std::vector<class VPUNN::SmartRanges, class std::allocator<class VPUNN::SmartRanges> > &>(), pybind11::arg("ranges_") );

		cl.def( pybind11::init( [](VPUNN::MultiSmartRanges const &o){ return new VPUNN::MultiSmartRanges(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::MultiSmartRanges(); } ) );
		cl.def("assign", (class VPUNN::MultiSmartRanges & (VPUNN::MultiSmartRanges::*)(const class VPUNN::MultiSmartRanges &)) &VPUNN::MultiSmartRanges::operator=, "C++: VPUNN::MultiSmartRanges::operator=(const class VPUNN::MultiSmartRanges &) --> class VPUNN::MultiSmartRanges &", pybind11::return_value_policy::reference, pybind11::arg("other"));
		cl.def("is_in", [](VPUNN::MultiSmartRanges const &o, int const & a0, std::string & a1) -> bool { return o.is_in(a0, a1); }, "", pybind11::arg("value"), pybind11::arg("text"));
		cl.def("is_in", (bool (VPUNN::MultiSmartRanges::*)(int, std::string &, class std::vector<bool, class std::allocator<bool> >) const) &VPUNN::MultiSmartRanges::is_in, ": here we verify if a value respect all the range requirements\n \n\n the value we want to verify\n \n\n a string with information when value does not respect all the requirements\n \n\n a vector of bools that indicates which ranges to check\n             - If empty: all ranges are checked (mask is set to all true).\n             - If smaller than the number of ranges: mask is extended with false for missing entries.\n             - If larger than the number of ranges: extra mask entries are ignored.\n \n\n true if value respect all the requirements, false if not\n\nC++: VPUNN::MultiSmartRanges::is_in(int, std::string &, class std::vector<bool, class std::allocator<bool> >) const --> bool", pybind11::arg("value"), pybind11::arg("text"), pybind11::arg("mask"));
		cl.def("is_in", [](VPUNN::MultiSmartRanges const &o, int const & a0) -> bool { return o.is_in(a0); }, "", pybind11::arg("value"));
		cl.def("is_in", (bool (VPUNN::MultiSmartRanges::*)(int, class std::vector<bool, class std::allocator<bool> >) const) &VPUNN::MultiSmartRanges::is_in, "C++: VPUNN::MultiSmartRanges::is_in(int, class std::vector<bool, class std::allocator<bool> >) const --> bool", pybind11::arg("value"), pybind11::arg("mask"));
		cl.def("get_range", (class VPUNN::SmartRanges (VPUNN::MultiSmartRanges::*)(unsigned long) const) &VPUNN::MultiSmartRanges::get_range, ": get a specific range from the vector of ranges\n \n\n the index of the range we want to get\n \n\n the range at the given index\n\nC++: VPUNN::MultiSmartRanges::get_range(unsigned long) const --> class VPUNN::SmartRanges", pybind11::arg("index"));
		cl.def("getUpperBound", (int (VPUNN::MultiSmartRanges::*)() const) &VPUNN::MultiSmartRanges::getUpperBound, "C++: VPUNN::MultiSmartRanges::getUpperBound() const --> int");
		cl.def("getLowerBound", (int (VPUNN::MultiSmartRanges::*)() const) &VPUNN::MultiSmartRanges::getLowerBound, "C++: VPUNN::MultiSmartRanges::getLowerBound() const --> int");
		cl.def("multiply_lower", (class VPUNN::MultiSmartRanges (VPUNN::MultiSmartRanges::*)(int) const) &VPUNN::MultiSmartRanges::multiply_lower, "C++: VPUNN::MultiSmartRanges::multiply_lower(int) const --> class VPUNN::MultiSmartRanges", pybind11::arg("multiplier"));
		cl.def("multiply_upper", (class VPUNN::MultiSmartRanges (VPUNN::MultiSmartRanges::*)(int) const) &VPUNN::MultiSmartRanges::multiply_upper, "C++: VPUNN::MultiSmartRanges::multiply_upper(int) const --> class VPUNN::MultiSmartRanges", pybind11::arg("multiplier"));
	}
	{ // VPUNN::ValidValuesInfrastructure file: line:36
		pybind11::class_<VPUNN::ValidValuesInfrastructure, std::shared_ptr<VPUNN::ValidValuesInfrastructure>> cl(M("VPUNN"), "ValidValuesInfrastructure", "infrastructure class for describing and creating  valid values");
		cl.def( pybind11::init( [](VPUNN::ValidValuesInfrastructure const &o){ return new VPUNN::ValidValuesInfrastructure(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::ValidValuesInfrastructure(); } ) );
		cl.def("contains_value", (bool (VPUNN::ValidValuesInfrastructure::*)(const class std::vector<enum VPUNN::Operation, class std::allocator<enum VPUNN::Operation> > &, const enum VPUNN::Operation &) const) &VPUNN::ValidValuesInfrastructure::contains_value<VPUNN::Operation>, "C++: VPUNN::ValidValuesInfrastructure::contains_value(const class std::vector<enum VPUNN::Operation, class std::allocator<enum VPUNN::Operation> > &, const enum VPUNN::Operation &) const --> bool", pybind11::arg("container"), pybind11::arg("element"));
		cl.def_static("makeList", [](int const & a0, int const & a1) -> std::vector<int, class std::allocator<int> > { return VPUNN::ValidValuesInfrastructure::makeList(a0, a1); }, "", pybind11::arg("from"), pybind11::arg("to"));
		cl.def_static("makeList", (class std::vector<int, class std::allocator<int> > (*)(int, int, int)) &VPUNN::ValidValuesInfrastructure::makeList, "creates a list , rule: [from ... to] * multiply\n\nC++: VPUNN::ValidValuesInfrastructure::makeList(int, int, int) --> class std::vector<int, class std::allocator<int> >", pybind11::arg("from"), pybind11::arg("to"), pybind11::arg("multiply"));
		cl.def("assign", (class VPUNN::ValidValuesInfrastructure & (VPUNN::ValidValuesInfrastructure::*)(const class VPUNN::ValidValuesInfrastructure &)) &VPUNN::ValidValuesInfrastructure::operator=, "C++: VPUNN::ValidValuesInfrastructure::operator=(const class VPUNN::ValidValuesInfrastructure &) --> class VPUNN::ValidValuesInfrastructure &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::IDeviceValidValues file: line:71
		pybind11::class_<VPUNN::IDeviceValidValues, VPUNN::IDeviceValidValues*, PyCallBack_VPUNN_IDeviceValidValues, VPUNN::ValidValuesInfrastructure> cl(M("VPUNN"), "IDeviceValidValues", "interface for finding out what are the valid values for a workload that has a particular device and operation\n for stable values (independent of operation) : holds the data values that a workload can take on its fields\n dynamic behavior is provided via methods, including pure virtual ones.\n has also a connection to the specific behavior interface that discriminated between operations\n /* coverity[rule_of_five_violation:FALSE] */");
		cl.def(pybind11::init<PyCallBack_VPUNN_IDeviceValidValues const &>());
		cl.def("get_specific_behaviour", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::IDeviceValidValues::*)(const enum VPUNN::Operation) const) &VPUNN::IDeviceValidValues::get_specific_behaviour, "wrapper for accessing IContainer_OperationsDynamicBehavior\n\nC++: VPUNN::IDeviceValidValues::get_specific_behaviour(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("get_input_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_input_channels_restriction, "C++: VPUNN::IDeviceValidValues::get_input_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg(""));
		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_output_channels_restriction, "C++: VPUNN::IDeviceValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg(""));
		cl.def("get_batch_restrictions", (class VPUNN::MultiSmartRanges (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_batch_restrictions, "C++: VPUNN::IDeviceValidValues::get_batch_restrictions() const --> class VPUNN::MultiSmartRanges");
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::mustExecuteHWLowLevelChecks, "false for places where checks regarding properties that are not connected to the abstract operation is not  to\n be checked (they do not really exists in that context). e.g. stencil. true: low level checks to be executed\n\nC++: VPUNN::IDeviceValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
		cl.def("get_valid_datatypes_map", (const class VPUNN::IDeviceValidValues::ValidDatatypes & (VPUNN::IDeviceValidValues::*)(const enum VPUNN::MPEEngine &) const) &VPUNN::IDeviceValidValues::get_valid_datatypes_map, "C++: VPUNN::IDeviceValidValues::get_valid_datatypes_map(const enum VPUNN::MPEEngine &) const --> const class VPUNN::IDeviceValidValues::ValidDatatypes &", pybind11::return_value_policy::reference, pybind11::arg(""));
		cl.def("get_input_valid_datatypes", (const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > & (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_input_valid_datatypes, "C++: VPUNN::IDeviceValidValues::get_input_valid_datatypes(const struct VPUNN::DPUOperation &) const --> const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &", pybind11::return_value_policy::reference, pybind11::arg("dpu"));
		cl.def("get_output_valid_datatypes", (const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > & (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_output_valid_datatypes, "C++: VPUNN::IDeviceValidValues::get_output_valid_datatypes(const struct VPUNN::DPUOperation &) const --> const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &", pybind11::return_value_policy::reference, pybind11::arg("dpu"));
		cl.def("get_weights_valid_datatypes", (const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > & (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_weights_valid_datatypes, "C++: VPUNN::IDeviceValidValues::get_weights_valid_datatypes(const struct VPUNN::DPUOperation &) const --> const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &", pybind11::return_value_policy::reference, pybind11::arg("dpu"));
		cl.def("adapt_device_comaptible_tensor_layout", (enum VPUNN::Layout (VPUNN::IDeviceValidValues::*)(enum VPUNN::Layout) const) &VPUNN::IDeviceValidValues::adapt_device_comaptible_tensor_layout, "CHanges tensor layouts to match the device convention (if possible). Useful for defaults\n\nC++: VPUNN::IDeviceValidValues::adapt_device_comaptible_tensor_layout(enum VPUNN::Layout) const --> enum VPUNN::Layout", pybind11::arg("layout"));
		cl.def("adapt_device_comaptible_swizzling", (enum VPUNN::Swizzling (VPUNN::IDeviceValidValues::*)(enum VPUNN::Swizzling) const) &VPUNN::IDeviceValidValues::adapt_device_comaptible_swizzling, "Changes tensor swizzling to match the device special restrictions or conventions. Useful for defaults\n\nC++: VPUNN::IDeviceValidValues::adapt_device_comaptible_swizzling(enum VPUNN::Swizzling) const --> enum VPUNN::Swizzling", pybind11::arg("swizz"));
		cl.def("get_input_height_interval", [](VPUNN::IDeviceValidValues const &o, const struct VPUNN::DPUOperation & a0) -> std::pair<int, int> { return o.get_input_height_interval(a0); }, "", pybind11::arg("dpu"));
		cl.def("get_input_height_interval", (struct std::pair<int, int> (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &, bool) const) &VPUNN::IDeviceValidValues::get_input_height_interval, "C++: VPUNN::IDeviceValidValues::get_input_height_interval(const struct VPUNN::DPUOperation &, bool) const --> struct std::pair<int, int>", pybind11::arg("dpu"), pybind11::arg("use_extra_start"));
		cl.def("get_input_height_range", (class std::vector<int, class std::allocator<int> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_input_height_range, "slow , only for generators\n\nC++: VPUNN::IDeviceValidValues::get_input_height_range(const struct VPUNN::DPUOperation &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("dpu"));
		cl.def("get_input_width_interval", [](VPUNN::IDeviceValidValues const &o, const struct VPUNN::DPUOperation & a0) -> std::pair<int, int> { return o.get_input_width_interval(a0); }, "", pybind11::arg("dpu"));
		cl.def("get_input_width_interval", (struct std::pair<int, int> (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &, bool) const) &VPUNN::IDeviceValidValues::get_input_width_interval, "C++: VPUNN::IDeviceValidValues::get_input_width_interval(const struct VPUNN::DPUOperation &, bool) const --> struct std::pair<int, int>", pybind11::arg("dpu"), pybind11::arg("use_extra_start"));
		cl.def("get_input_width_range", (class std::vector<int, class std::allocator<int> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_input_width_range, "slow , only for generators\n\nC++: VPUNN::IDeviceValidValues::get_input_width_range(const struct VPUNN::DPUOperation &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("dpu"));
		cl.def("get_pad_horz_range", (class std::vector<int, class std::allocator<int> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_pad_horz_range, "C++: VPUNN::IDeviceValidValues::get_pad_horz_range(const struct VPUNN::DPUOperation &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("dpu"));
		cl.def("get_pad_vert_range", (class std::vector<int, class std::allocator<int> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_pad_vert_range, "C++: VPUNN::IDeviceValidValues::get_pad_vert_range(const struct VPUNN::DPUOperation &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("dpu"));
		cl.def("get_ISI_Strategy_Range", (class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_ISI_Strategy_Range, "restricts ISI options based on output write tile value.\n\nC++: VPUNN::IDeviceValidValues::get_ISI_Strategy_Range(const struct VPUNN::DPUOperation &) const --> class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >", pybind11::arg("dpu"));
		cl.def("get_output_write_tile_Range", (class std::vector<int, class std::allocator<int> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_output_write_tile_Range, "restricts output_write_tile options based on operation.\n\nC++: VPUNN::IDeviceValidValues::get_output_write_tile_Range(const struct VPUNN::DPUOperation &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("dpu"));
		cl.def("get_kernel_range", (class std::vector<int, class std::allocator<int> > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_kernel_range, "C++: VPUNN::IDeviceValidValues::get_kernel_range(const struct VPUNN::DPUOperation &) const --> class std::vector<int, class std::allocator<int> >", pybind11::arg("dpu"));
		cl.def("get_strides_range", (struct std::pair<class std::vector<int, class std::allocator<int> >, class std::vector<int, class std::allocator<int> > > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_strides_range, "@ brief strides range , depends on input zero, and operation sometimes\n \n\n a pair of lists of values, one first for  stride Width, second for stride height\n\nC++: VPUNN::IDeviceValidValues::get_strides_range(const struct VPUNN::DPUOperation &) const --> struct std::pair<class std::vector<int, class std::allocator<int> >, class std::vector<int, class std::allocator<int> > >", pybind11::arg("dpu"));
		cl.def("get_dpu_strides_range", (struct std::pair<class std::vector<int, class std::allocator<int> >, class std::vector<int, class std::allocator<int> > > (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_dpu_strides_range, "@ brief this function is set to determine the range of strides for the split layers\n \n\n a pair of lists of values, one first for  stride Width, second for stride height\n\nC++: VPUNN::IDeviceValidValues::get_dpu_strides_range(const struct VPUNN::DPUOperation &) const --> struct std::pair<class std::vector<int, class std::allocator<int> >, class std::vector<int, class std::allocator<int> > >", pybind11::arg("dpu"));
		cl.def("get_default_swizzling", (enum VPUNN::Swizzling (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_default_swizzling, "To use when generating new data\n\nC++: VPUNN::IDeviceValidValues::get_default_swizzling() const --> enum VPUNN::Swizzling");
		cl.def("get_output_write_tile_options", (const class std::vector<int, class std::allocator<int> > & (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_output_write_tile_options, "C++: VPUNN::IDeviceValidValues::get_output_write_tile_options() const --> const class std::vector<int, class std::allocator<int> > &", pybind11::return_value_policy::reference);
		cl.def("get_specific_weigths_alignment", (int (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_specific_weigths_alignment, "provides the default/nominal weights alignment for the device. Can be used in case we need to align the weights\n TODO: unclear measurement unit, BYtes or samples?  Now it is interpreted as Samples\n\nC++: VPUNN::IDeviceValidValues::get_specific_weigths_alignment() const --> int");
		cl.def("get_specific_out_innermost_dim_alignment", (int (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_specific_out_innermost_dim_alignment, "C++: VPUNN::IDeviceValidValues::get_specific_out_innermost_dim_alignment() const --> int");
		cl.def("get_valid_operations", (const class std::vector<enum VPUNN::Operation, class std::allocator<enum VPUNN::Operation> > & (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_valid_operations, "C++: VPUNN::IDeviceValidValues::get_valid_operations() const --> const class std::vector<enum VPUNN::Operation, class std::allocator<enum VPUNN::Operation> > &", pybind11::return_value_policy::reference);
		cl.def("get_valid_execution_order", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > & (VPUNN::IDeviceValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::IDeviceValidValues::get_valid_execution_order, "C++: VPUNN::IDeviceValidValues::get_valid_execution_order(const struct VPUNN::DPUOperation &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &", pybind11::return_value_policy::reference, pybind11::arg("dpu"));
		cl.def("get_valid_swizzlings", (const class std::vector<enum VPUNN::Swizzling, class std::allocator<enum VPUNN::Swizzling> > & (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_valid_swizzlings, "C++: VPUNN::IDeviceValidValues::get_valid_swizzlings() const --> const class std::vector<enum VPUNN::Swizzling, class std::allocator<enum VPUNN::Swizzling> > &", pybind11::return_value_policy::reference);
		cl.def("get_valid_layouts", (const class std::vector<enum VPUNN::Layout, class std::allocator<enum VPUNN::Layout> > & (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_valid_layouts, "C++: VPUNN::IDeviceValidValues::get_valid_layouts() const --> const class std::vector<enum VPUNN::Layout, class std::allocator<enum VPUNN::Layout> > &", pybind11::return_value_policy::reference);
		cl.def("get_devices", (const class std::vector<enum VPUNN::VPUDevice, class std::allocator<enum VPUNN::VPUDevice> > & (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_devices, "C++: VPUNN::IDeviceValidValues::get_devices() const --> const class std::vector<enum VPUNN::VPUDevice, class std::allocator<enum VPUNN::VPUDevice> > &", pybind11::return_value_policy::reference);
		cl.def("get_boolean_datatypes", (const class std::vector<bool, class std::allocator<bool> > & (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_boolean_datatypes, "C++: VPUNN::IDeviceValidValues::get_boolean_datatypes() const --> const class std::vector<bool, class std::allocator<bool> > &", pybind11::return_value_policy::reference);
		cl.def("get_page_alignment", (int (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_page_alignment, "bytes alignment fro the memory chunks\n\nC++: VPUNN::IDeviceValidValues::get_page_alignment() const --> int");
		cl.def("get_cmx_memory_aligned_overhead", (int (VPUNN::IDeviceValidValues::*)() const) &VPUNN::IDeviceValidValues::get_cmx_memory_aligned_overhead, "C++: VPUNN::IDeviceValidValues::get_cmx_memory_aligned_overhead() const --> int");
		cl.def("restrict_datatype", (enum VPUNN::DataType (VPUNN::IDeviceValidValues::*)(const enum VPUNN::DataType) const) &VPUNN::IDeviceValidValues::restrict_datatype, "restrict the datatype if it has an alternative type. eg INT8 is same like UINT8\n\nC++: VPUNN::IDeviceValidValues::restrict_datatype(const enum VPUNN::DataType) const --> enum VPUNN::DataType", pybind11::arg("in"));
		cl.def("get_cmx_size", (int (VPUNN::IDeviceValidValues::*)(const enum VPUNN::VPUDevice &) const) &VPUNN::IDeviceValidValues::get_cmx_size, "size of CMX in bytes\n\nC++: VPUNN::IDeviceValidValues::get_cmx_size(const enum VPUNN::VPUDevice &) const --> int", pybind11::arg("device"));
		cl.def("get_padMax", (int (VPUNN::IDeviceValidValues::*)(int) const) &VPUNN::IDeviceValidValues::get_padMax, "maximum padding required if the kernel is known\n\nC++: VPUNN::IDeviceValidValues::get_padMax(int) const --> int", pybind11::arg("kernel_dim"));
		cl.def("compute_output_dim", (int (VPUNN::IDeviceValidValues::*)(int, int, int, int, int) const) &VPUNN::IDeviceValidValues::compute_output_dim, "computes output dimension based on input, kernel, padding and stride (for a spatial dimension)\n \n\n zero if  kernel_stride is zero(avoids div by zero) else returns computed output dimension\n\nC++: VPUNN::IDeviceValidValues::compute_output_dim(int, int, int, int, int) const --> int", pybind11::arg("input"), pybind11::arg("pad"), pybind11::arg("pad_oppopsite"), pybind11::arg("kernel"), pybind11::arg("kernel_stride"));
		cl.def("align_to", (long long (VPUNN::IDeviceValidValues::*)(long long, int) const) &VPUNN::IDeviceValidValues::align_to, "computes the next larger value of x that is multiple of multiple\n \n\n only for positive values\n\nC++: VPUNN::IDeviceValidValues::align_to(long long, int) const --> long long", pybind11::arg("x"), pybind11::arg("multiple"));
		cl.def("sanitize_sparsity", (float (VPUNN::IDeviceValidValues::*)(long long, float) const) &VPUNN::IDeviceValidValues::sanitize_sparsity, "sparsity is applied in blocks (16 B normally) , the desired value has to be quantized taken that in\n consideration\n\nC++: VPUNN::IDeviceValidValues::sanitize_sparsity(long long, float) const --> float", pybind11::arg("tensor_size"), pybind11::arg("desired_sparsity_level"));
		cl.def("check_trailing_padding", (int (VPUNN::IDeviceValidValues::*)(int, int, int, int, int) const) &VPUNN::IDeviceValidValues::check_trailing_padding, "Adapt  padding\n Reference :\n\nC++: VPUNN::IDeviceValidValues::check_trailing_padding(int, int, int, int, int) const --> int", pybind11::arg("in_dim"), pybind11::arg("out_dim"), pybind11::arg("leading_pad"), pybind11::arg("kernel_radix"), pybind11::arg("stride"));
		cl.def("compute_size_aligned", (long long (VPUNN::IDeviceValidValues::*)(const long long, const enum VPUNN::DataType &) const) &VPUNN::IDeviceValidValues::compute_size_aligned, "computes size with alignment\n\nC++: VPUNN::IDeviceValidValues::compute_size_aligned(const long long, const enum VPUNN::DataType &) const --> long long", pybind11::arg("elements_count"), pybind11::arg("datatype"));
		cl.def("compute_size_raw", (long long (VPUNN::IDeviceValidValues::*)(const long long, const enum VPUNN::DataType &) const) &VPUNN::IDeviceValidValues::compute_size_raw, "computes size without alignment\n\nC++: VPUNN::IDeviceValidValues::compute_size_raw(const long long, const enum VPUNN::DataType &) const --> long long", pybind11::arg("elements_count"), pybind11::arg("datatype"));
		cl.def("is_valid_operation", (bool (VPUNN::IDeviceValidValues::*)(const enum VPUNN::Operation) const) &VPUNN::IDeviceValidValues::is_valid_operation, "C++: VPUNN::IDeviceValidValues::is_valid_operation(const enum VPUNN::Operation) const --> bool", pybind11::arg("op"));

		{ // VPUNN::IDeviceValidValues::ValidDatatypes file: line:85
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::IDeviceValidValues::ValidDatatypes, std::shared_ptr<VPUNN::IDeviceValidValues::ValidDatatypes>> cl(enclosing_class, "ValidDatatypes", "collection of possible datatypes for different in/outs and operations");
			cl.def( pybind11::init( [](VPUNN::IDeviceValidValues::ValidDatatypes const &o){ return new VPUNN::IDeviceValidValues::ValidDatatypes(o); } ) );
			cl.def( pybind11::init( [](){ return new VPUNN::IDeviceValidValues::ValidDatatypes(); } ) );
			cl.def_readwrite("input_datatypes", &VPUNN::IDeviceValidValues::ValidDatatypes::input_datatypes);
			cl.def_readwrite("output_datatypes", &VPUNN::IDeviceValidValues::ValidDatatypes::output_datatypes);
			cl.def_readwrite("weights_datatypes", &VPUNN::IDeviceValidValues::ValidDatatypes::weights_datatypes);
			cl.def("assign", (class VPUNN::IDeviceValidValues::ValidDatatypes & (VPUNN::IDeviceValidValues::ValidDatatypes::*)(const class VPUNN::IDeviceValidValues::ValidDatatypes &)) &VPUNN::IDeviceValidValues::ValidDatatypes::operator=, "C++: VPUNN::IDeviceValidValues::ValidDatatypes::operator=(const class VPUNN::IDeviceValidValues::ValidDatatypes &) --> class VPUNN::IDeviceValidValues::ValidDatatypes &", pybind11::return_value_policy::reference, pybind11::arg(""));
		}

		{ // VPUNN::IDeviceValidValues::ValidExecutionModes file: line:94
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::IDeviceValidValues::ValidExecutionModes, std::shared_ptr<VPUNN::IDeviceValidValues::ValidExecutionModes>> cl(enclosing_class, "ValidExecutionModes", "collection of possible execution modes for different operations");
			cl.def( pybind11::init( [](VPUNN::IDeviceValidValues::ValidExecutionModes const &o){ return new VPUNN::IDeviceValidValues::ValidExecutionModes(o); } ) );
			cl.def( pybind11::init( [](){ return new VPUNN::IDeviceValidValues::ValidExecutionModes(); } ) );
			cl.def_readwrite("execution_modes", &VPUNN::IDeviceValidValues::ValidExecutionModes::execution_modes);
			cl.def("assign", (class VPUNN::IDeviceValidValues::ValidExecutionModes & (VPUNN::IDeviceValidValues::ValidExecutionModes::*)(const class VPUNN::IDeviceValidValues::ValidExecutionModes &)) &VPUNN::IDeviceValidValues::ValidExecutionModes::operator=, "C++: VPUNN::IDeviceValidValues::ValidExecutionModes::operator=(const class VPUNN::IDeviceValidValues::ValidExecutionModes &) --> class VPUNN::IDeviceValidValues::ValidExecutionModes &", pybind11::return_value_policy::reference, pybind11::arg(""));
		}

	}
}


// File: VPUNN_14.cpp
#include <array> // std::array
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_14(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::VPUTilingStrategy file: line:19
	pybind11::enum_<VPUNN::VPUTilingStrategy>(M("VPUNN"), "VPUTilingStrategy", "VPU tiling strategy. How to split a Layer on multiple tiles")
		.value("NONE", VPUNN::VPUTilingStrategy::NONE)
		.value("SOH_Overlapped", VPUNN::VPUTilingStrategy::SOH_Overlapped)
		.value("SOK", VPUNN::VPUTilingStrategy::SOK)
		.value("SOW", VPUNN::VPUTilingStrategy::SOW)
		.value("SOHW", VPUNN::VPUTilingStrategy::SOHW)
		.value("SOHK", VPUNN::VPUTilingStrategy::SOHK)
		.value("SOH_HaloRead", VPUNN::VPUTilingStrategy::SOH_HaloRead)
		.value("SOHO_K_SWITCH", VPUNN::VPUTilingStrategy::SOHO_K_SWITCH)
		.value("SOH_K_SWITCH", VPUNN::VPUTilingStrategy::SOH_K_SWITCH)
		.value("SOK_NO_BROADCAST", VPUNN::VPUTilingStrategy::SOK_NO_BROADCAST)
		.value("UNKNOWN", VPUNN::VPUTilingStrategy::UNKNOWN)
		.value("__size", VPUNN::VPUTilingStrategy::__size);

;

	// VPUNN::mapToText() file: line:48
	M("VPUNN").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::mapToText<VPUNN::VPUTilingStrategy>, "C++: VPUNN::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::enumName() file: line:53
	M("VPUNN").def("enumName", (std::string (*)()) &VPUNN::enumName<VPUNN::VPUTilingStrategy>, "C++: VPUNN::enumName() --> std::string");

	{ // VPUNN::DPULayer file: line:24
		pybind11::class_<VPUNN::DPULayer, std::shared_ptr<VPUNN::DPULayer>, VPUNN::DPUWorkload> cl(M("VPUNN"), "DPULayer", "DPULayer class. no data  only methods on top of DPUWorkload");
		cl.def( pybind11::init<enum VPUNN::VPUDevice, enum VPUNN::Operation, struct std::array<class VPUNN::VPUTensor, 1>, struct std::array<class VPUNN::VPUTensor, 1>, struct std::array<unsigned int, 2>, struct std::array<unsigned int, 2>, struct std::array<unsigned int, 4>>(), pybind11::arg("device"), pybind11::arg("op"), pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("kernels"), pybind11::arg("strides"), pybind11::arg("padding") );

		cl.def( pybind11::init<const struct VPUNN::DPUWorkload &>(), pybind11::arg("wl") );

		cl.def( pybind11::init( [](VPUNN::DPULayer const &o){ return new VPUNN::DPULayer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DPULayer(); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DPULayer(); } ) );
		cl.def_readwrite("compiler_pass", &VPUNN::DPULayer::compiler_pass);
		cl.def("get_layer_info", [](VPUNN::DPULayer const &o) -> std::string { return o.get_layer_info(); }, "");
		cl.def("set_layer_info", [](VPUNN::DPULayer &o, const std::string & a0) -> void { return o.set_layer_info(a0); }, "", pybind11::arg("layer_info_name"));
		cl.def("clustering", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int) const) &VPUNN::DPULayer::clustering, "Implements the Clustering tiling strategy (inter tile)\n \n\n In the clustering tiling strategy, both activations and weights are fully replicated in all tiles\n isi_strategy set to clustering\n and output_write_tiles are propagated from input\n\n \n number of dpu tiles\n \n\n std::vector<DPULayer> the list of layers\n\nC++: VPUNN::DPULayer::clustering(unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"));
		cl.def("SOH_deprecated", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int) const) &VPUNN::DPULayer::SOH_deprecated, "Implements the SplitOverH (SOH) tiling strategy (inter tile)\n \n\n In the SOH tiling strategy, activations are split across the tiles over the H dimension\n todo: Cut lines must be without padding\n todo: compute tensors have a halo where the cut is to indicate how many lines are taken from the other tile\n The weights are fully replicated in all tiles\n Populates also ISI strategy with SOH\n output_write_tiles is propagated from inputLayer  to the tiles Layers\n\nif output tiles are less than nTiles , the ISI strategy or output_write_tiles are not adjusted\n\n \n number of CMX tiles\n \n\n std::vector<DPULayer>  the list of split layers. can be smaller than nTiles\n THIS IS OLD and is neither SOH or SOHO\n /deprecated\n\nC++: VPUNN::DPULayer::SOH_deprecated(unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"));
		cl.def("SOH_overlapped_inputs", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int, bool) const) &VPUNN::DPULayer::SOH_overlapped_inputs, "Implements the SplitOverH_OVERLAPPED (SOH) tiling strategy (inter tile)\n \n\n In the SOHOVERLAPPED tiling strategy, activations are split across the tiles over the H dimension\n Compute tensors are the same as memory tensors (no halo at cut lines)\n no padding at cut lines\n Algorithhm or principle is: split the output in (almost)equal slices, for each output slice compute(chose the\n elements from original in tensor) the input tensor that you need in order to produce that output. The result will\n be a list of input tensors that overlap (except if kernel =1).\n\n Internal slices (tiles>2), have 2 borders and may produce more than outside slices.\n Populates also ISI strategy with CLUSTERING,\n output_write_tiles is propagated from inputLayer  to the tiles Layers\n\n if output tiles are less than nTiles , the ISI strategy or output_write_tiles are not adjusted\n\n Halo info are adjusted(set to zero) only for the vertical dimension/direction. REst are just propagated.\n OWT>1 will influence output_inbound halo foe vertical direction: like saying broadcast this tile to all tiles,\n the output memory tensor will get big (= original full height)\n\n \n number of CMX tiles\n \n\n std::vector<DPULayer>  the list of split layers. can be smaller than nTiles\n\nC++: VPUNN::DPULayer::SOH_overlapped_inputs(unsigned int, bool) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"), pybind11::arg("force_broadcast"));
		cl.def("SOW_overlapped_inputs", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int, bool) const) &VPUNN::DPULayer::SOW_overlapped_inputs, "Implements the SplitOverWidth (SOW) tiling strategy\n \n\n In the SOW tiling strategy, activations are split across the tiles over the W dimension\n Algorithm or principle is: split the output in (almost)equal slices, for each output slice compute(chose the\n elements from original in tensor) the input tensor that you need in order to produce that output. The result will\n be a list of input tensors that overlap (except if kernel =1).\n\n Internal slices (tiles>2), have 2 borders and may produce more than outside slices.\n Populates also ISI strategy with CLUSTERING,\n output_write_tiles is propagated from inputLayer  to the tiles Layers\n\n if output tiles are less than nTiles , the ISI strategy or output_write_tiles are not adjusted\n\n Halo info are adjusted(set to zero) only for the horizontal dimension/direction. REst are just propagated.\n OWT>1 will influence output_inbound halo for horizontal direction: like saying broadcast this tile to all tiles,\n the output memory tensor will get big (= original full height)\n\n \n number of CMX tiles\n \n\n std::vector<DPULayer>  the list of split layers. can be smaller than nTiles\n\nC++: VPUNN::DPULayer::SOW_overlapped_inputs(unsigned int, bool) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"), pybind11::arg("force_broadcast"));
		cl.def("SOK", [](VPUNN::DPULayer const &o, unsigned int const & a0) -> std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > { return o.SOK(a0); }, "", pybind11::arg("nTiles"));
		cl.def("SOK", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int, unsigned int) const) &VPUNN::DPULayer::SOK, "Implements the SplitOverK (SOK) tiling strategy\n \n\n In the SOK tiling strategy, weights are split across the tiles over the K dimension.\n The DPU in each tile compute a K-slice of the output tensors and then broadcast the result in each\n CMX tile, implicitly concatenating the results and having then all activations completely replicated\n\n Populates also ISI strategy with SOK\n output_write_tiles is set to actual nTiles\n if output tiles are less than nTiles output_write_tiles are adjusted to actual output tiles\n\n Halo Aspects: SOK makes no changes in input halo or output halo for HW dimensions.\n Output_inbound halo is affected by OWT (full tile broadcast), all tiles having full output tensor.\n\n \n number of CMX tiles\n \n\n the channel alignment\n \n\n std::vector<DPULayer>\n\nC++: VPUNN::DPULayer::SOK(unsigned int, unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"), pybind11::arg("rounding"));
		cl.def("SOK_no_broadcast", [](VPUNN::DPULayer const &o, unsigned int const & a0) -> std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > { return o.SOK_no_broadcast(a0); }, "", pybind11::arg("nTiles"));
		cl.def("SOK_no_broadcast", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int, unsigned int) const) &VPUNN::DPULayer::SOK_no_broadcast, "C++: VPUNN::DPULayer::SOK_no_broadcast(unsigned int, unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"), pybind11::arg("rounding"));
		cl.def("SOK_Variants", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int, bool, unsigned int) const) &VPUNN::DPULayer::SOK_Variants, "Implements the SplitOverK (SOK) tiling strategy\n \n\n In the SOK tiling strategy, weights are split across the tiles over the K dimension.\n The DPU in each tile compute a K-slice of the output tensors and then broadcast the result in each\n CMX tile, implicitly concatenating the results and having then all activations completely replicated\n\n Populates also ISI strategy with SOK\n output_write_tiles is set to actual nTiles\n if output tiles are less than nTiles output_write_tiles are adjusted to actual output tiles\n\n Halo Aspects: SOK makes no changes in input halo or output halo for HW dimensions.\n Output_inbound halo is affected by OWT (in case of full tile broadcast), all tiles having full output tensor.\n\n \n number of CMX tiles\n \n\n The split will be done  forcing broadcast, the output memory tensor will be larger (SOK\n classic). OWT will be propagated from parent in case of no force broadcast, and if the parent specifies OWT it\n will generate halo(broadcast is received).\n \n\n the channel alignment\n \n\n std::vector<DPULayer>\n\nC++: VPUNN::DPULayer::SOK_Variants(unsigned int, bool, unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"), pybind11::arg("force_broadcast"), pybind11::arg("rounding"));
		cl.def("SOH_HALO_inputs", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(unsigned int) const) &VPUNN::DPULayer::SOH_HALO_inputs, "Implements the SplitOverH_with HALO inputs (ISI for NPU2.7) tiling strategy (inter tile)\n \n\n In the SOH with input HALO tiling strategy, activations are split across the tiles over the H dimension\n Compute tensors arelarger than memory tensors ( halo present at cut lines)\n no padding at cut lines\n Algorithm or principle is: split the output in (almost)equal slices, for each output slice compute( chose the\n elements from original in tensor) the input tensor that you need in order to produce that output. For 2\n consecutive split compute tensors calculate the overlap region and distribute this overlap to memory and halo\n regions of the adjacent tensors.\n E.g.: if overlap is 4, tensors will take 2 in their memory, teh remaining 2 will treat as halo regions T1: takes\n 2 in memory + 2 as halo (from T2)\n\n Internal slices (tiles>2), have 2 borders and may produce more than outside slices.\n Populates also ISI strategy with SOH,\n output_write_tiles is propagated from inputLayer  to the tiles Layers\n\n \n: rework:  if output tiles are less than nTiles , the ISI strategy or output_write_tiles are not adjusted\n\n \n: rework:\n Halo info are adjusted(set to zero) only for the vertical dimension/direction. REst are just propagated.\n OWT>1 will influence output_inbound halo foe vertical direction: like saying broadcast this tile to all tiles,\n the output memory tensor will get big (= original full height)\n\n \n number of CMX tiles\n \n\n std::vector<DPULayer>  the list of split layers. can be smaller than nTiles\n\nC++: VPUNN::DPULayer::SOH_HALO_inputs(unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("nTiles"));
		cl.def("splitAcrossTiles", [](VPUNN::DPULayer const &o, enum VPUNN::VPUTilingStrategy const & a0) -> std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > { return o.splitAcrossTiles(a0); }, "", pybind11::arg("strategy"));
		cl.def("splitAcrossTiles", (class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > (VPUNN::DPULayer::*)(enum VPUNN::VPUTilingStrategy, unsigned int) const) &VPUNN::DPULayer::splitAcrossTiles, "Split a DPULayer across N CMX tiles\n\n \n the VPUTilingStrategy to implement\n \n\n number of CMX tiles\n \n\n std::vector<DPULayer>\n\nC++: VPUNN::DPULayer::splitAcrossTiles(enum VPUNN::VPUTilingStrategy, unsigned int) const --> class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> >", pybind11::arg("strategy"), pybind11::arg("nTiles"));
		cl.def_static("mapTilingStrategiesToWorkload", (enum VPUNN::ISIStrategy (*)(enum VPUNN::VPUTilingStrategy)) &VPUNN::DPULayer::mapTilingStrategiesToWorkload, "C++: VPUNN::DPULayer::mapTilingStrategiesToWorkload(enum VPUNN::VPUTilingStrategy) --> enum VPUNN::ISIStrategy", pybind11::arg("strategy"));
		cl.def("input_footprint", (unsigned int (VPUNN::DPULayer::*)(const class VPUNN::IDeviceValidValues &) const) &VPUNN::DPULayer::input_footprint, "The memory footprint of the input tensors\n\n \n unsigned int\n\nC++: VPUNN::DPULayer::input_footprint(const class VPUNN::IDeviceValidValues &) const --> unsigned int", pybind11::arg("config"));
		cl.def("output_footprint", (unsigned int (VPUNN::DPULayer::*)(const class VPUNN::IDeviceValidValues &) const) &VPUNN::DPULayer::output_footprint, "The memory footprint of the output tensors\n\n \n unsigned int\n\nC++: VPUNN::DPULayer::output_footprint(const class VPUNN::IDeviceValidValues &) const --> unsigned int", pybind11::arg("config"));
		cl.def("weight_footprint", (unsigned int (VPUNN::DPULayer::*)(const class VPUNN::IDeviceValidValues &) const) &VPUNN::DPULayer::weight_footprint, "The memory footprint of the weights, without end cmx alignment(16Kb normally)\n \n\n: this might be wrong, review\n\n \n a good configuration(rules & behaviors) according to the device of the layer.\n \n\n unsigned int bytes\n\nC++: VPUNN::DPULayer::weight_footprint(const class VPUNN::IDeviceValidValues &) const --> unsigned int", pybind11::arg("config"));
		cl.def("footprint", (unsigned int (VPUNN::DPULayer::*)(const class VPUNN::IDeviceValidValues &) const) &VPUNN::DPULayer::footprint, "Layer total memory footprint\n\n \n unsigned int\n\nC++: VPUNN::DPULayer::footprint(const class VPUNN::IDeviceValidValues &) const --> unsigned int", pybind11::arg("config"));
		cl.def("recomputeInputTensorShape", (void (VPUNN::DPULayer::*)()) &VPUNN::DPULayer::recomputeInputTensorShape, "recomputes the input based on operation and a changed output size\n affects only WHC dimensions based on Outputs kernels, stride, padding\n\nC++: VPUNN::DPULayer::recomputeInputTensorShape() --> void");
		cl.def("set_weight_sparsity", (void (VPUNN::DPULayer::*)(bool, float)) &VPUNN::DPULayer::set_weight_sparsity, "enables /disables the w sparsity and sets the value. Only combinations that are allowed\n when enabling sparsity_value is limited to [0.0, 1.0]\n when disabling , sparsity will be set to zero\n\n \n true/false\n \n\n , limited to [0.0, 1.0] for enabled and to 0.0 for disabled\n\nC++: VPUNN::DPULayer::set_weight_sparsity(bool, float) --> void", pybind11::arg("enabled"), pybind11::arg("sparsity_value"));
		cl.def("get_layer_name", (std::string (VPUNN::DPULayer::*)() const) &VPUNN::DPULayer::get_layer_name, "C++: VPUNN::DPULayer::get_layer_name() const --> std::string");
		cl.def("get_compiler_pass", (std::string (VPUNN::DPULayer::*)() const) &VPUNN::DPULayer::get_compiler_pass, "C++: VPUNN::DPULayer::get_compiler_pass() const --> std::string");
		cl.def("set_compiler_pass", (void (VPUNN::DPULayer::*)(const std::string &)) &VPUNN::DPULayer::set_compiler_pass, "C++: VPUNN::DPULayer::set_compiler_pass(const std::string &) --> void", pybind11::arg("compiler_pass_info"));
		cl.def("assign", (struct VPUNN::DPULayer & (VPUNN::DPULayer::*)(const struct VPUNN::DPULayer &)) &VPUNN::DPULayer::operator=, "C++: VPUNN::DPULayer::operator=(const struct VPUNN::DPULayer &) --> struct VPUNN::DPULayer &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_15.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IPostProcess file: line:17
struct PyCallBack_VPUNN_IPostProcess : public VPUNN::IPostProcess {
	using VPUNN::IPostProcess::IPostProcess;

	float process(const struct VPUNN::DPUWorkload & a0, const float & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPostProcess *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPostProcess::process\"");
	}
};

// VPUNN::PassThroughPostP file: line:53
struct PyCallBack_VPUNN_PassThroughPostP : public VPUNN::PassThroughPostP {
	using VPUNN::PassThroughPostP::PassThroughPostP;

	float process(const struct VPUNN::DPUWorkload & a0, const float & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PassThroughPostP *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return PassThroughPostP::process(a0, a1);
	}
};

// VPUNN::AdaptFromNPU27to40 file: line:63
struct PyCallBack_VPUNN_AdaptFromNPU27to40 : public VPUNN::AdaptFromNPU27to40 {
	using VPUNN::AdaptFromNPU27to40::AdaptFromNPU27to40;

	float process(const struct VPUNN::DPUWorkload & a0, const float & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AdaptFromNPU27to40 *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return AdaptFromNPU27to40::process(a0, a1);
	}
};

// VPUNN::AdaptFromNPU40to40 file: line:216
struct PyCallBack_VPUNN_AdaptFromNPU40to40 : public VPUNN::AdaptFromNPU40to40 {
	using VPUNN::AdaptFromNPU40to40::AdaptFromNPU40to40;

	float process(const struct VPUNN::DPUWorkload & a0, const float & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AdaptFromNPU40to40 *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return AdaptFromNPU40to40::process(a0, a1);
	}
};

// VPUNN::Preprocessing file: line:31
struct PyCallBack_VPUNN_Preprocessing_float_t : public VPUNN::Preprocessing<float> {
	using VPUNN::Preprocessing<float>::Preprocessing;

	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing<float> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"Preprocessing::generate_descriptor\"");
	}
	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing<float> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"Preprocessing::interface_version\"");
	}
};

void bind_VPUNN_15(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::AccessCounter file: line:33
		pybind11::class_<VPUNN::AccessCounter, std::shared_ptr<VPUNN::AccessCounter>> cl(M("VPUNN"), "AccessCounter", "");
		cl.def( pybind11::init( [](){ return new VPUNN::AccessCounter(); } ) );
		cl.def( pybind11::init<std::string>(), pybind11::arg("desiredName") );

		cl.def("getName", (std::string (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::getName, "C++: VPUNN::AccessCounter::getName() const --> std::string");
		cl.def("access", [](VPUNN::AccessCounter &o) -> void { return o.access(); }, "");
		cl.def("access", (void (VPUNN::AccessCounter::*)(bool)) &VPUNN::AccessCounter::access, "C++: VPUNN::AccessCounter::access(bool) --> void", pybind11::arg("hit"));
		cl.def("hit", (void (VPUNN::AccessCounter::*)()) &VPUNN::AccessCounter::hit, "C++: VPUNN::AccessCounter::hit() --> void");
		cl.def("miss", (void (VPUNN::AccessCounter::*)()) &VPUNN::AccessCounter::miss, "C++: VPUNN::AccessCounter::miss() --> void");
		cl.def("reset", (void (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::reset, "C++: VPUNN::AccessCounter::reset() const --> void");
		cl.def("printToLog", [](VPUNN::AccessCounter const &o) -> void { return o.printToLog(); }, "");
		cl.def("printToLog", (void (VPUNN::AccessCounter::*)(const std::string) const) &VPUNN::AccessCounter::printToLog, "C++: VPUNN::AccessCounter::printToLog(const std::string) const --> void", pybind11::arg("prefix"));
		cl.def("printToCout", (void (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::printToCout, "C++: VPUNN::AccessCounter::printToCout() const --> void");
		cl.def("printString", (std::string (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::printString, "C++: VPUNN::AccessCounter::printString() const --> std::string");
		cl.def("getAccesses", (unsigned long (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::getAccesses, "C++: VPUNN::AccessCounter::getAccesses() const --> unsigned long");
		cl.def("getHits", (unsigned long (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::getHits, "C++: VPUNN::AccessCounter::getHits() const --> unsigned long");
		cl.def("getMisses", (unsigned long (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::getMisses, "C++: VPUNN::AccessCounter::getMisses() const --> unsigned long");
		cl.def("getHitRatio", (double (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::getHitRatio, "C++: VPUNN::AccessCounter::getHitRatio() const --> double");
		cl.def("getMissRatio", (double (VPUNN::AccessCounter::*)() const) &VPUNN::AccessCounter::getMissRatio, "C++: VPUNN::AccessCounter::getMissRatio() const --> double");
	}
	{ // VPUNN::FixedCacheAddON file: line:30
		pybind11::class_<VPUNN::FixedCacheAddON<VPUNN::SHAVEWorkload,float>, std::shared_ptr<VPUNN::FixedCacheAddON<VPUNN::SHAVEWorkload,float>>> cl(M("VPUNN"), "FixedCacheAddON_VPUNN_SHAVEWorkload_float_t", "");
		cl.def("getPreloadedCacheCounter", (const class VPUNN::AccessCounter & (VPUNN::FixedCacheAddON<VPUNN::SHAVEWorkload,float>::*)() const) &VPUNN::FixedCacheAddON<VPUNN::SHAVEWorkload, float>::getPreloadedCacheCounter, "C++: VPUNN::FixedCacheAddON<VPUNN::SHAVEWorkload, float>::getPreloadedCacheCounter() const --> const class VPUNN::AccessCounter &", pybind11::return_value_policy::reference);
	}
	{ // VPUNN::FixedCacheAddON file: line:30
		pybind11::class_<VPUNN::FixedCacheAddON<std::vector<float, std::allocator<float> >,float>, std::shared_ptr<VPUNN::FixedCacheAddON<std::vector<float, std::allocator<float> >,float>>> cl(M("VPUNN"), "FixedCacheAddON_std_vector_float_std_allocator_float_float_t", "");
		cl.def("getPreloadedCacheCounter", (const class VPUNN::AccessCounter & (VPUNN::FixedCacheAddON<std::vector<float, std::allocator<float> >,float>::*)() const) &VPUNN::FixedCacheAddON<std::vector<float, std::allocator<float> >, float>::getPreloadedCacheCounter, "C++: VPUNN::FixedCacheAddON<std::vector<float, std::allocator<float> >, float>::getPreloadedCacheCounter() const --> const class VPUNN::AccessCounter &", pybind11::return_value_policy::reference);
	}
	// VPUNN::NNOutputVersions file: line:23
	pybind11::enum_<VPUNN::NNOutputVersions>(M("VPUNN"), "NNOutputVersions", "enum for NN output versions")
		.value("OUT_LATEST", VPUNN::NNOutputVersions::OUT_LATEST)
		.value("OUT_HW_OVERHEAD_BOUNDED", VPUNN::NNOutputVersions::OUT_HW_OVERHEAD_BOUNDED)
		.value("OUT_CYCLES", VPUNN::NNOutputVersions::OUT_CYCLES)
		.value("OUT_HW_OVERHEAD_UNBOUNDED", VPUNN::NNOutputVersions::OUT_HW_OVERHEAD_UNBOUNDED)
		.value("OUT_CYCLES_NPU27", VPUNN::NNOutputVersions::OUT_CYCLES_NPU27)
		.value("OUT_CYCLES_NPU40_DEV", VPUNN::NNOutputVersions::OUT_CYCLES_NPU40_DEV);

;

	{ // VPUNN::PostProcessSupport file: line:39
		pybind11::class_<VPUNN::PostProcessSupport, std::shared_ptr<VPUNN::PostProcessSupport>> cl(M("VPUNN"), "PostProcessSupport", "Configuration options concerning the interpretation and post processing of inferred values\n This class have the goal to check if we know something about the output version of the model and if we don't know we\n will not support the output for the CostModel. We are going to use the output version parsed by the ModelVersion and\n use it to determine based on known output version if we support it or not. In case that we don't know the version we\n are going to not supprt the output.");
		cl.def( pybind11::init<int>(), pybind11::arg("output_version") );

		cl.def( pybind11::init( [](VPUNN::PostProcessSupport const &o){ return new VPUNN::PostProcessSupport(o); } ) );
		cl.def("is_output_supported", (bool (VPUNN::PostProcessSupport::*)() const) &VPUNN::PostProcessSupport::is_output_supported, "a method to see if we support the output\n\nC++: VPUNN::PostProcessSupport::is_output_supported() const --> bool");
	}
	{ // VPUNN::IPostProcess file: line:17
		pybind11::class_<VPUNN::IPostProcess, std::shared_ptr<VPUNN::IPostProcess>, PyCallBack_VPUNN_IPostProcess> cl(M("VPUNN"), "IPostProcess", "");
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IPostProcess(); } ) );
		cl.def(pybind11::init<PyCallBack_VPUNN_IPostProcess const &>());
		cl.def("process", (float (VPUNN::IPostProcess::*)(const struct VPUNN::DPUWorkload &, const float &) const) &VPUNN::IPostProcess::process, "C++: VPUNN::IPostProcess::process(const struct VPUNN::DPUWorkload &, const float &) const --> float", pybind11::arg(""), pybind11::arg("nn_val"));
		cl.def_static("is_NN_value_invalid", (bool (*)(const float)) &VPUNN::IPostProcess::is_NN_value_invalid, "checks if the NN returned value is invalid, is outside of usable range\n \n\n , the value to be analyzed, this is assumed given by the NN inference\n \n\n true if invalid value\n\nC++: VPUNN::IPostProcess::is_NN_value_invalid(const float) --> bool", pybind11::arg("nn_output_cycles"));
		cl.def_static("get_NN_Valid_interval", (struct std::pair<float, float> (*)()) &VPUNN::IPostProcess::get_NN_Valid_interval, "provides the value interval where the NN raw outputs are considered valid and will be used to further\n compute information\n\n \n a pair containing (minimum_valid_value maximum_valid_value)\n\nC++: VPUNN::IPostProcess::get_NN_Valid_interval() --> struct std::pair<float, float>");
		cl.def("assign", (class VPUNN::IPostProcess & (VPUNN::IPostProcess::*)(const class VPUNN::IPostProcess &)) &VPUNN::IPostProcess::operator=, "C++: VPUNN::IPostProcess::operator=(const class VPUNN::IPostProcess &) --> class VPUNN::IPostProcess &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::PassThroughPostP file: line:53
		pybind11::class_<VPUNN::PassThroughPostP, std::shared_ptr<VPUNN::PassThroughPostP>, PyCallBack_VPUNN_PassThroughPostP, VPUNN::IPostProcess> cl(M("VPUNN"), "PassThroughPostP", "A pass through post processing, does nothing, just returns the NN value");
		cl.def( pybind11::init( [](){ return new VPUNN::PassThroughPostP(); }, [](){ return new PyCallBack_VPUNN_PassThroughPostP(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_PassThroughPostP const &o){ return new PyCallBack_VPUNN_PassThroughPostP(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PassThroughPostP const &o){ return new VPUNN::PassThroughPostP(o); } ) );
		cl.def("process", (float (VPUNN::PassThroughPostP::*)(const struct VPUNN::DPUWorkload &, const float &) const) &VPUNN::PassThroughPostP::process, "C++: VPUNN::PassThroughPostP::process(const struct VPUNN::DPUWorkload &, const float &) const --> float", pybind11::arg(""), pybind11::arg("nn_val"));
		cl.def("assign", (class VPUNN::PassThroughPostP & (VPUNN::PassThroughPostP::*)(const class VPUNN::PassThroughPostP &)) &VPUNN::PassThroughPostP::operator=, "C++: VPUNN::PassThroughPostP::operator=(const class VPUNN::PassThroughPostP &) --> class VPUNN::PassThroughPostP &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::AdaptFromNPU27to40 file: line:63
		pybind11::class_<VPUNN::AdaptFromNPU27to40, std::shared_ptr<VPUNN::AdaptFromNPU27to40>, PyCallBack_VPUNN_AdaptFromNPU27to40, VPUNN::IPostProcess> cl(M("VPUNN"), "AdaptFromNPU27to40", "post process cycle times obtained from a NPU2.7 model.\n For now adapts to NPU4.0 and above, by applying a factor to the cycles");
		cl.def( pybind11::init( [](){ return new VPUNN::AdaptFromNPU27to40(); }, [](){ return new PyCallBack_VPUNN_AdaptFromNPU27to40(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_AdaptFromNPU27to40 const &o){ return new PyCallBack_VPUNN_AdaptFromNPU27to40(o); } ) );
		cl.def( pybind11::init( [](VPUNN::AdaptFromNPU27to40 const &o){ return new VPUNN::AdaptFromNPU27to40(o); } ) );
		cl.def("process", (float (VPUNN::AdaptFromNPU27to40::*)(const struct VPUNN::DPUWorkload &, const float &) const) &VPUNN::AdaptFromNPU27to40::process, "scales the cycles based on the workload and the NN value.\n Crt implementation treats only DW_CONV optimization of NPU4.0 vs NPU2.7\n\nC++: VPUNN::AdaptFromNPU27to40::process(const struct VPUNN::DPUWorkload &, const float &) const --> float", pybind11::arg("w"), pybind11::arg("nn_val"));
		cl.def("assign", (class VPUNN::AdaptFromNPU27to40 & (VPUNN::AdaptFromNPU27to40::*)(const class VPUNN::AdaptFromNPU27to40 &)) &VPUNN::AdaptFromNPU27to40::operator=, "C++: VPUNN::AdaptFromNPU27to40::operator=(const class VPUNN::AdaptFromNPU27to40 &) --> class VPUNN::AdaptFromNPU27to40 &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::AdaptFromNPU40to40 file: line:216
		pybind11::class_<VPUNN::AdaptFromNPU40to40, std::shared_ptr<VPUNN::AdaptFromNPU40to40>, PyCallBack_VPUNN_AdaptFromNPU40to40, VPUNN::IPostProcess> cl(M("VPUNN"), "AdaptFromNPU40to40", "post process cycle times obtained from a NPU40model.\n For now adapts to NPU4.0 and above since we have gaps in trained space.\n  CM conv not covered, replaced by CONV with IC=16");
		cl.def( pybind11::init( [](){ return new VPUNN::AdaptFromNPU40to40(); }, [](){ return new PyCallBack_VPUNN_AdaptFromNPU40to40(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_AdaptFromNPU40to40 const &o){ return new PyCallBack_VPUNN_AdaptFromNPU40to40(o); } ) );
		cl.def( pybind11::init( [](VPUNN::AdaptFromNPU40to40 const &o){ return new VPUNN::AdaptFromNPU40to40(o); } ) );
		cl.def("process", (float (VPUNN::AdaptFromNPU40to40::*)(const struct VPUNN::DPUWorkload &, const float &) const) &VPUNN::AdaptFromNPU40to40::process, "scales the cycles based on the workload and the NN value.\n Crt implementation treats only CM_CONV untrained space\n\nC++: VPUNN::AdaptFromNPU40to40::process(const struct VPUNN::DPUWorkload &, const float &) const --> float", pybind11::arg("w"), pybind11::arg("nn_val"));
		cl.def("assign", (class VPUNN::AdaptFromNPU40to40 & (VPUNN::AdaptFromNPU40to40::*)(const class VPUNN::AdaptFromNPU40to40 &)) &VPUNN::AdaptFromNPU40to40::operator=, "C++: VPUNN::AdaptFromNPU40to40::operator=(const class VPUNN::AdaptFromNPU40to40 &) --> class VPUNN::AdaptFromNPU40to40 &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::PostProcessingFactory file: line:28
		pybind11::class_<VPUNN::PostProcessingFactory, std::shared_ptr<VPUNN::PostProcessingFactory>> cl(M("VPUNN"), "PostProcessingFactory", "Provides processing related objects based on context\n\n The provided objects may be bounded(lifespan) to this instance");
		cl.def( pybind11::init( [](VPUNN::PostProcessingFactory const &o){ return new VPUNN::PostProcessingFactory(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::PostProcessingFactory(); } ) );
		cl.def("exists", (bool (VPUNN::PostProcessingFactory::*)(int) const) &VPUNN::PostProcessingFactory::exists, "True if a preprocessor exists for required/interrogated version\n\nC++: VPUNN::PostProcessingFactory::exists(int) const --> bool", pybind11::arg("version"));
		cl.def("make", (const class VPUNN::IPostProcess & (VPUNN::PostProcessingFactory::*)(int) const) &VPUNN::PostProcessingFactory::make, "provides a processor for the required interface\n The provided rocessor is owned by this class.\n For NOW multiple requests for the same version will provide the same object, the factory just shares the\n preprocessors , does not create a new one for each request\n \n\n desired interface version\n \n\n the processor object to be used (shared)\n \n\n out_of_range in case the version is not supported\n\nC++: VPUNN::PostProcessingFactory::make(int) const --> const class VPUNN::IPostProcess &", pybind11::return_value_policy::reference, pybind11::arg("version"));
	}
	// VPUNN::NNVersions file: line:16
	pybind11::enum_<VPUNN::NNVersions>(M("VPUNN"), "NNVersions", "enum for NN descriptor versions (input versions)")
		.value("VERSION_00_LATEST_NONE", VPUNN::NNVersions::VERSION_00_LATEST_NONE)
		.value("VERSION_01_BASE", VPUNN::NNVersions::VERSION_01_BASE)
		.value("VERSION_10_ENUMS_SAME", VPUNN::NNVersions::VERSION_10_ENUMS_SAME)
		.value("VERSION_11_VPU27_BETA", VPUNN::NNVersions::VERSION_11_VPU27_BETA)
		.value("VERSION_12_HALO", VPUNN::NNVersions::VERSION_12_HALO)
		.value("VERSION_11_V89_COMPTBL", VPUNN::NNVersions::VERSION_11_V89_COMPTBL)
		.value("VERSION_11_NPU40", VPUNN::NNVersions::VERSION_11_NPU40)
		.value("VERSION_11_NPU41", VPUNN::NNVersions::VERSION_11_NPU41)
		.value("VERSION_12_NPU51", VPUNN::NNVersions::VERSION_12_NPU51)
		.value("VERSION_13_NPU51", VPUNN::NNVersions::VERSION_13_NPU51)
		.value("VERSION_14_NPU51", VPUNN::NNVersions::VERSION_14_NPU51)
		.value("VERSION_15_NPU_RESERVED_11", VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11);

;

	// VPUNN::NNVersionsDMA file: line:33
	pybind11::enum_<VPUNN::NNVersionsDMA>(M("VPUNN"), "NNVersionsDMA", "enum for NN descriptor versions (input versions)")
		.value("VERSION_00_LATEST_NONE", VPUNN::NNVersionsDMA::VERSION_00_LATEST_NONE)
		.value("VERSION_01_27", VPUNN::NNVersionsDMA::VERSION_01_27)
		.value("VERSION_02_40", VPUNN::NNVersionsDMA::VERSION_02_40)
		.value("VERSION_03_50_v1", VPUNN::NNVersionsDMA::VERSION_03_50_v1);

;

	{ // VPUNN::Preprocessing file: line:31
		pybind11::class_<VPUNN::Preprocessing<float>, std::shared_ptr<VPUNN::Preprocessing<float>>, PyCallBack_VPUNN_Preprocessing_float_t> cl(M("VPUNN"), "Preprocessing_float_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def(pybind11::init<PyCallBack_VPUNN_Preprocessing_float_t const &>());
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_16.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types01.h> // VPUNN::Preprocessing_Interface01
#include <vpu/compatibility/types01.h> // VPUNN::Preprocessing_Interface10
#include <vpu/compatibility/types11.h> // VPUNN::Preprocessing_Interface11_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface01_float_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface10_float_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_16(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface01_float_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface01_float_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface01_float_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface01_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface10_float_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface10_float_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface10_float_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface10_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_17.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types11.h> // VPUNN::Preprocessing_Interface11_Archetype
#include <vpu/compatibility/types12.h> // VPUNN::Preprocessing_Interface12_Archetype
#include <vpu/compatibility/types13.h> // VPUNN::Preprocessing_Interface13_Archetype
#include <vpu/compatibility/types14.h> // VPUNN::Preprocessing_Interface14_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_17(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_18.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types11.h> // VPUNN::Preprocessing_Interface11_Archetype
#include <vpu/compatibility/types15.h> // VPUNN::Preprocessing_Interface15_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserter file: line:35
struct PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t : public VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>> {
	using VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>::PreprocessingInserter;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_18(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserter file: line:35
		pybind11::class_<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>, std::shared_ptr<VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>>, PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t, VPUNN::Preprocessing<float>> cl(M("VPUNN"), "PreprocessingInserter_float_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserter_float_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>> const &o){ return new VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_19.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::ActivationFunction
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::DataType
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::ExecutionMode
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::Layout
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::MemoryLocation
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::Operation
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::Swizzling
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::VPUDevice
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::VPUSubsystem
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::convert
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::mapFromText
#include <vpu/compatibility/types01.h> // VPUNN::intf_01::mapToText

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_19(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_01::mapFromText() file:vpu/compatibility/types01.h line:41
	M("VPUNN::intf_01").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_01::mapFromText<VPUNN::intf_01::VPUDevice>, "C++: VPUNN::intf_01::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::mapFromText() file:vpu/compatibility/types01.h line:41
	M("VPUNN::intf_01").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_01::mapFromText<VPUNN::intf_01::Operation>, "C++: VPUNN::intf_01::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::mapFromText() file:vpu/compatibility/types01.h line:41
	M("VPUNN::intf_01").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_01::mapFromText<VPUNN::intf_01::DataType>, "C++: VPUNN::intf_01::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::mapFromText() file:vpu/compatibility/types01.h line:41
	M("VPUNN::intf_01").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_01::mapFromText<VPUNN::intf_01::ExecutionMode>, "C++: VPUNN::intf_01::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::mapFromText() file:vpu/compatibility/types01.h line:41
	M("VPUNN::intf_01").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_01::mapFromText<VPUNN::intf_01::ActivationFunction>, "C++: VPUNN::intf_01::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::mapFromText() file:vpu/compatibility/types01.h line:41
	M("VPUNN::intf_01").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_01::mapFromText<VPUNN::intf_01::Swizzling>, "C++: VPUNN::intf_01::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::VPUDevice file:vpu/compatibility/types01.h line:50
	pybind11::enum_<VPUNN::intf_01::VPUDevice>(M("VPUNN::intf_01"), "VPUDevice", "VPU IP generations\n\n ")
		.value("VPU_2_0", VPUNN::intf_01::VPUDevice::VPU_2_0)
		.value("VPU_2_1", VPUNN::intf_01::VPUDevice::VPU_2_1)
		.value("VPU_2_7", VPUNN::intf_01::VPUDevice::VPU_2_7)
		.value("VPU_4_0", VPUNN::intf_01::VPUDevice::VPU_4_0)
		.value("__size", VPUNN::intf_01::VPUDevice::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:58
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::VPUDevice>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::DataType file:vpu/compatibility/types01.h line:66
	pybind11::enum_<VPUNN::intf_01::DataType>(M("VPUNN::intf_01"), "DataType", "Supported Datatypes\n\n ")
		.value("UINT8", VPUNN::intf_01::DataType::UINT8)
		.value("INT8", VPUNN::intf_01::DataType::INT8)
		.value("FLOAT16", VPUNN::intf_01::DataType::FLOAT16)
		.value("BFLOAT16", VPUNN::intf_01::DataType::BFLOAT16)
		.value("__size", VPUNN::intf_01::DataType::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:74
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::DataType>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::Operation file:vpu/compatibility/types01.h line:82
	pybind11::enum_<VPUNN::intf_01::Operation>(M("VPUNN::intf_01"), "Operation", "HW operations\n\n ")
		.value("CONVOLUTION", VPUNN::intf_01::Operation::CONVOLUTION)
		.value("DW_CONVOLUTION", VPUNN::intf_01::Operation::DW_CONVOLUTION)
		.value("ELTWISE", VPUNN::intf_01::Operation::ELTWISE)
		.value("MAXPOOL", VPUNN::intf_01::Operation::MAXPOOL)
		.value("AVEPOOL", VPUNN::intf_01::Operation::AVEPOOL)
		.value("CM_CONVOLUTION", VPUNN::intf_01::Operation::CM_CONVOLUTION)
		.value("__size", VPUNN::intf_01::Operation::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:89
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::Operation>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::ActivationFunction file:vpu/compatibility/types01.h line:97
	pybind11::enum_<VPUNN::intf_01::ActivationFunction>(M("VPUNN::intf_01"), "ActivationFunction", "Supported activation functions\n\n ")
		.value("NONE", VPUNN::intf_01::ActivationFunction::NONE)
		.value("RELU", VPUNN::intf_01::ActivationFunction::RELU)
		.value("LRELU", VPUNN::intf_01::ActivationFunction::LRELU)
		.value("ADD", VPUNN::intf_01::ActivationFunction::ADD)
		.value("SUB", VPUNN::intf_01::ActivationFunction::SUB)
		.value("MULT", VPUNN::intf_01::ActivationFunction::MULT)
		.value("__size", VPUNN::intf_01::ActivationFunction::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:104
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::ActivationFunction>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::Swizzling file:vpu/compatibility/types01.h line:112
	pybind11::enum_<VPUNN::intf_01::Swizzling>(M("VPUNN::intf_01"), "Swizzling", "Swizzling keys\n\n ")
		.value("KEY_0", VPUNN::intf_01::Swizzling::KEY_0)
		.value("KEY_1", VPUNN::intf_01::Swizzling::KEY_1)
		.value("KEY_2", VPUNN::intf_01::Swizzling::KEY_2)
		.value("KEY_3", VPUNN::intf_01::Swizzling::KEY_3)
		.value("KEY_4", VPUNN::intf_01::Swizzling::KEY_4)
		.value("KEY_5", VPUNN::intf_01::Swizzling::KEY_5)
		.value("__size", VPUNN::intf_01::Swizzling::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:118
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::Swizzling>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::ExecutionMode file:vpu/compatibility/types01.h line:125
	pybind11::enum_<VPUNN::intf_01::ExecutionMode>(M("VPUNN::intf_01"), "ExecutionMode", "DPU execution modes\n\n ")
		.value("VECTOR", VPUNN::intf_01::ExecutionMode::VECTOR)
		.value("MATRIX", VPUNN::intf_01::ExecutionMode::MATRIX)
		.value("VECTOR_FP16", VPUNN::intf_01::ExecutionMode::VECTOR_FP16)
		.value("CUBOID_16x16", VPUNN::intf_01::ExecutionMode::CUBOID_16x16)
		.value("CUBOID_8x16", VPUNN::intf_01::ExecutionMode::CUBOID_8x16)
		.value("CUBOID_4x16", VPUNN::intf_01::ExecutionMode::CUBOID_4x16)
		.value("__size", VPUNN::intf_01::ExecutionMode::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:132
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::ExecutionMode>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::Layout file:vpu/compatibility/types01.h line:140
	pybind11::enum_<VPUNN::intf_01::Layout>(M("VPUNN::intf_01"), "Layout", "Data layout\n\n ")
		.value("ZMAJOR", VPUNN::intf_01::Layout::ZMAJOR)
		.value("CMAJOR", VPUNN::intf_01::Layout::CMAJOR)
		.value("__size", VPUNN::intf_01::Layout::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:146
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::Layout>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::MemoryLocation file:vpu/compatibility/types01.h line:154
	pybind11::enum_<VPUNN::intf_01::MemoryLocation>(M("VPUNN::intf_01"), "MemoryLocation", "Memory locations\n\n ")
		.value("DRAM", VPUNN::intf_01::MemoryLocation::DRAM)
		.value("CMX", VPUNN::intf_01::MemoryLocation::CMX)
		.value("CSRAM", VPUNN::intf_01::MemoryLocation::CSRAM)
		.value("UPA", VPUNN::intf_01::MemoryLocation::UPA)
		.value("__size", VPUNN::intf_01::MemoryLocation::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:162
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::MemoryLocation>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::VPUSubsystem file:vpu/compatibility/types01.h line:170
	pybind11::enum_<VPUNN::intf_01::VPUSubsystem>(M("VPUNN::intf_01"), "VPUSubsystem", "VPU Hw subsystem\n\n ")
		.value("VPU_DPU", VPUNN::intf_01::VPUSubsystem::VPU_DPU)
		.value("VPU_SHV", VPUNN::intf_01::VPUSubsystem::VPU_SHV)
		.value("VPU_DMA", VPUNN::intf_01::VPUSubsystem::VPU_DMA)
		.value("VPU_CPU", VPUNN::intf_01::VPUSubsystem::VPU_CPU)
		.value("VPU_CMX", VPUNN::intf_01::VPUSubsystem::VPU_CMX)
		.value("__size", VPUNN::intf_01::VPUSubsystem::__size);

;

	// VPUNN::intf_01::mapToText() file:vpu/compatibility/types01.h line:177
	M("VPUNN::intf_01").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_01::mapToText<VPUNN::intf_01::VPUSubsystem>, "C++: VPUNN::intf_01::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_01::convert(enum VPUNN::DataType) file:vpu/compatibility/types01.h line:187
	M("VPUNN::intf_01").def("convert", (enum VPUNN::intf_01::DataType (*)(enum VPUNN::DataType)) &VPUNN::intf_01::convert<VPUNN::intf_01::DataType,VPUNN::DataType>, "C++: VPUNN::intf_01::convert(enum VPUNN::DataType) --> enum VPUNN::intf_01::DataType", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_01::convert(enum VPUNN::VPUDevice) file:vpu/compatibility/types01.h line:187
	M("VPUNN::intf_01").def("convert", (enum VPUNN::intf_01::VPUDevice (*)(enum VPUNN::VPUDevice)) &VPUNN::intf_01::convert<VPUNN::intf_01::VPUDevice,VPUNN::VPUDevice>, "C++: VPUNN::intf_01::convert(enum VPUNN::VPUDevice) --> enum VPUNN::intf_01::VPUDevice", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_01::convert(enum VPUNN::Operation) file:vpu/compatibility/types01.h line:187
	M("VPUNN::intf_01").def("convert", (enum VPUNN::intf_01::Operation (*)(enum VPUNN::Operation)) &VPUNN::intf_01::convert<VPUNN::intf_01::Operation,VPUNN::Operation>, "C++: VPUNN::intf_01::convert(enum VPUNN::Operation) --> enum VPUNN::intf_01::Operation", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_01::convert(enum VPUNN::ExecutionMode) file:vpu/compatibility/types01.h line:187
	M("VPUNN::intf_01").def("convert", (enum VPUNN::intf_01::ExecutionMode (*)(enum VPUNN::ExecutionMode)) &VPUNN::intf_01::convert<VPUNN::intf_01::ExecutionMode,VPUNN::ExecutionMode>, "C++: VPUNN::intf_01::convert(enum VPUNN::ExecutionMode) --> enum VPUNN::intf_01::ExecutionMode", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_01::convert(enum VPUNN::ActivationFunction) file:vpu/compatibility/types01.h line:187
	M("VPUNN::intf_01").def("convert", (enum VPUNN::intf_01::ActivationFunction (*)(enum VPUNN::ActivationFunction)) &VPUNN::intf_01::convert<VPUNN::intf_01::ActivationFunction,VPUNN::ActivationFunction>, "C++: VPUNN::intf_01::convert(enum VPUNN::ActivationFunction) --> enum VPUNN::intf_01::ActivationFunction", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_01::convert(enum VPUNN::Swizzling) file:vpu/compatibility/types01.h line:187
	M("VPUNN::intf_01").def("convert", (enum VPUNN::intf_01::Swizzling (*)(enum VPUNN::Swizzling)) &VPUNN::intf_01::convert<VPUNN::intf_01::Swizzling,VPUNN::Swizzling>, "C++: VPUNN::intf_01::convert(enum VPUNN::Swizzling) --> enum VPUNN::intf_01::Swizzling", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_20.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <vector> // std::vector
#include <vpu/compatibility/types01.h> // VPUNN::Inserter_Interface01
#include <vpu/compatibility/types01.h> // VPUNN::Preprocessing_Interface01
#include <vpu/compatibility/types01.h> // VPUNN::Preprocessing_Interface10

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface01 file:vpu/compatibility/types01.h line:253
struct PyCallBack_VPUNN_Preprocessing_Interface01_float_t : public VPUNN::Preprocessing_Interface01<float> {
	using VPUNN::Preprocessing_Interface01<float>::Preprocessing_Interface01;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface01<float> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface01<float> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::Preprocessing_Interface10 file:vpu/compatibility/types01.h line:337
struct PyCallBack_VPUNN_Preprocessing_Interface10_float_t : public VPUNN::Preprocessing_Interface10<float> {
	using VPUNN::Preprocessing_Interface10<float>::Preprocessing_Interface10;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface10<float> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface10<float> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_20(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface01 file:vpu/compatibility/types01.h line:227
		pybind11::class_<VPUNN::Inserter_Interface01<float>, std::shared_ptr<VPUNN::Inserter_Interface01<float>>> cl(M("VPUNN"), "Inserter_Interface01_float_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface01<float> const &o){ return new VPUNN::Inserter_Interface01<float>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface01<float>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface01<float>::insert<false>, "C++: VPUNN::Inserter_Interface01<float>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Preprocessing_Interface01 file:vpu/compatibility/types01.h line:253
		pybind11::class_<VPUNN::Preprocessing_Interface01<float>, std::shared_ptr<VPUNN::Preprocessing_Interface01<float>>, PyCallBack_VPUNN_Preprocessing_Interface01_float_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>> cl(M("VPUNN"), "Preprocessing_Interface01_float_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface01<float>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface01_float_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface01_float_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface01_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface01<float> const &o){ return new VPUNN::Preprocessing_Interface01<float>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface01<float>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface01<float>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface01<float>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface01<float> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::Preprocessing_Interface10 file:vpu/compatibility/types01.h line:337
		pybind11::class_<VPUNN::Preprocessing_Interface10<float>, std::shared_ptr<VPUNN::Preprocessing_Interface10<float>>, PyCallBack_VPUNN_Preprocessing_Interface10_float_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>> cl(M("VPUNN"), "Preprocessing_Interface10_float_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface10<float>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface10_float_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface10_float_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface10_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface10<float> const &o){ return new VPUNN::Preprocessing_Interface10<float>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface10<float>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface10<float>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface10<float>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface10<float> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::FilteredFields file: line:27
		pybind11::class_<VPUNN::FilteredFields, std::shared_ptr<VPUNN::FilteredFields>> cl(M("VPUNN"), "FilteredFields", "");
		cl.def( pybind11::init( [](){ return new VPUNN::FilteredFields(); } ) );
		cl.def( pybind11::init( [](VPUNN::FilteredFields const &o){ return new VPUNN::FilteredFields(o); } ) );
		cl.def_readwrite("isi", &VPUNN::FilteredFields::isi);
		cl.def_readwrite("owt", &VPUNN::FilteredFields::owt);
	}
	{ // VPUNN::PassThroughInputAdapter file: line:32
		pybind11::class_<VPUNN::PassThroughInputAdapter, std::shared_ptr<VPUNN::PassThroughInputAdapter>> cl(M("VPUNN"), "PassThroughInputAdapter", "");
		cl.def( pybind11::init( [](){ return new VPUNN::PassThroughInputAdapter(); } ) );
		cl.def_static("mock_replace_datatypes", (enum VPUNN::DataType (*)(const enum VPUNN::DataType)) &VPUNN::PassThroughInputAdapter::mock_replace_datatypes, "C++: VPUNN::PassThroughInputAdapter::mock_replace_datatypes(const enum VPUNN::DataType) --> enum VPUNN::DataType", pybind11::arg("in_datatype"));
		cl.def_static("mock_replace_operations", (enum VPUNN::Operation (*)(const enum VPUNN::Operation)) &VPUNN::PassThroughInputAdapter::mock_replace_operations, "C++: VPUNN::PassThroughInputAdapter::mock_replace_operations(const enum VPUNN::Operation) --> enum VPUNN::Operation", pybind11::arg("in_operation"));
		cl.def_static("mock_replace_devices", (enum VPUNN::VPUDevice (*)(const enum VPUNN::VPUDevice)) &VPUNN::PassThroughInputAdapter::mock_replace_devices, "C++: VPUNN::PassThroughInputAdapter::mock_replace_devices(const enum VPUNN::VPUDevice) --> enum VPUNN::VPUDevice", pybind11::arg("in_device"));
		cl.def_static("avoid_untrained_space", (struct VPUNN::FilteredFields (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::PassThroughInputAdapter::avoid_untrained_space, "C++: VPUNN::PassThroughInputAdapter::avoid_untrained_space(const struct VPUNN::DPUWorkload &) --> struct VPUNN::FilteredFields", pybind11::arg("w"));
		cl.def_static("alternative_input0_spatial_memory", (class VPUNN::VPUTensor (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::PassThroughInputAdapter::alternative_input0_spatial_memory, "C++: VPUNN::PassThroughInputAdapter::alternative_input0_spatial_memory(const struct VPUNN::DPUWorkload &) --> class VPUNN::VPUTensor", pybind11::arg("wl"));
		cl.def_static("establishUniqueSwizzling", (class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling> (*)(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation)) &VPUNN::PassThroughInputAdapter::establishUniqueSwizzling, "Compute one swizzling based on the 3 in/out individual swizzlings\n\nC++: VPUNN::PassThroughInputAdapter::establishUniqueSwizzling(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation) --> class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling>", pybind11::arg("in0"), pybind11::arg("in1"), pybind11::arg("out0"), pybind11::arg(""));
	}
	{ // VPUNN::NN27InputAdapter file: line:63
		pybind11::class_<VPUNN::NN27InputAdapter, std::shared_ptr<VPUNN::NN27InputAdapter>> cl(M("VPUNN"), "NN27InputAdapter", "adapting input to VPU2.7");
		cl.def( pybind11::init( [](){ return new VPUNN::NN27InputAdapter(); } ) );
		cl.def_static("mock_replace_datatypes", (enum VPUNN::DataType (*)(const enum VPUNN::DataType)) &VPUNN::NN27InputAdapter::mock_replace_datatypes, "some datatypes are replaced to supported ones\n\nC++: VPUNN::NN27InputAdapter::mock_replace_datatypes(const enum VPUNN::DataType) --> enum VPUNN::DataType", pybind11::arg("in_datatype"));
		cl.def_static("mock_replace_operations", (enum VPUNN::Operation (*)(const enum VPUNN::Operation)) &VPUNN::NN27InputAdapter::mock_replace_operations, "some operations are replaced to supported ones\n\nC++: VPUNN::NN27InputAdapter::mock_replace_operations(const enum VPUNN::Operation) --> enum VPUNN::Operation", pybind11::arg("in_operation"));
		cl.def_static("mock_replace_devices", (enum VPUNN::VPUDevice (*)(const enum VPUNN::VPUDevice)) &VPUNN::NN27InputAdapter::mock_replace_devices, "some devices are replaced to supported ones\n\nC++: VPUNN::NN27InputAdapter::mock_replace_devices(const enum VPUNN::VPUDevice) --> enum VPUNN::VPUDevice", pybind11::arg("in_device"));
		cl.def_static("avoid_untrained_space", (struct VPUNN::FilteredFields (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::NN27InputAdapter::avoid_untrained_space, "ISI Strategy (up to v11) might not be compatible in any combination. Reasons are rather based on data\n available for training and training over-fitting.\n\n a) CLUSTERING + OWT=2+ : not possible,           :replaced with SOK+OWT=2+ (both do no use input HALO),\n filter with step b) next\n\n b) SOK + ELEMENTWISE   : not possible to profile : replace with CLU+OWT=1  (slightly smaller then real\n due to owt=1),\n\n c) SOH + Kernel vertical is 1: no reason to use it, no input halo necessary: replace  with CLU , ,\n filter with a) next.\n\n d) limit owt to 2! THis is to be done only for NPU2.7 trained NNs. For beyond 2.7 we need a new\n interface, derived of it!\n\n order of calls: c, a, b , d\n\n SOH+OWT>1  was trained. no need to handle\n\nC++: VPUNN::NN27InputAdapter::avoid_untrained_space(const struct VPUNN::DPUWorkload &) --> struct VPUNN::FilteredFields", pybind11::arg("w"));
		cl.def_static("establishUniqueSwizzling", (class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling> (*)(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation)) &VPUNN::NN27InputAdapter::establishUniqueSwizzling, "Compute one swizzling based on the 3 in/out individual swizzlings\n\nC++: VPUNN::NN27InputAdapter::establishUniqueSwizzling(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation) --> class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling>", pybind11::arg("in0"), pybind11::arg("in1"), pybind11::arg("out0"), pybind11::arg("op"));
		cl.def_static("alternative_input0_spatial_memory", (class VPUNN::VPUTensor (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::NN27InputAdapter::alternative_input0_spatial_memory, "C++: VPUNN::NN27InputAdapter::alternative_input0_spatial_memory(const struct VPUNN::DPUWorkload &) --> class VPUNN::VPUTensor", pybind11::arg("wl"));
		cl.def_static("input0_OperationBasedReplace", (class VPUNN::VPUTensor (*)(const struct VPUNN::DPUWorkload &, const class VPUNN::VPUTensor &)) &VPUNN::NN27InputAdapter::input0_OperationBasedReplace, "C++: VPUNN::NN27InputAdapter::input0_OperationBasedReplace(const struct VPUNN::DPUWorkload &, const class VPUNN::VPUTensor &) --> class VPUNN::VPUTensor", pybind11::arg(""), pybind11::arg("input0"));
		cl.def_static("computeActualSpatialMemoryNoHaloTensor", (class VPUNN::VPUTensor (*)(const class VPUNN::VPUTensor &, const class VPUNN::HaloWorkload &)) &VPUNN::NN27InputAdapter::computeActualSpatialMemoryNoHaloTensor, "C++: VPUNN::NN27InputAdapter::computeActualSpatialMemoryNoHaloTensor(const class VPUNN::VPUTensor &, const class VPUNN::HaloWorkload &) --> class VPUNN::VPUTensor", pybind11::arg("origT"), pybind11::arg("halo"));
	}
	{ // VPUNN::NN27_159_InputAdapter file: line:243
		pybind11::class_<VPUNN::NN27_159_InputAdapter, std::shared_ptr<VPUNN::NN27_159_InputAdapter>, VPUNN::NN27InputAdapter> cl(M("VPUNN"), "NN27_159_InputAdapter", "adapting input to VPU2.7  but in compatibility v159 mode");
		cl.def( pybind11::init( [](){ return new VPUNN::NN27_159_InputAdapter(); } ) );
		cl.def_static("avoid_untrained_space", (struct VPUNN::FilteredFields (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::NN27_159_InputAdapter::avoid_untrained_space, "ISI Strategy (up to v11) might not be compatible in any combination. Reasons are rather based on data\n available for training and training over-fitting.\n\n a) CLUSTERING + OWT=2+ : not possible,           :replaced with SOK+OWT=2+ (both do no use input HALO),\n filter with step b) next\n\n b) SOK + ELEMENTWISE   : not possible to profile : replace with CLU+OWT=1  (slightly smaller then real\n due to owt=1),\n\n c) SOH + Kernel vertical is 1: no reason to use it, no input halo necessary: replace  with CLU , ,\n filter with a) next.\n\n d) limit owt to 2! THis is to be done only for NPU2.7 trained NNs. For beyond 2.7 we need a new\n interface, derived of it!\n\n order of calls: c, a, b , d\n\n SOH+OWT>1  was trained. no need to handle\n\nC++: VPUNN::NN27_159_InputAdapter::avoid_untrained_space(const struct VPUNN::DPUWorkload &) --> struct VPUNN::FilteredFields", pybind11::arg("w"));
		cl.def_static("establishUniqueSwizzling", (class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling> (*)(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation)) &VPUNN::NN27_159_InputAdapter::establishUniqueSwizzling, "Compute one swizzling based on the 3 in/out individual swizzlings\n\nC++: VPUNN::NN27_159_InputAdapter::establishUniqueSwizzling(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation) --> class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling>", pybind11::arg("in0"), pybind11::arg("in1"), pybind11::arg("out0"), pybind11::arg("op"));
	}
}


// File: VPUNN_21.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Behaviours file: line:29
struct PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_t : public VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints> {
	using VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::Behaviours;

	const class VPUNN::IOperationDynamicConstraints & get_operation_specific_behaviour(const enum VPUNN::Operation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints> *>(this), "get_operation_specific_behaviour");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IOperationDynamicConstraints &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IOperationDynamicConstraints &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IOperationDynamicConstraints &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IOperationDynamicConstraints &>(std::move(o));
		}
		return Behaviours::get_operation_specific_behaviour(a0);
	}
};

// VPUNN::Behaviours file: line:29
struct PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_t : public VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer> {
	using VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::Behaviours;

	const class VPUNN::IOperationDynamicConstraints & get_operation_specific_behaviour(const enum VPUNN::Operation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer> *>(this), "get_operation_specific_behaviour");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IOperationDynamicConstraints &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IOperationDynamicConstraints &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IOperationDynamicConstraints &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IOperationDynamicConstraints &>(std::move(o));
		}
		return Behaviours::get_operation_specific_behaviour(a0);
	}
};

void bind_VPUNN_21(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::NN40InputAdapter file: line:330
		pybind11::class_<VPUNN::NN40InputAdapter, std::shared_ptr<VPUNN::NN40InputAdapter>> cl(M("VPUNN"), "NN40InputAdapter", "adapting input to NPU40");
		cl.def( pybind11::init( [](){ return new VPUNN::NN40InputAdapter(); } ) );
		cl.def_static("mock_replace_datatypes", (enum VPUNN::DataType (*)(const enum VPUNN::DataType)) &VPUNN::NN40InputAdapter::mock_replace_datatypes, "some datatypes are replaced to supported ones\n\nC++: VPUNN::NN40InputAdapter::mock_replace_datatypes(const enum VPUNN::DataType) --> enum VPUNN::DataType", pybind11::arg("in_datatype"));
		cl.def_static("mock_replace_operations", (enum VPUNN::Operation (*)(const enum VPUNN::Operation)) &VPUNN::NN40InputAdapter::mock_replace_operations, "some operations are replaced to supported ones\n\nC++: VPUNN::NN40InputAdapter::mock_replace_operations(const enum VPUNN::Operation) --> enum VPUNN::Operation", pybind11::arg("in_operation"));
		cl.def_static("alternative_input0_spatial_memory", (class VPUNN::VPUTensor (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::NN40InputAdapter::alternative_input0_spatial_memory, "C++: VPUNN::NN40InputAdapter::alternative_input0_spatial_memory(const struct VPUNN::DPUWorkload &) --> class VPUNN::VPUTensor", pybind11::arg("wl"));
		cl.def_static("input0_OperationBasedReplace", (class VPUNN::VPUTensor (*)(const struct VPUNN::DPUWorkload &, const class VPUNN::VPUTensor &)) &VPUNN::NN40InputAdapter::input0_OperationBasedReplace, "C++: VPUNN::NN40InputAdapter::input0_OperationBasedReplace(const struct VPUNN::DPUWorkload &, const class VPUNN::VPUTensor &) --> class VPUNN::VPUTensor", pybind11::arg(""), pybind11::arg("input0"));
		cl.def_static("mock_replace_devices", (enum VPUNN::VPUDevice (*)(const enum VPUNN::VPUDevice)) &VPUNN::NN40InputAdapter::mock_replace_devices, "some devices are replaced to supported ones\n\nC++: VPUNN::NN40InputAdapter::mock_replace_devices(const enum VPUNN::VPUDevice) --> enum VPUNN::VPUDevice", pybind11::arg("in_device"));
		cl.def_static("avoid_untrained_space", (struct VPUNN::FilteredFields (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::NN40InputAdapter::avoid_untrained_space, "ISI Strategy (up to v11) might not be compatible in any combination. Reasons are rather based on data\n available for training and training over-fitting.\n\n a) CLUSTERING + OWT=2+ : not possible,           :replaced with SOK+OWT=2+ (both do no use input HALO),\n filter with step b) next\n\n b) SOK + ELEMENTWISE   : not possible to profile : replace with CLU+OWT=1  (slightly smaller then real\n due to owt=1),\n\n c) [SOH] :invalid in : replace  with CLU , ,\n filter with a) next.\n\n d) limit owt to 6! Even if NPU40 supports more\n\n order of calls: c, a, b , d\n\nC++: VPUNN::NN40InputAdapter::avoid_untrained_space(const struct VPUNN::DPUWorkload &) --> struct VPUNN::FilteredFields", pybind11::arg("w"));
		cl.def_static("establishUniqueSwizzling", (class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling> (*)(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation)) &VPUNN::NN40InputAdapter::establishUniqueSwizzling, "Compute one swizzling based on the 3 in/out individual swizzlings\n\nC++: VPUNN::NN40InputAdapter::establishUniqueSwizzling(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation) --> class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling>", pybind11::arg("in0"), pybind11::arg("in1"), pybind11::arg("out0"), pybind11::arg("op"));
	}
	{ // VPUNN::NN41InputAdapter file: line:486
		pybind11::class_<VPUNN::NN41InputAdapter, std::shared_ptr<VPUNN::NN41InputAdapter>, VPUNN::NN40InputAdapter> cl(M("VPUNN"), "NN41InputAdapter", "INput adapter for LNL NN, that lets all the swizzlings to pass to NN and to cache.\n  This is needed in order to have in preloaded cache the mixed swizzling information that otherwise are not part of\n  the trained space. disadvantage is that if the preloaded cache does not  hot, the NN prediction is unpredictable");
		cl.def( pybind11::init( [](){ return new VPUNN::NN41InputAdapter(); } ) );
		cl.def_static("establishUniqueSwizzling", (class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling> (*)(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation)) &VPUNN::NN41InputAdapter::establishUniqueSwizzling, "Compute one swizzling based on the 3 in/out individual swizzlings\n\nC++: VPUNN::NN41InputAdapter::establishUniqueSwizzling(const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Swizzling, const enum VPUNN::Operation) --> class std::tuple<enum VPUNN::Swizzling, enum VPUNN::Swizzling, enum VPUNN::Swizzling>", pybind11::arg("in0"), pybind11::arg("in1"), pybind11::arg("out0"), pybind11::arg("op"));
	}
	{ // VPUNN::NN5XInputAdapter file: line:519
		pybind11::class_<VPUNN::NN5XInputAdapter, std::shared_ptr<VPUNN::NN5XInputAdapter>> cl(M("VPUNN"), "NN5XInputAdapter", "adapting input to NPU40");
		cl.def( pybind11::init( [](){ return new VPUNN::NN5XInputAdapter(); } ) );
		cl.def_static("mock_replace_operations", (enum VPUNN::Operation (*)(const enum VPUNN::Operation)) &VPUNN::NN5XInputAdapter::mock_replace_operations, "some operations are replaced to supported ones. \n This might happen also via the types namespace specific mapping. But is better to be controlled also from here\n\nC++: VPUNN::NN5XInputAdapter::mock_replace_operations(const enum VPUNN::Operation) --> enum VPUNN::Operation", pybind11::arg("in_operation"));
		cl.def_static("avoid_untrained_space", (struct VPUNN::FilteredFields (*)(const struct VPUNN::DPUWorkload &)) &VPUNN::NN5XInputAdapter::avoid_untrained_space, "ISI Strategy (up to v11) might not be compatible in any combination. Reasons are rather based on data\n available for training and training over-fitting.\n\n a) CLUSTERING + OWT=2+ : not possible,           :replaced with SOK+OWT=2+ (both do no use input HALO),\n filter with step b) next\n\n b) SOK + ELEMENTWISE   : not possible to profile : replace with CLU+OWT=1  (slightly smaller then real\n due to owt=1),\n\n c) [SOH] :invalid in : replace  with CLU , ,\n filter with a) next.\n\n d) limit owt to 6! Even if NPU40 supports more\n\n order of calls: c, a, b , d\n\nC++: VPUNN::NN5XInputAdapter::avoid_untrained_space(const struct VPUNN::DPUWorkload &) --> struct VPUNN::FilteredFields", pybind11::arg("w"));
	}
	{ // VPUNN::Behaviours file: line:29
		pybind11::class_<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, std::shared_ptr<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>>, PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_t, VPUNN::IContainer_OperationsDynamicBehavior> cl(M("VPUNN"), "Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_t", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_t const &o){ return new PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints> const &o){ return new VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>(); }, [](){ return new PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_t(); } ) );
		cl.def("get_operation_specific_", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::*)(const enum VPUNN::Operation) const) &VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::get_operation_specific_<VPUNN::IOperationDynamicConstraints>, "C++: VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::get_operation_specific_(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("get_operation_specific_behaviour", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::*)(const enum VPUNN::Operation) const) &VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::get_operation_specific_behaviour, "C++: VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>::get_operation_specific_behaviour(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("get_operation_specific_behaviour", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::IContainer_OperationsDynamicBehavior::*)(const enum VPUNN::Operation) const) &VPUNN::IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour, "C++: VPUNN::IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("assign", (class VPUNN::IContainer_OperationsDynamicBehavior & (VPUNN::IContainer_OperationsDynamicBehavior::*)(const class VPUNN::IContainer_OperationsDynamicBehavior &)) &VPUNN::IContainer_OperationsDynamicBehavior::operator=, "C++: VPUNN::IContainer_OperationsDynamicBehavior::operator=(const class VPUNN::IContainer_OperationsDynamicBehavior &) --> class VPUNN::IContainer_OperationsDynamicBehavior &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::Behaviours file: line:29
		pybind11::class_<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>, std::shared_ptr<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>>, PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_t, VPUNN::IContainer_OperationsDynamicBehavior> cl(M("VPUNN"), "Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_t", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_t const &o){ return new PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer> const &o){ return new VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>(); }, [](){ return new PyCallBack_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_t(); } ) );
		cl.def("get_operation_specific_", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::*)(const enum VPUNN::Operation) const) &VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::get_operation_specific_<VPUNN::IOperationDynamicConstraints>, "C++: VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::get_operation_specific_(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("get_operation_specific_behaviour", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::*)(const enum VPUNN::Operation) const) &VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::get_operation_specific_behaviour, "C++: VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>::get_operation_specific_behaviour(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("get_operation_specific_behaviour", (const class VPUNN::IOperationDynamicConstraints & (VPUNN::IContainer_OperationsDynamicBehavior::*)(const enum VPUNN::Operation) const) &VPUNN::IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour, "C++: VPUNN::IContainer_OperationsDynamicBehavior::get_operation_specific_behaviour(const enum VPUNN::Operation) const --> const class VPUNN::IOperationDynamicConstraints &", pybind11::return_value_policy::reference, pybind11::arg("op"));
		cl.def("assign", (class VPUNN::IContainer_OperationsDynamicBehavior & (VPUNN::IContainer_OperationsDynamicBehavior::*)(const class VPUNN::IContainer_OperationsDynamicBehavior &)) &VPUNN::IContainer_OperationsDynamicBehavior::operator=, "C++: VPUNN::IContainer_OperationsDynamicBehavior::operator=(const class VPUNN::IContainer_OperationsDynamicBehavior &) --> class VPUNN::IContainer_OperationsDynamicBehavior &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_22.cpp
#include <memory> // std::allocator
#include <sstream> // __str__
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_22(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Behavior_Device_Mapping file: line:113
		pybind11::class_<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>, std::shared_ptr<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>> cl(M("VPUNN"), "Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_VPUNN_VPU2_0_WorkloadValidValues_VPUNN_VPU2_7_WorkloadValidValues_VPUNN_VPU4_0_WorkloadValidValues_VPUNN_VPU5_0_WorkloadValidValues_t", "");
		cl.def( pybind11::init( [](VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> const &o){ return new VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>(); } ) );
		cl.def("is_supported", (bool (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::is_supported, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::is_supported(enum VPUNN::VPUDevice) const --> bool", pybind11::arg("device"));
		cl.def("get_config", (const class VPUNN::IDeviceValidValues & (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::get_config, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::get_config(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
	}
	{ // VPUNN::Behavior_Device_Mapping file: line:113
		pybind11::class_<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>, std::shared_ptr<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>>> cl(M("VPUNN"), "Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_Layer_VPUNN_DW_CONVOLUTION_Constraints_Layer_VPUNN_CM_CONVOLUTION_Constraints_Layer_VPUNN_ELTWISE_Constraints_Layer_VPUNN_MAXPOOL_Constraints_Layer_VPUNN_LAYERNORM_Constraints_Layer_VPUNN_ELTWISE_MUL_Constraints_Layer_VPUNN_AVGPOOL_Constraints_Layer_VPUNN_VPU2_0_LayerValidValues_VPUNN_VPU2_7_LayerValidValues_VPUNN_VPU4_0_LayerValidValues_VPUNN_VPU5_0_LayerValidValues_t", "");
		cl.def( pybind11::init( [](VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues> const &o){ return new VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>(); } ) );
		cl.def("is_supported", (bool (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>, VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>::is_supported, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>, VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>::is_supported(enum VPUNN::VPUDevice) const --> bool", pybind11::arg("device"));
		cl.def("get_config", (const class VPUNN::IDeviceValidValues & (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>, VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>::get_config, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>, VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>::get_config(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
	}
	{ // VPUNN::Behavior_Device_Mapping file: line:113
		pybind11::class_<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>, std::shared_ptr<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>> cl(M("VPUNN"), "Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_VPUNN_VPU2_0_LayerOnTileValidValues_VPUNN_VPU2_7_LayerOnTileValidValues_VPUNN_VPU4_0_LayerOnTileValidValues_VPUNN_VPU5_0_LayerOnTileValidValues_t", "");
		cl.def( pybind11::init( [](VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> const &o){ return new VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>(); } ) );
		cl.def("is_supported", (bool (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::is_supported, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::is_supported(enum VPUNN::VPUDevice) const --> bool", pybind11::arg("device"));
		cl.def("get_config", (const class VPUNN::IDeviceValidValues & (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::get_config, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::get_config(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
	}
}


// File: VPUNN_23.cpp
#include <functional> // std::equal_to
#include <functional> // std::hash
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <memory> // std::allocator
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <unordered_map> // std::__detail::_Node_const_iterator
#include <unordered_map> // std::__detail::_Node_iterator
#include <unordered_map> // std::unordered_map
#include <utility> // std::pair
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::VPU2_0_WorkloadValidValues file: line:37
struct PyCallBack_VPUNN_VPU2_0_WorkloadValidValues : public VPUNN::VPU2_0_WorkloadValidValues {
	using VPUNN::VPU2_0_WorkloadValidValues::VPU2_0_WorkloadValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IDeviceValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_WorkloadValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU2_0_LayerValidValues file: line:219
struct PyCallBack_VPUNN_VPU2_0_LayerValidValues : public VPUNN::VPU2_0_LayerValidValues {
	using VPUNN::VPU2_0_LayerValidValues::VPU2_0_LayerValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_LayerValidValues::get_output_channels_restriction(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU2_0_LayerValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU2_0_LayerOnTileValidValues file: line:244
struct PyCallBack_VPUNN_VPU2_0_LayerOnTileValidValues : public VPUNN::VPU2_0_LayerOnTileValidValues {
	using VPUNN::VPU2_0_LayerOnTileValidValues::VPU2_0_LayerOnTileValidValues;

	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU2_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU2_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_0_LayerOnTileValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU2_7_WorkloadValidValues file: line:37
struct PyCallBack_VPUNN_VPU2_7_WorkloadValidValues : public VPUNN::VPU2_7_WorkloadValidValues {
	using VPUNN::VPU2_7_WorkloadValidValues::VPU2_7_WorkloadValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IDeviceValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_WorkloadValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU2_7_LayerValidValues file: line:246
struct PyCallBack_VPUNN_VPU2_7_LayerValidValues : public VPUNN::VPU2_7_LayerValidValues {
	using VPUNN::VPU2_7_LayerValidValues::VPU2_7_LayerValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_LayerValidValues::get_output_channels_restriction(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU2_7_LayerValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return VPU2_7_LayerValidValues::get_ISI_Strategy_Range(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_3 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_3 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU2_7_LayerOnTileValidValues file: line:290
struct PyCallBack_VPUNN_VPU2_7_LayerOnTileValidValues : public VPUNN::VPU2_7_LayerOnTileValidValues {
	using VPUNN::VPU2_7_LayerOnTileValidValues::VPU2_7_LayerOnTileValidValues;

	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU2_7_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU2_7_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU2_7_LayerOnTileValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU4_0_WorkloadValidValues file: line:39
struct PyCallBack_VPUNN_VPU4_0_WorkloadValidValues : public VPUNN::VPU4_0_WorkloadValidValues {
	using VPUNN::VPU4_0_WorkloadValidValues::VPU4_0_WorkloadValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IDeviceValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_WorkloadValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU4_0_LayerValidValues file: line:258
struct PyCallBack_VPUNN_VPU4_0_LayerValidValues : public VPUNN::VPU4_0_LayerValidValues {
	using VPUNN::VPU4_0_LayerValidValues::VPU4_0_LayerValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_LayerValidValues::get_output_channels_restriction(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU4_0_LayerValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return VPU4_0_LayerValidValues::get_ISI_Strategy_Range(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_3 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_3 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU4_0_LayerOnTileValidValues file: line:302
struct PyCallBack_VPUNN_VPU4_0_LayerOnTileValidValues : public VPUNN::VPU4_0_LayerOnTileValidValues {
	using VPUNN::VPU4_0_LayerOnTileValidValues::VPU4_0_LayerOnTileValidValues;

	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU4_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU4_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU4_0_LayerOnTileValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

void bind_VPUNN_23(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPU2_0_WorkloadValidValues file: line:37
		pybind11::class_<VPUNN::VPU2_0_WorkloadValidValues, std::shared_ptr<VPUNN::VPU2_0_WorkloadValidValues>, PyCallBack_VPUNN_VPU2_0_WorkloadValidValues, VPUNN::IDeviceValidValues> cl(M("VPUNN"), "VPU2_0_WorkloadValidValues", "specific VPU2.0 configuration possibilities, for workload, not layer");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU2_0_WorkloadValidValues const &o){ return new PyCallBack_VPUNN_VPU2_0_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_0_WorkloadValidValues const &o){ return new VPUNN::VPU2_0_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const int &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_heigth_start_factor_SOH_") );

	}
	{ // VPUNN::VPU2_0_LayerValidValues file: line:219
		pybind11::class_<VPUNN::VPU2_0_LayerValidValues, std::shared_ptr<VPUNN::VPU2_0_LayerValidValues>, PyCallBack_VPUNN_VPU2_0_LayerValidValues, VPUNN::VPU2_0_WorkloadValidValues> cl(M("VPUNN"), "VPU2_0_LayerValidValues", "specific VPU2.0 configuration possibilities, for  layer");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU2_0_LayerValidValues const &o){ return new PyCallBack_VPUNN_VPU2_0_LayerValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_0_LayerValidValues const &o){ return new VPUNN::VPU2_0_LayerValidValues(o); } ) );
		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU2_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_0_LayerValidValues::get_output_channels_restriction, "C++: VPUNN::VPU2_0_LayerValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU2_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_0_LayerValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU2_0_LayerValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
	}
	{ // VPUNN::VPU2_0_LayerOnTileValidValues file: line:244
		pybind11::class_<VPUNN::VPU2_0_LayerOnTileValidValues, std::shared_ptr<VPUNN::VPU2_0_LayerOnTileValidValues>, PyCallBack_VPUNN_VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_0_WorkloadValidValues> cl(M("VPUNN"), "VPU2_0_LayerOnTileValidValues", "specific VPU2.0 configuration possibilities, for  layer already split on tile.\n channels restrictions are less strict vs workload, since a further split is expected");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_cosntraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU2_0_LayerOnTileValidValues const &o){ return new PyCallBack_VPUNN_VPU2_0_LayerOnTileValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_0_LayerOnTileValidValues const &o){ return new VPUNN::VPU2_0_LayerOnTileValidValues(o); } ) );
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU2_0_LayerOnTileValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU2_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
	}
	{ // VPUNN::VPU2_7_WorkloadValidValues file: line:37
		pybind11::class_<VPUNN::VPU2_7_WorkloadValidValues, std::shared_ptr<VPUNN::VPU2_7_WorkloadValidValues>, PyCallBack_VPUNN_VPU2_7_WorkloadValidValues, VPUNN::IDeviceValidValues> cl(M("VPUNN"), "VPU2_7_WorkloadValidValues", "specific VPU 2.7 configuration possibilities for workload, not layer");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU2_7_WorkloadValidValues const &o){ return new PyCallBack_VPUNN_VPU2_7_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_7_WorkloadValidValues const &o){ return new VPUNN::VPU2_7_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const class std::unordered_map<enum VPUNN::Operation, class VPUNN::MultiSmartRanges, struct std::hash<enum VPUNN::Operation>, struct std::equal_to<enum VPUNN::Operation>, class std::allocator<struct std::pair<const enum VPUNN::Operation, class VPUNN::MultiSmartRanges> > > &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_channels_restrictions_") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const int &, const class std::unordered_map<enum VPUNN::Operation, class VPUNN::MultiSmartRanges, struct std::hash<enum VPUNN::Operation>, struct std::equal_to<enum VPUNN::Operation>, class std::allocator<struct std::pair<const enum VPUNN::Operation, class VPUNN::MultiSmartRanges> > > &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_heigth_start_factor_SOH_"), pybind11::arg("input_channels_restrictions_") );

		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU2_7_WorkloadValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_7_WorkloadValidValues::get_output_channels_restriction, "C++: VPUNN::VPU2_7_WorkloadValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg(""));
		cl.def("get_input_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU2_7_WorkloadValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_7_WorkloadValidValues::get_input_channels_restriction, "C++: VPUNN::VPU2_7_WorkloadValidValues::get_input_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("get_batch_restrictions", (class VPUNN::MultiSmartRanges (VPUNN::VPU2_7_WorkloadValidValues::*)() const) &VPUNN::VPU2_7_WorkloadValidValues::get_batch_restrictions, "C++: VPUNN::VPU2_7_WorkloadValidValues::get_batch_restrictions() const --> class VPUNN::MultiSmartRanges");
		cl.def("adapt_device_comaptible_tensor_layout", (enum VPUNN::Layout (VPUNN::VPU2_7_WorkloadValidValues::*)(enum VPUNN::Layout) const) &VPUNN::VPU2_7_WorkloadValidValues::adapt_device_comaptible_tensor_layout, "a SmartRange that contains all possible values,\n from 1 to maxim number accepted => [1, max_limit]\n\nC++: VPUNN::VPU2_7_WorkloadValidValues::adapt_device_comaptible_tensor_layout(enum VPUNN::Layout) const --> enum VPUNN::Layout", pybind11::arg("layout"));
		cl.def("adapt_device_comaptible_swizzling", (enum VPUNN::Swizzling (VPUNN::VPU2_7_WorkloadValidValues::*)(enum VPUNN::Swizzling) const) &VPUNN::VPU2_7_WorkloadValidValues::adapt_device_comaptible_swizzling, "C++: VPUNN::VPU2_7_WorkloadValidValues::adapt_device_comaptible_swizzling(enum VPUNN::Swizzling) const --> enum VPUNN::Swizzling", pybind11::arg("swizz"));
	}
	{ // VPUNN::VPU2_7_LayerValidValues file: line:246
		pybind11::class_<VPUNN::VPU2_7_LayerValidValues, std::shared_ptr<VPUNN::VPU2_7_LayerValidValues>, PyCallBack_VPUNN_VPU2_7_LayerValidValues, VPUNN::VPU2_7_WorkloadValidValues> cl(M("VPUNN"), "VPU2_7_LayerValidValues", "specific VPU 2.7 configuration possibilities for  layer");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU2_7_LayerValidValues const &o){ return new PyCallBack_VPUNN_VPU2_7_LayerValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_7_LayerValidValues const &o){ return new VPUNN::VPU2_7_LayerValidValues(o); } ) );
		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU2_7_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_7_LayerValidValues::get_output_channels_restriction, "C++: VPUNN::VPU2_7_LayerValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU2_7_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_7_LayerValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU2_7_LayerValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
		cl.def("get_ISI_Strategy_Range", (class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > (VPUNN::VPU2_7_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_7_LayerValidValues::get_ISI_Strategy_Range, "C++: VPUNN::VPU2_7_LayerValidValues::get_ISI_Strategy_Range(const struct VPUNN::DPUOperation &) const --> class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >", pybind11::arg("dpu"));
	}
	{ // VPUNN::VPU2_7_LayerOnTileValidValues file: line:290
		pybind11::class_<VPUNN::VPU2_7_LayerOnTileValidValues, std::shared_ptr<VPUNN::VPU2_7_LayerOnTileValidValues>, PyCallBack_VPUNN_VPU2_7_LayerOnTileValidValues, VPUNN::VPU2_7_WorkloadValidValues> cl(M("VPUNN"), "VPU2_7_LayerOnTileValidValues", "specific VPU 2.7 configuration possibilities for  layer already split on tile.\n channels restrictions are less strict vs workload, since a further split is expected");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_cosntraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU2_7_LayerOnTileValidValues const &o){ return new PyCallBack_VPUNN_VPU2_7_LayerOnTileValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_7_LayerOnTileValidValues const &o){ return new VPUNN::VPU2_7_LayerOnTileValidValues(o); } ) );
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU2_7_LayerOnTileValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU2_7_LayerOnTileValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU2_7_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
	}
	{ // VPUNN::VPU4_0_WorkloadValidValues file: line:39
		pybind11::class_<VPUNN::VPU4_0_WorkloadValidValues, std::shared_ptr<VPUNN::VPU4_0_WorkloadValidValues>, PyCallBack_VPUNN_VPU4_0_WorkloadValidValues, VPUNN::IDeviceValidValues> cl(M("VPUNN"), "VPU4_0_WorkloadValidValues", "specific VPU 4.0 configuration possibilities for workload, not layer");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU4_0_WorkloadValidValues const &o){ return new PyCallBack_VPUNN_VPU4_0_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU4_0_WorkloadValidValues const &o){ return new VPUNN::VPU4_0_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const class std::unordered_map<enum VPUNN::Operation, class VPUNN::MultiSmartRanges, struct std::hash<enum VPUNN::Operation>, struct std::equal_to<enum VPUNN::Operation>, class std::allocator<struct std::pair<const enum VPUNN::Operation, class VPUNN::MultiSmartRanges> > > &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_channels_restrictions_") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const int &, const class std::unordered_map<enum VPUNN::Operation, class VPUNN::MultiSmartRanges, struct std::hash<enum VPUNN::Operation>, struct std::equal_to<enum VPUNN::Operation>, class std::allocator<struct std::pair<const enum VPUNN::Operation, class VPUNN::MultiSmartRanges> > > &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_heigth_start_factor_SOH_"), pybind11::arg("input_channels_restrictions_") );

		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU4_0_WorkloadValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU4_0_WorkloadValidValues::get_output_channels_restriction, "C++: VPUNN::VPU4_0_WorkloadValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg(""));
		cl.def("get_input_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU4_0_WorkloadValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU4_0_WorkloadValidValues::get_input_channels_restriction, "C++: VPUNN::VPU4_0_WorkloadValidValues::get_input_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("get_batch_restrictions", (class VPUNN::MultiSmartRanges (VPUNN::VPU4_0_WorkloadValidValues::*)() const) &VPUNN::VPU4_0_WorkloadValidValues::get_batch_restrictions, "C++: VPUNN::VPU4_0_WorkloadValidValues::get_batch_restrictions() const --> class VPUNN::MultiSmartRanges");
		cl.def("adapt_device_comaptible_tensor_layout", (enum VPUNN::Layout (VPUNN::VPU4_0_WorkloadValidValues::*)(enum VPUNN::Layout) const) &VPUNN::VPU4_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout, "a SmartRange that contains all possible values,\n from 1 to maxim number accepted => [1, max_limit]\n\nC++: VPUNN::VPU4_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(enum VPUNN::Layout) const --> enum VPUNN::Layout", pybind11::arg("layout"));
		cl.def("adapt_device_comaptible_swizzling", (enum VPUNN::Swizzling (VPUNN::VPU4_0_WorkloadValidValues::*)(enum VPUNN::Swizzling) const) &VPUNN::VPU4_0_WorkloadValidValues::adapt_device_comaptible_swizzling, "C++: VPUNN::VPU4_0_WorkloadValidValues::adapt_device_comaptible_swizzling(enum VPUNN::Swizzling) const --> enum VPUNN::Swizzling", pybind11::arg("swizz"));
	}
	{ // VPUNN::VPU4_0_LayerValidValues file: line:258
		pybind11::class_<VPUNN::VPU4_0_LayerValidValues, std::shared_ptr<VPUNN::VPU4_0_LayerValidValues>, PyCallBack_VPUNN_VPU4_0_LayerValidValues, VPUNN::VPU4_0_WorkloadValidValues> cl(M("VPUNN"), "VPU4_0_LayerValidValues", "///// LAYER UNSPLIT situation\n \n\n specific VPU 4.0 configuration possibilities for  layer");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU4_0_LayerValidValues const &o){ return new PyCallBack_VPUNN_VPU4_0_LayerValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU4_0_LayerValidValues const &o){ return new VPUNN::VPU4_0_LayerValidValues(o); } ) );
		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU4_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU4_0_LayerValidValues::get_output_channels_restriction, "C++: VPUNN::VPU4_0_LayerValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU4_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU4_0_LayerValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU4_0_LayerValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
		cl.def("get_ISI_Strategy_Range", (class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > (VPUNN::VPU4_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU4_0_LayerValidValues::get_ISI_Strategy_Range, "C++: VPUNN::VPU4_0_LayerValidValues::get_ISI_Strategy_Range(const struct VPUNN::DPUOperation &) const --> class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >", pybind11::arg("dpu"));
	}
	{ // VPUNN::VPU4_0_LayerOnTileValidValues file: line:302
		pybind11::class_<VPUNN::VPU4_0_LayerOnTileValidValues, std::shared_ptr<VPUNN::VPU4_0_LayerOnTileValidValues>, PyCallBack_VPUNN_VPU4_0_LayerOnTileValidValues, VPUNN::VPU4_0_WorkloadValidValues> cl(M("VPUNN"), "VPU4_0_LayerOnTileValidValues", "specific VPU 4.0 configuration possibilities for  layer already split on tile.\n channels restrictions are less strict vs workload, since a further split is expected");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU4_0_LayerOnTileValidValues const &o){ return new PyCallBack_VPUNN_VPU4_0_LayerOnTileValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU4_0_LayerOnTileValidValues const &o){ return new VPUNN::VPU4_0_LayerOnTileValidValues(o); } ) );
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU4_0_LayerOnTileValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU4_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU4_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
	}
}


// File: VPUNN_24.cpp
#include <functional> // std::equal_to
#include <functional> // std::hash
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <memory> // std::allocator
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <unordered_map> // std::__detail::_Node_const_iterator
#include <unordered_map> // std::__detail::_Node_iterator
#include <unordered_map> // std::unordered_map
#include <utility> // std::pair
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::VPU5_0_WorkloadValidValues file: line:39
struct PyCallBack_VPUNN_VPU5_0_WorkloadValidValues : public VPUNN::VPU5_0_WorkloadValidValues {
	using VPUNN::VPU5_0_WorkloadValidValues::VPU5_0_WorkloadValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IDeviceValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_WorkloadValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU5_0_LayerValidValues file: line:330
struct PyCallBack_VPUNN_VPU5_0_LayerValidValues : public VPUNN::VPU5_0_LayerValidValues {
	using VPUNN::VPU5_0_LayerValidValues::VPU5_0_LayerValidValues;

	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_LayerValidValues::get_output_channels_restriction(a0);
	}
	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU5_0_LayerValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return VPU5_0_LayerValidValues::get_ISI_Strategy_Range(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_3 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_3 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

// VPUNN::VPU5_0_LayerOnTileValidValues file: line:381
struct PyCallBack_VPUNN_VPU5_0_LayerOnTileValidValues : public VPUNN::VPU5_0_LayerOnTileValidValues {
	using VPUNN::VPU5_0_LayerOnTileValidValues::VPU5_0_LayerOnTileValidValues;

	bool mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "mustExecuteHWLowLevelChecks");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return VPU5_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(a0);
	}
	class VPUNN::MultiSmartRanges get_output_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_output_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_output_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_input_channels_restriction(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_input_channels_restriction");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_input_channels_restriction(a0);
	}
	class VPUNN::MultiSmartRanges get_batch_restrictions() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_batch_restrictions");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<class VPUNN::MultiSmartRanges>::value) {
				static pybind11::detail::override_caster_t<class VPUNN::MultiSmartRanges> caster;
				return pybind11::detail::cast_ref<class VPUNN::MultiSmartRanges>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class VPUNN::MultiSmartRanges>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::get_batch_restrictions();
	}
	enum VPUNN::Layout adapt_device_comaptible_tensor_layout(enum VPUNN::Layout a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "adapt_device_comaptible_tensor_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Layout>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Layout> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Layout>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Layout>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(a0);
	}
	enum VPUNN::Swizzling adapt_device_comaptible_swizzling(enum VPUNN::Swizzling a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "adapt_device_comaptible_swizzling");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::Swizzling>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::Swizzling> caster;
				return pybind11::detail::cast_ref<enum VPUNN::Swizzling>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::Swizzling>(std::move(o));
		}
		return VPU5_0_WorkloadValidValues::adapt_device_comaptible_swizzling(a0);
	}
	const class VPUNN::IDeviceValidValues::ValidDatatypes & get_valid_datatypes_map(const enum VPUNN::MPEEngine & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_valid_datatypes_map");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceValidValues::ValidDatatypes &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceValidValues::ValidDatatypes &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceValidValues::ValidDatatypes &>(std::move(o));
		}
		return IDeviceValidValues::get_valid_datatypes_map(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_0 get_input_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_input_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IDeviceValidValues::get_input_valid_datatypes(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_1 get_output_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_output_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IDeviceValidValues::get_output_valid_datatypes(a0);
	}
	using _binder_ret_2 = const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &;
	_binder_ret_2 get_weights_valid_datatypes(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_weights_valid_datatypes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_2>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_2> caster;
				return pybind11::detail::cast_ref<_binder_ret_2>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_2>(std::move(o));
		}
		return IDeviceValidValues::get_weights_valid_datatypes(a0);
	}
	using _binder_ret_3 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_3 get_ISI_Strategy_Range(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_ISI_Strategy_Range");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_3>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_3> caster;
				return pybind11::detail::cast_ref<_binder_ret_3>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_3>(std::move(o));
		}
		return IDeviceValidValues::get_ISI_Strategy_Range(a0);
	}
	using _binder_ret_4 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &;
	_binder_ret_4 get_valid_execution_order(const struct VPUNN::DPUOperation & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::VPU5_0_LayerOnTileValidValues *>(this), "get_valid_execution_order");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_4>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_4> caster;
				return pybind11::detail::cast_ref<_binder_ret_4>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_4>(std::move(o));
		}
		return IDeviceValidValues::get_valid_execution_order(a0);
	}
};

void bind_VPUNN_24(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPU5_0_WorkloadValidValues file: line:39
		pybind11::class_<VPUNN::VPU5_0_WorkloadValidValues, std::shared_ptr<VPUNN::VPU5_0_WorkloadValidValues>, PyCallBack_VPUNN_VPU5_0_WorkloadValidValues, VPUNN::IDeviceValidValues> cl(M("VPUNN"), "VPU5_0_WorkloadValidValues", "specific NPU 5.0 configuration possibilities for workload, not layer");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU5_0_WorkloadValidValues const &o){ return new PyCallBack_VPUNN_VPU5_0_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU5_0_WorkloadValidValues const &o){ return new VPUNN::VPU5_0_WorkloadValidValues(o); } ) );
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const class std::unordered_map<enum VPUNN::Operation, class VPUNN::SmartRanges, struct std::hash<enum VPUNN::Operation>, struct std::equal_to<enum VPUNN::Operation>, class std::allocator<struct std::pair<const enum VPUNN::Operation, class VPUNN::SmartRanges> > > &, const class VPUNN::SmartRanges &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_channels_restrictions_"), pybind11::arg("batch_restrictions_") );

		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &, const int &, const class std::unordered_map<enum VPUNN::Operation, class VPUNN::SmartRanges, struct std::hash<enum VPUNN::Operation>, struct std::equal_to<enum VPUNN::Operation>, class std::allocator<struct std::pair<const enum VPUNN::Operation, class VPUNN::SmartRanges> > > &, const class VPUNN::SmartRanges &>(), pybind11::arg("op_dynamic_constraints"), pybind11::arg("input_heigth_start_factor_SOH_"), pybind11::arg("input_channels_restrictions_"), pybind11::arg("batch_restrictions_") );

		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU5_0_WorkloadValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU5_0_WorkloadValidValues::get_output_channels_restriction, "C++: VPUNN::VPU5_0_WorkloadValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("get_input_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU5_0_WorkloadValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU5_0_WorkloadValidValues::get_input_channels_restriction, "C++: VPUNN::VPU5_0_WorkloadValidValues::get_input_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("get_batch_restrictions", (class VPUNN::MultiSmartRanges (VPUNN::VPU5_0_WorkloadValidValues::*)() const) &VPUNN::VPU5_0_WorkloadValidValues::get_batch_restrictions, "C++: VPUNN::VPU5_0_WorkloadValidValues::get_batch_restrictions() const --> class VPUNN::MultiSmartRanges");
		cl.def("adapt_device_comaptible_tensor_layout", (enum VPUNN::Layout (VPUNN::VPU5_0_WorkloadValidValues::*)(enum VPUNN::Layout) const) &VPUNN::VPU5_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout, "C++: VPUNN::VPU5_0_WorkloadValidValues::adapt_device_comaptible_tensor_layout(enum VPUNN::Layout) const --> enum VPUNN::Layout", pybind11::arg("layout"));
		cl.def("adapt_device_comaptible_swizzling", (enum VPUNN::Swizzling (VPUNN::VPU5_0_WorkloadValidValues::*)(enum VPUNN::Swizzling) const) &VPUNN::VPU5_0_WorkloadValidValues::adapt_device_comaptible_swizzling, "C++: VPUNN::VPU5_0_WorkloadValidValues::adapt_device_comaptible_swizzling(enum VPUNN::Swizzling) const --> enum VPUNN::Swizzling", pybind11::arg("swizz"));
	}
	{ // VPUNN::VPU5_0_LayerValidValues file: line:330
		pybind11::class_<VPUNN::VPU5_0_LayerValidValues, std::shared_ptr<VPUNN::VPU5_0_LayerValidValues>, PyCallBack_VPUNN_VPU5_0_LayerValidValues, VPUNN::VPU5_0_WorkloadValidValues> cl(M("VPUNN"), "VPU5_0_LayerValidValues", "///// LAYER UNSPLIT situation\n \n\n specific VPU 4.0 configuration possibilities for  layer");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU5_0_LayerValidValues const &o){ return new PyCallBack_VPUNN_VPU5_0_LayerValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU5_0_LayerValidValues const &o){ return new VPUNN::VPU5_0_LayerValidValues(o); } ) );
		cl.def("get_output_channels_restriction", (class VPUNN::MultiSmartRanges (VPUNN::VPU5_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU5_0_LayerValidValues::get_output_channels_restriction, "C++: VPUNN::VPU5_0_LayerValidValues::get_output_channels_restriction(const struct VPUNN::DPUOperation &) const --> class VPUNN::MultiSmartRanges", pybind11::arg("dpu"));
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU5_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU5_0_LayerValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU5_0_LayerValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
		cl.def("get_ISI_Strategy_Range", (class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > (VPUNN::VPU5_0_LayerValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU5_0_LayerValidValues::get_ISI_Strategy_Range, "C++: VPUNN::VPU5_0_LayerValidValues::get_ISI_Strategy_Range(const struct VPUNN::DPUOperation &) const --> class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >", pybind11::arg("dpu"));
	}
	{ // VPUNN::VPU5_0_LayerOnTileValidValues file: line:381
		pybind11::class_<VPUNN::VPU5_0_LayerOnTileValidValues, std::shared_ptr<VPUNN::VPU5_0_LayerOnTileValidValues>, PyCallBack_VPUNN_VPU5_0_LayerOnTileValidValues, VPUNN::VPU5_0_WorkloadValidValues> cl(M("VPUNN"), "VPU5_0_LayerOnTileValidValues", "specific VPU 5.0 configuration possibilities for  layer already split on tile.\n channels restrictions are less strict vs workload, since a further split is expected");
		cl.def( pybind11::init<const class VPUNN::IContainer_OperationsDynamicBehavior &>(), pybind11::arg("op_dynamic_constraints") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_VPU5_0_LayerOnTileValidValues const &o){ return new PyCallBack_VPUNN_VPU5_0_LayerOnTileValidValues(o); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU5_0_LayerOnTileValidValues const &o){ return new VPUNN::VPU5_0_LayerOnTileValidValues(o); } ) );
		cl.def("mustExecuteHWLowLevelChecks", (bool (VPUNN::VPU5_0_LayerOnTileValidValues::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::VPU5_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks, "C++: VPUNN::VPU5_0_LayerOnTileValidValues::mustExecuteHWLowLevelChecks(const struct VPUNN::DPUOperation &) const --> bool", pybind11::arg(""));
	}
	{ // VPUNN::Checker file: line:26
		pybind11::class_<VPUNN::Checker, std::shared_ptr<VPUNN::Checker>> cl(M("VPUNN"), "Checker", "simple checker mechanism that logs textual info and remembers if a error was recorded.");
		cl.def( pybind11::init( [](VPUNN::Checker const &o){ return new VPUNN::Checker(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::Checker(); } ) );
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const int &, const class std::vector<int, class std::allocator<int> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<int>, "C++: VPUNN::Checker::check_is_in_list(const int &, const class std::vector<int, class std::allocator<int> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::VPUDevice &, const class std::vector<enum VPUNN::VPUDevice, class std::allocator<enum VPUNN::VPUDevice> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::VPUDevice>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::VPUDevice &, const class std::vector<enum VPUNN::VPUDevice, class std::allocator<enum VPUNN::VPUDevice> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::Operation &, const class std::vector<enum VPUNN::Operation, class std::allocator<enum VPUNN::Operation> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::Operation>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::Operation &, const class std::vector<enum VPUNN::Operation, class std::allocator<enum VPUNN::Operation> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::ISIStrategy &, const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::ISIStrategy>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::ISIStrategy &, const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::DataType &, const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::DataType>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::DataType &, const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::Layout &, const class std::vector<enum VPUNN::Layout, class std::allocator<enum VPUNN::Layout> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::Layout>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::Layout &, const class std::vector<enum VPUNN::Layout, class std::allocator<enum VPUNN::Layout> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::Swizzling &, const class std::vector<enum VPUNN::Swizzling, class std::allocator<enum VPUNN::Swizzling> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::Swizzling>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::Swizzling &, const class std::vector<enum VPUNN::Swizzling, class std::allocator<enum VPUNN::Swizzling> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_list", (bool (VPUNN::Checker::*)(const enum VPUNN::ExecutionMode &, const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &, const std::string &)) &VPUNN::Checker::check_is_in_list<VPUNN::ExecutionMode>, "C++: VPUNN::Checker::check_is_in_list(const enum VPUNN::ExecutionMode &, const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("container"), pybind11::arg("what"));
		cl.def("check_is_in_interval", (bool (VPUNN::Checker::*)(const int &, const struct std::pair<int, int> &, const std::string &)) &VPUNN::Checker::check_is_in_interval<int>, "C++: VPUNN::Checker::check_is_in_interval(const int &, const struct std::pair<int, int> &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("interval"), pybind11::arg("what"));
		cl.def("check_is_equal", (bool (VPUNN::Checker::*)(const bool &, const bool &, const std::string)) &VPUNN::Checker::check_is_equal<bool>, "C++: VPUNN::Checker::check_is_equal(const bool &, const bool &, const std::string) --> bool", pybind11::arg("item"), pybind11::arg("right_side"), pybind11::arg("what"));
		cl.def("check_is_equal", (bool (VPUNN::Checker::*)(const float &, const float &, const std::string)) &VPUNN::Checker::check_is_equal<float>, "C++: VPUNN::Checker::check_is_equal(const float &, const float &, const std::string) --> bool", pybind11::arg("item"), pybind11::arg("right_side"), pybind11::arg("what"));
		cl.def_static("set_print_tags", (bool (*)(bool)) &VPUNN::Checker::set_print_tags, "sets a new mode and returns the current mode\n\nC++: VPUNN::Checker::set_print_tags(bool) --> bool", pybind11::arg("new_mode"));
		cl.def("reset", (bool (VPUNN::Checker::*)()) &VPUNN::Checker::reset, "cleans  up the history\n \n\n the state before reset\n\nC++: VPUNN::Checker::reset() --> bool");
		cl.def("is_clean", (bool (VPUNN::Checker::*)() const) &VPUNN::Checker::is_clean, "true if the checker has no error recorded\n\nC++: VPUNN::Checker::is_clean() const --> bool");
		cl.def("add_check_failed", (void (VPUNN::Checker::*)(const std::string &)) &VPUNN::Checker::add_check_failed, "marks the checker with error and ads a textual info\n \n\n the string with information\n\nC++: VPUNN::Checker::add_check_failed(const std::string &) --> void", pybind11::arg("info"));
		cl.def("findings", (std::string (VPUNN::Checker::*)() const) &VPUNN::Checker::findings, "the string containing the textual information that was logged (since reset).\n\nC++: VPUNN::Checker::findings() const --> std::string");
		cl.def("check_is_in_requirements", (bool (VPUNN::Checker::*)(const int, const class VPUNN::MultiSmartRanges &, const std::string &)) &VPUNN::Checker::check_is_in_requirements, "checks if the item respects all the rules of a smart range. If not it will record an error/finding\n\nC++: VPUNN::Checker::check_is_in_requirements(const int, const class VPUNN::MultiSmartRanges &, const std::string &) --> bool", pybind11::arg("item"), pybind11::arg("range"), pybind11::arg("what"));

		{ // VPUNN::Checker::Show file: line:74
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<bool,void>, std::shared_ptr<VPUNN::Checker::Show<bool,void>>> cl(enclosing_class, "Show_bool_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<bool,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const bool &)) &VPUNN::Checker::Show<bool, void>::show_value, "C++: VPUNN::Checker::Show<bool, void>::show_value(const bool &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:74
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<float,void>, std::shared_ptr<VPUNN::Checker::Show<float,void>>> cl(enclosing_class, "Show_float_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<float,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const float &)) &VPUNN::Checker::Show<float, void>::show_value, "C++: VPUNN::Checker::Show<float, void>::show_value(const float &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:74
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<int,void>, std::shared_ptr<VPUNN::Checker::Show<int,void>>> cl(enclosing_class, "Show_int_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<int,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const int &)) &VPUNN::Checker::Show<int, void>::show_value, "C++: VPUNN::Checker::Show<int, void>::show_value(const int &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::ExecutionMode,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::ExecutionMode,void>>> cl(enclosing_class, "Show_VPUNN_ExecutionMode_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::ExecutionMode,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::ExecutionMode &)) &VPUNN::Checker::Show<VPUNN::ExecutionMode, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::ExecutionMode, void>::show_value(const enum VPUNN::ExecutionMode &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::VPUDevice,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::VPUDevice,void>>> cl(enclosing_class, "Show_VPUNN_VPUDevice_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::VPUDevice,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::VPUDevice &)) &VPUNN::Checker::Show<VPUNN::VPUDevice, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::VPUDevice, void>::show_value(const enum VPUNN::VPUDevice &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::Operation,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::Operation,void>>> cl(enclosing_class, "Show_VPUNN_Operation_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::Operation,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::Operation &)) &VPUNN::Checker::Show<VPUNN::Operation, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::Operation, void>::show_value(const enum VPUNN::Operation &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::ISIStrategy,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::ISIStrategy,void>>> cl(enclosing_class, "Show_VPUNN_ISIStrategy_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::ISIStrategy,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::ISIStrategy &)) &VPUNN::Checker::Show<VPUNN::ISIStrategy, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::ISIStrategy, void>::show_value(const enum VPUNN::ISIStrategy &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::DataType,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::DataType,void>>> cl(enclosing_class, "Show_VPUNN_DataType_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::DataType,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::DataType &)) &VPUNN::Checker::Show<VPUNN::DataType, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::DataType, void>::show_value(const enum VPUNN::DataType &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::Layout,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::Layout,void>>> cl(enclosing_class, "Show_VPUNN_Layout_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::Layout,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::Layout &)) &VPUNN::Checker::Show<VPUNN::Layout, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::Layout, void>::show_value(const enum VPUNN::Layout &) --> std::string", pybind11::arg("item"));
		}

		{ // VPUNN::Checker::Show file: line:84
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::Checker::Show<VPUNN::Swizzling,void>, std::shared_ptr<VPUNN::Checker::Show<VPUNN::Swizzling,void>>> cl(enclosing_class, "Show_VPUNN_Swizzling_void_t", "");
			cl.def( pybind11::init( [](){ return new VPUNN::Checker::Show<VPUNN::Swizzling,void>(); } ) );
			cl.def_static("show_value", (std::string (*)(const enum VPUNN::Swizzling &)) &VPUNN::Checker::Show<VPUNN::Swizzling, void>::show_value, "C++: VPUNN::Checker::Show<VPUNN::Swizzling, void>::show_value(const enum VPUNN::Swizzling &) --> std::string", pybind11::arg("item"));
		}

	}
}


// File: VPUNN_25.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <memory> // std::allocator
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IOperationDynamicGenerator file: line:60
struct PyCallBack_VPUNN_IOperationDynamicGenerator : public VPUNN::IOperationDynamicGenerator {
	using VPUNN::IOperationDynamicGenerator::IOperationDynamicGenerator;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicGenerator *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicGenerator::generate_operation_dependent_tensors\"");
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IOperationDynamicGenerator *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicGenerator::generate_sparsity\"");
	}
};

// VPUNN::Base_Constraints file: line:74
struct PyCallBack_VPUNN_Base_Constraints : public VPUNN::Base_Constraints {
	using VPUNN::Base_Constraints::Base_Constraints;

	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::deduce_input_1_shape_and_layout\"");
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::check_input_output_tensor_corelation\"");
	}
};

// VPUNN::GenericConvolution_Constraints file: line:283
struct PyCallBack_VPUNN_GenericConvolution_Constraints : public VPUNN::GenericConvolution_Constraints {
	using VPUNN::GenericConvolution_Constraints::GenericConvolution_Constraints;

	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::generate_sparsity(a0, a1, a2);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::deduce_input_1_shape_and_layout\"");
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicConstraints::check_input_output_tensor_corelation\"");
	}
	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::GenericConvolution_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IOperationDynamicGenerator::generate_operation_dependent_tensors\"");
	}
};

// VPUNN::CONVOLUTION_Constraints file: line:328
struct PyCallBack_VPUNN_CONVOLUTION_Constraints : public VPUNN::CONVOLUTION_Constraints {
	using VPUNN::CONVOLUTION_Constraints::CONVOLUTION_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::DW_CONVOLUTION_Constraints file: line:418
struct PyCallBack_VPUNN_DW_CONVOLUTION_Constraints : public VPUNN::DW_CONVOLUTION_Constraints {
	using VPUNN::DW_CONVOLUTION_Constraints::DW_CONVOLUTION_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return DW_CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return DW_CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return DW_CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::generate_sparsity(a0, a1, a2);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::CM_CONVOLUTION_Constraints file: line:468
struct PyCallBack_VPUNN_CM_CONVOLUTION_Constraints : public VPUNN::CM_CONVOLUTION_Constraints {
	using VPUNN::CM_CONVOLUTION_Constraints::CM_CONVOLUTION_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::input_0_volume(a0);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::generate_sparsity(a0, a1, a2);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::ELTWISE_Constraints file: line:530
struct PyCallBack_VPUNN_ELTWISE_Constraints : public VPUNN::ELTWISE_Constraints {
	using VPUNN::ELTWISE_Constraints::ELTWISE_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ELTWISE_Constraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return ELTWISE_Constraints::filter_output_write_tile_Options(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
};

// VPUNN::MAXPOOL_Constraints file: line:626
struct PyCallBack_VPUNN_MAXPOOL_Constraints : public VPUNN::MAXPOOL_Constraints {
	using VPUNN::MAXPOOL_Constraints::MAXPOOL_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return MAXPOOL_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return MAXPOOL_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return MAXPOOL_Constraints::generate_sparsity(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return MAXPOOL_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
};

// VPUNN::LAYERNORM_Constraints file: line:682
struct PyCallBack_VPUNN_LAYERNORM_Constraints : public VPUNN::LAYERNORM_Constraints {
	using VPUNN::LAYERNORM_Constraints::LAYERNORM_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::ELTWISE_MUL_Constraints file: line:683
struct PyCallBack_VPUNN_ELTWISE_MUL_Constraints : public VPUNN::ELTWISE_MUL_Constraints {
	using VPUNN::ELTWISE_MUL_Constraints::ELTWISE_MUL_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ELTWISE_Constraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return ELTWISE_Constraints::filter_output_write_tile_Options(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
};

void bind_VPUNN_25(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Sampler file: line:20
		pybind11::class_<VPUNN::Sampler, std::shared_ptr<VPUNN::Sampler>> cl(M("VPUNN"), "Sampler", "Generates sample, different distributions, controlled random seed");
		cl.def( pybind11::init( [](){ return new VPUNN::Sampler(); } ) );
		cl.def( pybind11::init<unsigned int>(), pybind11::arg("forced_seed") );

		cl.def( pybind11::init( [](VPUNN::Sampler const &o){ return new VPUNN::Sampler(o); } ) );
		cl.def("sample_list", (enum VPUNN::DataType (VPUNN::Sampler::*)(const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &) const) &VPUNN::Sampler::sample_list<std::vector<VPUNN::DataType, std::allocator<VPUNN::DataType> >>, "C++: VPUNN::Sampler::sample_list(const class std::vector<enum VPUNN::DataType, class std::allocator<enum VPUNN::DataType> > &) const --> enum VPUNN::DataType", pybind11::arg("elements"));
		cl.def("sample_list", (bool (VPUNN::Sampler::*)(const class std::vector<bool, class std::allocator<bool> > &) const) &VPUNN::Sampler::sample_list<std::vector<bool, std::allocator<bool> >>, "C++: VPUNN::Sampler::sample_list(const class std::vector<bool, class std::allocator<bool> > &) const --> bool", pybind11::arg("elements"));
		cl.def("sample_list_decrease_prob", (int (VPUNN::Sampler::*)(const class VPUNN::SmartRanges &) const) &VPUNN::Sampler::sample_list_decrease_prob<VPUNN::SmartRanges>, "C++: VPUNN::Sampler::sample_list_decrease_prob(const class VPUNN::SmartRanges &) const --> int", pybind11::arg("elements"));
		cl.def("sample_list_decrease_prob", (int (VPUNN::Sampler::*)(const class VPUNN::MultiSmartRanges &) const) &VPUNN::Sampler::sample_list_decrease_prob<VPUNN::MultiSmartRanges>, "C++: VPUNN::Sampler::sample_list_decrease_prob(const class VPUNN::MultiSmartRanges &) const --> int", pybind11::arg("elements"));
		cl.def("sample_list_decrease_prob", (int (VPUNN::Sampler::*)(const class std::vector<int, class std::allocator<int> > &) const) &VPUNN::Sampler::sample_list_decrease_prob<std::vector<int, std::allocator<int> >>, "C++: VPUNN::Sampler::sample_list_decrease_prob(const class std::vector<int, class std::allocator<int> > &) const --> int", pybind11::arg("elements"));
		cl.def("get_seed", (unsigned int (VPUNN::Sampler::*)() const) &VPUNN::Sampler::get_seed, "C++: VPUNN::Sampler::get_seed() const --> unsigned int");
		cl.def("sample_continuous_uniform", [](VPUNN::Sampler &o) -> float { return o.sample_continuous_uniform(); }, "");
		cl.def("sample_continuous_uniform", [](VPUNN::Sampler &o, float const & a0) -> float { return o.sample_continuous_uniform(a0); }, "", pybind11::arg("min_interval_closed"));
		cl.def("sample_continuous_uniform", (float (VPUNN::Sampler::*)(float, float)) &VPUNN::Sampler::sample_continuous_uniform, "C++: VPUNN::Sampler::sample_continuous_uniform(float, float) --> float", pybind11::arg("min_interval_closed"), pybind11::arg("max_interval_open"));
	}
	{ // VPUNN::IOperationDynamicGenerator file: line:60
		pybind11::class_<VPUNN::IOperationDynamicGenerator, VPUNN::IOperationDynamicGenerator*, PyCallBack_VPUNN_IOperationDynamicGenerator> cl(M("VPUNN"), "IOperationDynamicGenerator", "");
		cl.def(pybind11::init<PyCallBack_VPUNN_IOperationDynamicGenerator const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IOperationDynamicGenerator(); } ) );
		cl.def("generate_operation_dependent_tensors", (void (VPUNN::IOperationDynamicGenerator::*)(class VPUNN::Sampler &, const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicGenerator::generate_operation_dependent_tensors, "dynamic establishment of output_0 and input_1\n eg input_1 (weights) may depend dynamically on output_0 info (channels)\n\nC++: VPUNN::IOperationDynamicGenerator::generate_operation_dependent_tensors(class VPUNN::Sampler &, const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const --> void", pybind11::arg("sampler"), pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("generate_sparsity", (void (VPUNN::IOperationDynamicGenerator::*)(class VPUNN::Sampler &, const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const) &VPUNN::IOperationDynamicGenerator::generate_sparsity, "fills/generates sparsity values\n\nC++: VPUNN::IOperationDynamicGenerator::generate_sparsity(class VPUNN::Sampler &, const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const --> void", pybind11::arg("sampler"), pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("assign", (class VPUNN::IOperationDynamicGenerator & (VPUNN::IOperationDynamicGenerator::*)(const class VPUNN::IOperationDynamicGenerator &)) &VPUNN::IOperationDynamicGenerator::operator=, "C++: VPUNN::IOperationDynamicGenerator::operator=(const class VPUNN::IOperationDynamicGenerator &) --> class VPUNN::IOperationDynamicGenerator &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::Base_Constraints file: line:74
		pybind11::class_<VPUNN::Base_Constraints, std::shared_ptr<VPUNN::Base_Constraints>, PyCallBack_VPUNN_Base_Constraints, VPUNN::IOperationDynamicConstraints> cl(M("VPUNN"), "Base_Constraints", "");
		cl.def(pybind11::init<PyCallBack_VPUNN_Base_Constraints const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_Base_Constraints(); } ) );
		cl.def("check_sparsity_rules", (bool (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const) &VPUNN::Base_Constraints::check_sparsity_rules, "this specialization checks sparsity is turned off for inputs, any state for output\n\nC++: VPUNN::Base_Constraints::check_sparsity_rules(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const --> bool", pybind11::arg(""), pybind11::arg("dpu"), pybind11::arg("info"));
		cl.def("input_1_volume", (long long (VPUNN::Base_Constraints::*)(const struct VPUNN::TensorInfo &) const) &VPUNN::Base_Constraints::input_1_volume, "weights number of elements. SPecific for some operations\n\nC++: VPUNN::Base_Constraints::input_1_volume(const struct VPUNN::TensorInfo &) const --> long long", pybind11::arg("w"));
		cl.def("input_1_aligned_size_bytes", (long long (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::Base_Constraints::input_1_aligned_size_bytes, "computes the aligned size in bytes for weights\n\nC++: VPUNN::Base_Constraints::input_1_aligned_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("input_1_contiguous_size_bytes", (long long (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::Base_Constraints::input_1_contiguous_size_bytes, "computes the non CMX aligned/contiguous  size in bytes for the weights\n\nC++: VPUNN::Base_Constraints::input_1_contiguous_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("input_0_volume", (long long (VPUNN::Base_Constraints::*)(const struct VPUNN::TensorInfo &) const) &VPUNN::Base_Constraints::input_0_volume, "C++: VPUNN::Base_Constraints::input_0_volume(const struct VPUNN::TensorInfo &) const --> long long", pybind11::arg("w"));
		cl.def("input_0_aligned_size_bytes", (long long (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::Base_Constraints::input_0_aligned_size_bytes, "computes the aligned size in bytes for activators of a workload. the actual memory occupied considering\n SEP or sparsity.\n\nC++: VPUNN::Base_Constraints::input_0_aligned_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("input_0_contiguous_size_bytes", (long long (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::Base_Constraints::input_0_contiguous_size_bytes, "computes the non CMX aligned/contiguous  size in bytes for the activators\n\nC++: VPUNN::Base_Constraints::input_0_contiguous_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("output_0_aligned_size_bytes", (long long (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::Base_Constraints::output_0_aligned_size_bytes, "computes the aligned size in bytes for  output activators of a workload. the actual memory occupied\n considering sparsity.\n\nC++: VPUNN::Base_Constraints::output_0_aligned_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
		cl.def("output_0_contiguous_size_bytes", (long long (VPUNN::Base_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const) &VPUNN::Base_Constraints::output_0_contiguous_size_bytes, "computes the non CMX aligned/contiguous  size in bytes for the output. the actual memory occupied\n considering sparsity map\n\nC++: VPUNN::Base_Constraints::output_0_contiguous_size_bytes(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &) const --> long long", pybind11::arg("config"), pybind11::arg("dpu"));
	}
	{ // VPUNN::GenericConvolution_Constraints file: line:283
		pybind11::class_<VPUNN::GenericConvolution_Constraints, std::shared_ptr<VPUNN::GenericConvolution_Constraints>, PyCallBack_VPUNN_GenericConvolution_Constraints, VPUNN::Base_Constraints, VPUNN::IOperationDynamicGenerator> cl(M("VPUNN"), "GenericConvolution_Constraints", "");
		cl.def(pybind11::init<PyCallBack_VPUNN_GenericConvolution_Constraints const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_GenericConvolution_Constraints(); } ) );
		cl.def("generate_sparsity", (void (VPUNN::GenericConvolution_Constraints::*)(class VPUNN::Sampler &, const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const) &VPUNN::GenericConvolution_Constraints::generate_sparsity, "C++: VPUNN::GenericConvolution_Constraints::generate_sparsity(class VPUNN::Sampler &, const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const --> void", pybind11::arg(""), pybind11::arg(""), pybind11::arg("dpu"));
		cl.def("limit_sparsity", (void (VPUNN::GenericConvolution_Constraints::*)(const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const) &VPUNN::GenericConvolution_Constraints::limit_sparsity, "@ reduces/adjusts sparsity  according to context\n\nC++: VPUNN::GenericConvolution_Constraints::limit_sparsity(const class VPUNN::IDeviceValidValues &, struct VPUNN::DPUOperation &) const --> void", pybind11::arg(""), pybind11::arg("dpu"));
		cl.def("check_sparsity_layer_SOK", (bool (VPUNN::GenericConvolution_Constraints::*)(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const) &VPUNN::GenericConvolution_Constraints::check_sparsity_layer_SOK, "if SOK => channels must be aligned to 32 channels\n rule to be applied to un-tiled layer, before split on tiles\n\nC++: VPUNN::GenericConvolution_Constraints::check_sparsity_layer_SOK(const class VPUNN::IDeviceValidValues &, const struct VPUNN::DPUOperation &, std::string &) const --> bool", pybind11::arg(""), pybind11::arg("dpu"), pybind11::arg("info"));
	}
	{ // VPUNN::CONVOLUTION_Constraints file: line:328
		pybind11::class_<VPUNN::CONVOLUTION_Constraints, std::shared_ptr<VPUNN::CONVOLUTION_Constraints>, PyCallBack_VPUNN_CONVOLUTION_Constraints, VPUNN::GenericConvolution_Constraints> cl(M("VPUNN"), "CONVOLUTION_Constraints", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_CONVOLUTION_Constraints const &o){ return new PyCallBack_VPUNN_CONVOLUTION_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::CONVOLUTION_Constraints const &o){ return new VPUNN::CONVOLUTION_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::CONVOLUTION_Constraints(); }, [](){ return new PyCallBack_VPUNN_CONVOLUTION_Constraints(); } ) );
	}
	{ // VPUNN::DW_CONVOLUTION_Constraints file: line:418
		pybind11::class_<VPUNN::DW_CONVOLUTION_Constraints, std::shared_ptr<VPUNN::DW_CONVOLUTION_Constraints>, PyCallBack_VPUNN_DW_CONVOLUTION_Constraints, VPUNN::GenericConvolution_Constraints> cl(M("VPUNN"), "DW_CONVOLUTION_Constraints", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DW_CONVOLUTION_Constraints(); }, [](){ return new PyCallBack_VPUNN_DW_CONVOLUTION_Constraints(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_DW_CONVOLUTION_Constraints const &o){ return new PyCallBack_VPUNN_DW_CONVOLUTION_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::DW_CONVOLUTION_Constraints const &o){ return new VPUNN::DW_CONVOLUTION_Constraints(o); } ) );
	}
	{ // VPUNN::CM_CONVOLUTION_Constraints file: line:468
		pybind11::class_<VPUNN::CM_CONVOLUTION_Constraints, std::shared_ptr<VPUNN::CM_CONVOLUTION_Constraints>, PyCallBack_VPUNN_CM_CONVOLUTION_Constraints, VPUNN::GenericConvolution_Constraints> cl(M("VPUNN"), "CM_CONVOLUTION_Constraints", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_CM_CONVOLUTION_Constraints const &o){ return new PyCallBack_VPUNN_CM_CONVOLUTION_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::CM_CONVOLUTION_Constraints const &o){ return new VPUNN::CM_CONVOLUTION_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::CM_CONVOLUTION_Constraints(); }, [](){ return new PyCallBack_VPUNN_CM_CONVOLUTION_Constraints(); } ) );
	}
	{ // VPUNN::ELTWISE_Constraints file: line:530
		pybind11::class_<VPUNN::ELTWISE_Constraints, std::shared_ptr<VPUNN::ELTWISE_Constraints>, PyCallBack_VPUNN_ELTWISE_Constraints, VPUNN::Base_Constraints, VPUNN::IOperationDynamicGenerator> cl(M("VPUNN"), "ELTWISE_Constraints", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ELTWISE_Constraints const &o){ return new PyCallBack_VPUNN_ELTWISE_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ELTWISE_Constraints const &o){ return new VPUNN::ELTWISE_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::ELTWISE_Constraints(); }, [](){ return new PyCallBack_VPUNN_ELTWISE_Constraints(); } ) );
	}
	{ // VPUNN::MAXPOOL_Constraints file: line:626
		pybind11::class_<VPUNN::MAXPOOL_Constraints, std::shared_ptr<VPUNN::MAXPOOL_Constraints>, PyCallBack_VPUNN_MAXPOOL_Constraints, VPUNN::Base_Constraints, VPUNN::IOperationDynamicGenerator> cl(M("VPUNN"), "MAXPOOL_Constraints", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_MAXPOOL_Constraints const &o){ return new PyCallBack_VPUNN_MAXPOOL_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::MAXPOOL_Constraints const &o){ return new VPUNN::MAXPOOL_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::MAXPOOL_Constraints(); }, [](){ return new PyCallBack_VPUNN_MAXPOOL_Constraints(); } ) );
	}
	{ // VPUNN::LAYERNORM_Constraints file: line:682
		pybind11::class_<VPUNN::LAYERNORM_Constraints, std::shared_ptr<VPUNN::LAYERNORM_Constraints>, PyCallBack_VPUNN_LAYERNORM_Constraints, VPUNN::CONVOLUTION_Constraints> cl(M("VPUNN"), "LAYERNORM_Constraints", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_LAYERNORM_Constraints const &o){ return new PyCallBack_VPUNN_LAYERNORM_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::LAYERNORM_Constraints const &o){ return new VPUNN::LAYERNORM_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::LAYERNORM_Constraints(); }, [](){ return new PyCallBack_VPUNN_LAYERNORM_Constraints(); } ) );
	}
	{ // VPUNN::ELTWISE_MUL_Constraints file: line:683
		pybind11::class_<VPUNN::ELTWISE_MUL_Constraints, std::shared_ptr<VPUNN::ELTWISE_MUL_Constraints>, PyCallBack_VPUNN_ELTWISE_MUL_Constraints, VPUNN::ELTWISE_Constraints> cl(M("VPUNN"), "ELTWISE_MUL_Constraints", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ELTWISE_MUL_Constraints const &o){ return new PyCallBack_VPUNN_ELTWISE_MUL_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ELTWISE_MUL_Constraints const &o){ return new VPUNN::ELTWISE_MUL_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::ELTWISE_MUL_Constraints(); }, [](){ return new PyCallBack_VPUNN_ELTWISE_MUL_Constraints(); } ) );
	}
}


// File: VPUNN_26.cpp
#include <array> // std::array
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <locale> // std::locale
#include <map> // std::map
#include <memory> // std::allocator
#include <optional> // std::optional
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::AVGPOOL_Constraints file: line:686
struct PyCallBack_VPUNN_AVGPOOL_Constraints : public VPUNN::AVGPOOL_Constraints {
	using VPUNN::AVGPOOL_Constraints::AVGPOOL_Constraints;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return AVGPOOL_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return AVGPOOL_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return AVGPOOL_Constraints::generate_sparsity(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return AVGPOOL_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

void bind_VPUNN_26(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::AVGPOOL_Constraints file: line:686
		pybind11::class_<VPUNN::AVGPOOL_Constraints, std::shared_ptr<VPUNN::AVGPOOL_Constraints>, PyCallBack_VPUNN_AVGPOOL_Constraints, VPUNN::GenericConvolution_Constraints> cl(M("VPUNN"), "AVGPOOL_Constraints", "IS a DW_CONV without weights. BUt we will replace it at the NN descriptor (so some info has to be present)");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_AVGPOOL_Constraints const &o){ return new PyCallBack_VPUNN_AVGPOOL_Constraints(o); } ) );
		cl.def( pybind11::init( [](VPUNN::AVGPOOL_Constraints const &o){ return new VPUNN::AVGPOOL_Constraints(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::AVGPOOL_Constraints(); }, [](){ return new PyCallBack_VPUNN_AVGPOOL_Constraints(); } ) );
	}
	{ // VPUNN::MemorySize file: line:25
		pybind11::class_<VPUNN::MemorySize, std::shared_ptr<VPUNN::MemorySize>> cl(M("VPUNN"), "MemorySize", "size of a DPU tensors in memory");
		cl.def( pybind11::init( [](){ return new VPUNN::MemorySize(); } ) );
		cl.def( pybind11::init( [](VPUNN::MemorySize const &o){ return new VPUNN::MemorySize(o); } ) );
		cl.def_readwrite("cmx", &VPUNN::MemorySize::cmx);
		cl.def_readwrite("input_0", &VPUNN::MemorySize::input_0);
		cl.def_readwrite("input_1", &VPUNN::MemorySize::input_1);
		cl.def_readwrite("output_0", &VPUNN::MemorySize::output_0);
		cl.def_readwrite("inplace_output", &VPUNN::MemorySize::inplace_output);
		cl.def_readwrite("cmx_overhead", &VPUNN::MemorySize::cmx_overhead);
		cl.def_readwrite("ignore_overhead", &VPUNN::MemorySize::ignore_overhead);

		cl.def("__str__", [](VPUNN::MemorySize const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::WorkloadMemorySizeCalculator file: line:49
		pybind11::class_<VPUNN::WorkloadMemorySizeCalculator, std::shared_ptr<VPUNN::WorkloadMemorySizeCalculator>> cl(M("VPUNN"), "WorkloadMemorySizeCalculator", "");
		cl.def( pybind11::init( [](){ return new VPUNN::WorkloadMemorySizeCalculator(); } ) );
		cl.def( pybind11::init( [](VPUNN::WorkloadMemorySizeCalculator const &o){ return new VPUNN::WorkloadMemorySizeCalculator(o); } ) );
		cl.def("set_ignore_cmx_overhead", (void (VPUNN::WorkloadMemorySizeCalculator::*)(bool)) &VPUNN::WorkloadMemorySizeCalculator::set_ignore_cmx_overhead, "changes the state of ignore_cmx_overhead, that controls if overhead is added or not to final memory\n\nC++: VPUNN::WorkloadMemorySizeCalculator::set_ignore_cmx_overhead(bool) --> void", pybind11::arg("new_state"));
		cl.def("compute_memory", (struct VPUNN::MemorySize (VPUNN::WorkloadMemorySizeCalculator::*)(const struct VPUNN::DPUOperation &, const class VPUNN::IDeviceValidValues &) const) &VPUNN::WorkloadMemorySizeCalculator::compute_memory, "cmx memory in bytes , not considering broadcasting\n\n \n is the workload for which the memory to be computed\n \n\n knows device configurations and restrictions\n \n\n memory information.\n\nC++: VPUNN::WorkloadMemorySizeCalculator::compute_memory(const struct VPUNN::DPUOperation &, const class VPUNN::IDeviceValidValues &) const --> struct VPUNN::MemorySize", pybind11::arg("w"), pybind11::arg("config"));
		cl.def("compute_memory", (struct VPUNN::MemorySize (VPUNN::WorkloadMemorySizeCalculator::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::WorkloadMemorySizeCalculator::compute_memory, "cmx memory in bytes for a shave workload\n \n\n is the workload for which the memory to be computed\n\n \n total cmx memory required in bytes\n\nC++: VPUNN::WorkloadMemorySizeCalculator::compute_memory(const class VPUNN::SHAVEWorkload &) const --> struct VPUNN::MemorySize", pybind11::arg("swl"));
	}
	{ // VPUNN::SanityReport file: line:20
		pybind11::class_<VPUNN::SanityReport, std::shared_ptr<VPUNN::SanityReport>> cl(M("VPUNN"), "SanityReport", "Post sanity analysis.");
		cl.def( pybind11::init( [](VPUNN::SanityReport const &o){ return new VPUNN::SanityReport(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::SanityReport(); } ) );
		cl.def_readwrite("info", &VPUNN::SanityReport::info);
		cl.def("is_usable", (bool (VPUNN::SanityReport::*)() const) &VPUNN::SanityReport::is_usable, "is the workload usable for NN run\n\nC++: VPUNN::SanityReport::is_usable() const --> bool");
		cl.def("has_error", (bool (VPUNN::SanityReport::*)() const) &VPUNN::SanityReport::has_error, "C++: VPUNN::SanityReport::has_error() const --> bool");
		cl.def("resetOK", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::resetOK, "C++: VPUNN::SanityReport::resetOK() --> void");
		cl.def("value", (unsigned int (VPUNN::SanityReport::*)() const) &VPUNN::SanityReport::value, "C++: VPUNN::SanityReport::value() const --> unsigned int");
		cl.def("mark_size_too_big", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_size_too_big, "C++: VPUNN::SanityReport::mark_size_too_big() --> void");
		cl.def("mark_unknown_device", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_unknown_device, "C++: VPUNN::SanityReport::mark_unknown_device() --> void");
		cl.def("mark_unknown_operation", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_unknown_operation, "C++: VPUNN::SanityReport::mark_unknown_operation() --> void");
		cl.def("mark_invalid_NN_response", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_invalid_NN_response, "C++: VPUNN::SanityReport::mark_invalid_NN_response() --> void");
		cl.def("mark_invalid_DPU_workload", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_invalid_DPU_workload, "C++: VPUNN::SanityReport::mark_invalid_DPU_workload() --> void");
		cl.def("mark_invalid_SHAVE_workload", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_invalid_SHAVE_workload, "C++: VPUNN::SanityReport::mark_invalid_SHAVE_workload() --> void");
		cl.def("mark_invalid_LayerConfiguration", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_invalid_LayerConfiguration, "C++: VPUNN::SanityReport::mark_invalid_LayerConfiguration() --> void");
		cl.def("mark_split_error", (void (VPUNN::SanityReport::*)()) &VPUNN::SanityReport::mark_split_error, "C++: VPUNN::SanityReport::mark_split_error() --> void");
		cl.def("assign", (struct VPUNN::SanityReport & (VPUNN::SanityReport::*)(const struct VPUNN::SanityReport &)) &VPUNN::SanityReport::operator=, "C++: VPUNN::SanityReport::operator=(const struct VPUNN::SanityReport &) --> struct VPUNN::SanityReport &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ContextualMemoryCalculator file: line:44
		pybind11::class_<VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>, std::shared_ptr<VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>>> cl(M("VPUNN"), "ContextualMemoryCalculator_VPUNN_Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_VPUNN_VPU2_0_WorkloadValidValues_VPUNN_VPU2_7_WorkloadValidValues_VPUNN_VPU4_0_WorkloadValidValues_VPUNN_VPU5_0_WorkloadValidValues_t", "");
		cl.def( pybind11::init( [](VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>> const &o){ return new VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>(o); } ) );
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory(const struct VPUNN::DPUOperation &) const --> struct VPUNN::MemorySize", pybind11::arg("w"));
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory(const struct VPUNN::DPUWorkload &) const --> struct VPUNN::MemorySize", pybind11::arg("wl"));
	}
	{ // VPUNN::ContextualMemoryCalculator file: line:44
		pybind11::class_<VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>, std::shared_ptr<VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>>> cl(M("VPUNN"), "ContextualMemoryCalculator_VPUNN_Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_VPUNN_VPU2_0_LayerOnTileValidValues_VPUNN_VPU2_7_LayerOnTileValidValues_VPUNN_VPU4_0_LayerOnTileValidValues_VPUNN_VPU5_0_LayerOnTileValidValues_t", "");
		cl.def( pybind11::init( [](VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>> const &o){ return new VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>(o); } ) );
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory(const struct VPUNN::DPUOperation &) const --> struct VPUNN::MemorySize", pybind11::arg("w"));
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory(const struct VPUNN::DPUWorkload &) const --> struct VPUNN::MemorySize", pybind11::arg("wl"));
	}
}


// File: VPUNN_27.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_27(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::DPU_ConfigurableOperationValidator file: line:84
		pybind11::class_<VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>, std::shared_ptr<VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>>, VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>, VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>> cl(M("VPUNN"), "DPU_ConfigurableOperationValidator_VPUNN_Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_VPUNN_VPU2_0_WorkloadValidValues_VPUNN_VPU2_7_WorkloadValidValues_VPUNN_VPU4_0_WorkloadValidValues_VPUNN_VPU5_0_WorkloadValidValues_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>(); } ) );
		cl.def( pybind11::init( [](VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>> const &o){ return new VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>(o); } ) );
		cl.def("construct_input_1", (class VPUNN::VPUTensor (VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::construct_input_1, "C++: VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::construct_input_1(const struct VPUNN::DPUWorkload &) const --> class VPUNN::VPUTensor", pybind11::arg("wl"));
		cl.def("check_workload_consistency", (void (VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>::*)(const struct VPUNN::DPUOperation &, const class VPUNN::IDeviceValidValues &, const class VPUNN::IOperationDynamicConstraints &, struct VPUNN::SanityReport &) const) &VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::check_workload_consistency, "C++: VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::check_workload_consistency(const struct VPUNN::DPUOperation &, const class VPUNN::IDeviceValidValues &, const class VPUNN::IOperationDynamicConstraints &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("w"), pybind11::arg("config"), pybind11::arg("operation_behaviour"), pybind11::arg("result"));
		cl.def_static("check_halo", (bool (*)(const struct VPUNN::DPUOperation &, std::string &)) &VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::check_halo, "C++: VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::check_halo(const struct VPUNN::DPUOperation &, std::string &) --> bool", pybind11::arg("dpu"), pybind11::arg("info"));
		cl.def("is_supported", (bool (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::is_supported, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::is_supported(enum VPUNN::VPUDevice) const --> bool", pybind11::arg("device"));
		cl.def("get_config", (const class VPUNN::IDeviceValidValues & (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::get_config, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>::get_config(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory(const struct VPUNN::DPUOperation &) const --> struct VPUNN::MemorySize", pybind11::arg("w"));
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues>>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_WorkloadValidValues, VPUNN::VPU2_7_WorkloadValidValues, VPUNN::VPU4_0_WorkloadValidValues, VPUNN::VPU5_0_WorkloadValidValues> >::compute_wl_memory(const struct VPUNN::DPUWorkload &) const --> struct VPUNN::MemorySize", pybind11::arg("wl"));
	}
	{ // VPUNN::DPU_ConfigurableOperationValidator file: line:84
		pybind11::class_<VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>, std::shared_ptr<VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>>, VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>, VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>> cl(M("VPUNN"), "DPU_ConfigurableOperationValidator_VPUNN_Behavior_Device_Mapping_VPUNN_Behaviours_VPUNN_CONVOLUTION_Constraints_VPUNN_DW_CONVOLUTION_Constraints_VPUNN_CM_CONVOLUTION_Constraints_VPUNN_ELTWISE_Constraints_VPUNN_MAXPOOL_Constraints_VPUNN_LAYERNORM_Constraints_VPUNN_ELTWISE_MUL_Constraints_VPUNN_AVGPOOL_Constraints_VPUNN_VPU2_0_LayerOnTileValidValues_VPUNN_VPU2_7_LayerOnTileValidValues_VPUNN_VPU4_0_LayerOnTileValidValues_VPUNN_VPU5_0_LayerOnTileValidValues_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>(); } ) );
		cl.def( pybind11::init( [](VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>> const &o){ return new VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>(o); } ) );
		cl.def("construct_input_1", (class VPUNN::VPUTensor (VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::construct_input_1, "C++: VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::construct_input_1(const struct VPUNN::DPUWorkload &) const --> class VPUNN::VPUTensor", pybind11::arg("wl"));
		cl.def("check_workload_consistency", (void (VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>::*)(const struct VPUNN::DPUOperation &, const class VPUNN::IDeviceValidValues &, const class VPUNN::IOperationDynamicConstraints &, struct VPUNN::SanityReport &) const) &VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::check_workload_consistency, "C++: VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::check_workload_consistency(const struct VPUNN::DPUOperation &, const class VPUNN::IDeviceValidValues &, const class VPUNN::IOperationDynamicConstraints &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("w"), pybind11::arg("config"), pybind11::arg("operation_behaviour"), pybind11::arg("result"));
		cl.def_static("check_halo", (bool (*)(const struct VPUNN::DPUOperation &, std::string &)) &VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::check_halo, "C++: VPUNN::DPU_ConfigurableOperationValidator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::check_halo(const struct VPUNN::DPUOperation &, std::string &) --> bool", pybind11::arg("dpu"), pybind11::arg("info"));
		cl.def("is_supported", (bool (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::is_supported, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::is_supported(enum VPUNN::VPUDevice) const --> bool", pybind11::arg("device"));
		cl.def("get_config", (const class VPUNN::IDeviceValidValues & (VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>,VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::get_config, "C++: VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>::get_config(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>::*)(const struct VPUNN::DPUOperation &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory(const struct VPUNN::DPUOperation &) const --> struct VPUNN::MemorySize", pybind11::arg("w"));
		cl.def("compute_wl_memory", (struct VPUNN::MemorySize (VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues>>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory, "C++: VPUNN::ContextualMemoryCalculator<VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints, VPUNN::DW_CONVOLUTION_Constraints, VPUNN::CM_CONVOLUTION_Constraints, VPUNN::ELTWISE_Constraints, VPUNN::MAXPOOL_Constraints, VPUNN::LAYERNORM_Constraints, VPUNN::ELTWISE_MUL_Constraints, VPUNN::AVGPOOL_Constraints>, VPUNN::VPU2_0_LayerOnTileValidValues, VPUNN::VPU2_7_LayerOnTileValidValues, VPUNN::VPU4_0_LayerOnTileValidValues, VPUNN::VPU5_0_LayerOnTileValidValues> >::compute_wl_memory(const struct VPUNN::DPUWorkload &) const --> struct VPUNN::MemorySize", pybind11::arg("wl"));
	}
}


// File: VPUNN_28.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ActivationFunction
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::DataType
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ExecutionMode
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ISIStrategy
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Layout
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::MemoryLocation
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Operation
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Swizzling
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::VPUDevice
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::VPUSubsystem
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::convert
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::mapFromText
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::mapToText

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_28(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::VPUDevice>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::Operation>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::DataType>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::Layout>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::ExecutionMode>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::Swizzling>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::mapFromText() file:vpu/compatibility/types11.h line:48
	M("VPUNN::intf_11").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_11::mapFromText<VPUNN::intf_11::ISIStrategy>, "C++: VPUNN::intf_11::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::VPUDevice file:vpu/compatibility/types11.h line:57
	pybind11::enum_<VPUNN::intf_11::VPUDevice>(M("VPUNN::intf_11"), "VPUDevice", "VPU IP generations\n\n ")
		.value("VPU_2_0", VPUNN::intf_11::VPUDevice::VPU_2_0)
		.value("VPU_2_1", VPUNN::intf_11::VPUDevice::VPU_2_1)
		.value("VPU_2_7", VPUNN::intf_11::VPUDevice::VPU_2_7)
		.value("VPU_4_0", VPUNN::intf_11::VPUDevice::VPU_4_0)
		.value("__size", VPUNN::intf_11::VPUDevice::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:61
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::VPUDevice>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::DataType file:vpu/compatibility/types11.h line:69
	pybind11::enum_<VPUNN::intf_11::DataType>(M("VPUNN::intf_11"), "DataType", "Supported Datatypes\n\n ")
		.value("UINT8", VPUNN::intf_11::DataType::UINT8)
		.value("INT8", VPUNN::intf_11::DataType::INT8)
		.value("FLOAT16", VPUNN::intf_11::DataType::FLOAT16)
		.value("BFLOAT16", VPUNN::intf_11::DataType::BFLOAT16)
		.value("__size", VPUNN::intf_11::DataType::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:77
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::DataType>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::Operation file:vpu/compatibility/types11.h line:85
	pybind11::enum_<VPUNN::intf_11::Operation>(M("VPUNN::intf_11"), "Operation", "HW operations\n\n ")
		.value("CONVOLUTION", VPUNN::intf_11::Operation::CONVOLUTION)
		.value("DW_CONVOLUTION", VPUNN::intf_11::Operation::DW_CONVOLUTION)
		.value("ELTWISE", VPUNN::intf_11::Operation::ELTWISE)
		.value("MAXPOOL", VPUNN::intf_11::Operation::MAXPOOL)
		.value("AVEPOOL", VPUNN::intf_11::Operation::AVEPOOL)
		.value("CM_CONVOLUTION", VPUNN::intf_11::Operation::CM_CONVOLUTION)
		.value("__size", VPUNN::intf_11::Operation::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:92
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::Operation>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::ActivationFunction file:vpu/compatibility/types11.h line:99
	pybind11::enum_<VPUNN::intf_11::ActivationFunction>(M("VPUNN::intf_11"), "ActivationFunction", "Supported activation functions\n\n ")
		.value("NONE", VPUNN::intf_11::ActivationFunction::NONE)
		.value("RELU", VPUNN::intf_11::ActivationFunction::RELU)
		.value("LRELU", VPUNN::intf_11::ActivationFunction::LRELU)
		.value("ADD", VPUNN::intf_11::ActivationFunction::ADD)
		.value("SUB", VPUNN::intf_11::ActivationFunction::SUB)
		.value("MULT", VPUNN::intf_11::ActivationFunction::MULT)
		.value("__size", VPUNN::intf_11::ActivationFunction::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:106
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::ActivationFunction>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::Swizzling file:vpu/compatibility/types11.h line:113
	pybind11::enum_<VPUNN::intf_11::Swizzling>(M("VPUNN::intf_11"), "Swizzling", "Swizzling keys\n\n ")
		.value("KEY_0", VPUNN::intf_11::Swizzling::KEY_0)
		.value("KEY_1", VPUNN::intf_11::Swizzling::KEY_1)
		.value("KEY_2", VPUNN::intf_11::Swizzling::KEY_2)
		.value("KEY_3", VPUNN::intf_11::Swizzling::KEY_3)
		.value("KEY_4", VPUNN::intf_11::Swizzling::KEY_4)
		.value("KEY_5", VPUNN::intf_11::Swizzling::KEY_5)
		.value("__size", VPUNN::intf_11::Swizzling::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:119
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::Swizzling>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::ExecutionMode file:vpu/compatibility/types11.h line:127
	pybind11::enum_<VPUNN::intf_11::ExecutionMode>(M("VPUNN::intf_11"), "ExecutionMode", "DPU execution modes\n VECTOR, MATRIX, VECTOR_FP16,are DELETED for VPU2.7\n\n ")
		.value("CUBOID_16x16", VPUNN::intf_11::ExecutionMode::CUBOID_16x16)
		.value("CUBOID_8x16", VPUNN::intf_11::ExecutionMode::CUBOID_8x16)
		.value("CUBOID_4x16", VPUNN::intf_11::ExecutionMode::CUBOID_4x16)
		.value("__size", VPUNN::intf_11::ExecutionMode::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:134
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::ExecutionMode>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::Layout file:vpu/compatibility/types11.h line:148
	pybind11::enum_<VPUNN::intf_11::Layout>(M("VPUNN::intf_11"), "Layout", "Data layout\n\n ZMAJOR and CMAJOR are coming from VPU2.0, were DELETED!\n\n XYZ, XZY, YXZ, YZX, ZXY, ZYX  were introduced for 2.7\n They are to interpreted as from  innermost to outermost dimension of the tensor\n eg: XYZ is NCHW; N=Batch is always outermost, then channels (Z), height (Y), width (X)\n\n ")
		.value("XYZ", VPUNN::intf_11::Layout::XYZ)
		.value("XZY", VPUNN::intf_11::Layout::XZY)
		.value("YXZ", VPUNN::intf_11::Layout::YXZ)
		.value("YZX", VPUNN::intf_11::Layout::YZX)
		.value("ZXY", VPUNN::intf_11::Layout::ZXY)
		.value("ZYX", VPUNN::intf_11::Layout::ZYX)
		.value("INVALID", VPUNN::intf_11::Layout::INVALID)
		.value("__size", VPUNN::intf_11::Layout::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:153
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::Layout>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::ISIStrategy file:vpu/compatibility/types11.h line:158
	pybind11::enum_<VPUNN::intf_11::ISIStrategy>(M("VPUNN::intf_11"), "ISIStrategy", "ISI_Strategy")
		.value("CLUSTERING", VPUNN::intf_11::ISIStrategy::CLUSTERING)
		.value("SPLIT_OVER_H", VPUNN::intf_11::ISIStrategy::SPLIT_OVER_H)
		.value("SPLIT_OVER_K", VPUNN::intf_11::ISIStrategy::SPLIT_OVER_K)
		.value("__size", VPUNN::intf_11::ISIStrategy::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:165
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::ISIStrategy>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::MemoryLocation file:vpu/compatibility/types11.h line:173
	pybind11::enum_<VPUNN::intf_11::MemoryLocation>(M("VPUNN::intf_11"), "MemoryLocation", "Memory locations\n\n ")
		.value("DRAM", VPUNN::intf_11::MemoryLocation::DRAM)
		.value("CMX", VPUNN::intf_11::MemoryLocation::CMX)
		.value("CSRAM", VPUNN::intf_11::MemoryLocation::CSRAM)
		.value("UPA", VPUNN::intf_11::MemoryLocation::UPA)
		.value("__size", VPUNN::intf_11::MemoryLocation::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:181
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::MemoryLocation>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::VPUSubsystem file:vpu/compatibility/types11.h line:189
	pybind11::enum_<VPUNN::intf_11::VPUSubsystem>(M("VPUNN::intf_11"), "VPUSubsystem", "VPU Hw subsystem\n\n ")
		.value("VPU_DPU", VPUNN::intf_11::VPUSubsystem::VPU_DPU)
		.value("VPU_SHV", VPUNN::intf_11::VPUSubsystem::VPU_SHV)
		.value("VPU_DMA", VPUNN::intf_11::VPUSubsystem::VPU_DMA)
		.value("VPU_CPU", VPUNN::intf_11::VPUSubsystem::VPU_CPU)
		.value("VPU_CMX", VPUNN::intf_11::VPUSubsystem::VPU_CMX)
		.value("__size", VPUNN::intf_11::VPUSubsystem::__size);

;

	// VPUNN::intf_11::mapToText() file:vpu/compatibility/types11.h line:196
	M("VPUNN::intf_11").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_11::mapToText<VPUNN::intf_11::VPUSubsystem>, "C++: VPUNN::intf_11::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_11::convert(enum VPUNN::Layout) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::Layout (*)(enum VPUNN::Layout)) &VPUNN::intf_11::convert<VPUNN::intf_11::Layout,VPUNN::Layout>, "C++: VPUNN::intf_11::convert(enum VPUNN::Layout) --> enum VPUNN::intf_11::Layout", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_11::convert(enum VPUNN::ExecutionMode) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::ExecutionMode (*)(enum VPUNN::ExecutionMode)) &VPUNN::intf_11::convert<VPUNN::intf_11::ExecutionMode,VPUNN::ExecutionMode>, "C++: VPUNN::intf_11::convert(enum VPUNN::ExecutionMode) --> enum VPUNN::intf_11::ExecutionMode", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_11::convert(enum VPUNN::VPUDevice) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::VPUDevice (*)(enum VPUNN::VPUDevice)) &VPUNN::intf_11::convert<VPUNN::intf_11::VPUDevice,VPUNN::VPUDevice>, "C++: VPUNN::intf_11::convert(enum VPUNN::VPUDevice) --> enum VPUNN::intf_11::VPUDevice", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_29.cpp
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::DataType
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::ISIStrategy
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Operation
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::Swizzling
#include <vpu/compatibility/types11.h> // VPUNN::intf_11::convert

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_29(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_11::convert(enum VPUNN::Operation) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::Operation (*)(enum VPUNN::Operation)) &VPUNN::intf_11::convert<VPUNN::intf_11::Operation,VPUNN::Operation>, "C++: VPUNN::intf_11::convert(enum VPUNN::Operation) --> enum VPUNN::intf_11::Operation", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_11::convert(enum VPUNN::Swizzling) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::Swizzling (*)(enum VPUNN::Swizzling)) &VPUNN::intf_11::convert<VPUNN::intf_11::Swizzling,VPUNN::Swizzling>, "C++: VPUNN::intf_11::convert(enum VPUNN::Swizzling) --> enum VPUNN::intf_11::Swizzling", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_11::convert(enum VPUNN::ISIStrategy) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::ISIStrategy (*)(enum VPUNN::ISIStrategy)) &VPUNN::intf_11::convert<VPUNN::intf_11::ISIStrategy,VPUNN::ISIStrategy>, "C++: VPUNN::intf_11::convert(enum VPUNN::ISIStrategy) --> enum VPUNN::intf_11::ISIStrategy", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_11::convert(enum VPUNN::DataType) file:vpu/compatibility/types11.h line:208
	M("VPUNN::intf_11").def("convert", (enum VPUNN::intf_11::DataType (*)(enum VPUNN::DataType)) &VPUNN::intf_11::convert<VPUNN::intf_11::DataType,VPUNN::DataType>, "C++: VPUNN::intf_11::convert(enum VPUNN::DataType) --> enum VPUNN::intf_11::DataType", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_30.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <vector> // std::vector
#include <vpu/compatibility/types11.h> // VPUNN::Inserter_Interface11
#include <vpu/compatibility/types11.h> // VPUNN::Preprocessing_Interface11_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
struct PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t : public VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA> {
	using VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA>::Preprocessing_Interface11_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
struct PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t : public VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40> {
	using VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40>::Preprocessing_Interface11_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

// VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
struct PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t : public VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41> {
	using VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41>::Preprocessing_Interface11_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_30(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface11 file:vpu/compatibility/types11.h line:248
		pybind11::class_<VPUNN::Inserter_Interface11<float,VPUNN::NN27InputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface11<float,VPUNN::NN27InputAdapter>>> cl(M("VPUNN"), "Inserter_Interface11_float_VPUNN_NN27InputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface11<float,VPUNN::NN27InputAdapter> const &o){ return new VPUNN::Inserter_Interface11<float,VPUNN::NN27InputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface11<float,VPUNN::NN27InputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface11<float, VPUNN::NN27InputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface11<float, VPUNN::NN27InputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Inserter_Interface11 file:vpu/compatibility/types11.h line:248
		pybind11::class_<VPUNN::Inserter_Interface11<float,VPUNN::NN40InputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface11<float,VPUNN::NN40InputAdapter>>> cl(M("VPUNN"), "Inserter_Interface11_float_VPUNN_NN40InputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface11<float,VPUNN::NN40InputAdapter> const &o){ return new VPUNN::Inserter_Interface11<float,VPUNN::NN40InputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface11<float,VPUNN::NN40InputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface11<float, VPUNN::NN40InputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface11<float, VPUNN::NN40InputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Inserter_Interface11 file:vpu/compatibility/types11.h line:248
		pybind11::class_<VPUNN::Inserter_Interface11<float,VPUNN::NN41InputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface11<float,VPUNN::NN41InputAdapter>>> cl(M("VPUNN"), "Inserter_Interface11_float_VPUNN_NN41InputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface11<float,VPUNN::NN41InputAdapter> const &o){ return new VPUNN::Inserter_Interface11<float,VPUNN::NN41InputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface11<float,VPUNN::NN41InputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface11<float, VPUNN::NN41InputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface11<float, VPUNN::NN41InputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Inserter_Interface11 file:vpu/compatibility/types11.h line:248
		pybind11::class_<VPUNN::Inserter_Interface11<float,VPUNN::NN27_159_InputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface11<float,VPUNN::NN27_159_InputAdapter>>> cl(M("VPUNN"), "Inserter_Interface11_float_VPUNN_NN27_159_InputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface11<float,VPUNN::NN27_159_InputAdapter> const &o){ return new VPUNN::Inserter_Interface11<float,VPUNN::NN27_159_InputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface11<float,VPUNN::NN27_159_InputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface11<float, VPUNN::NN27_159_InputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface11<float, VPUNN::NN27_159_InputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
		pybind11::class_<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA>, std::shared_ptr<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA>>, PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>> cl(M("VPUNN"), "Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27InputAdapter_VPUNN_NNVersions_VERSION_11_VPU27_BETA_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA> const &o){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27InputAdapter,VPUNN::NNVersions::VERSION_11_VPU27_BETA>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27InputAdapter, VPUNN::NNVersions::VERSION_11_VPU27_BETA> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
		pybind11::class_<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40>, std::shared_ptr<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40>>, PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>> cl(M("VPUNN"), "Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN40InputAdapter_VPUNN_NNVersions_VERSION_11_NPU40_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40> const &o){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN40InputAdapter,VPUNN::NNVersions::VERSION_11_NPU40>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN40InputAdapter, VPUNN::NNVersions::VERSION_11_NPU40> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
		pybind11::class_<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41>, std::shared_ptr<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41>>, PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>> cl(M("VPUNN"), "Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN41InputAdapter_VPUNN_NNVersions_VERSION_11_NPU41_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41> const &o){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN41InputAdapter,VPUNN::NNVersions::VERSION_11_NPU41>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN41InputAdapter, VPUNN::NNVersions::VERSION_11_NPU41> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_31.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <vector> // std::vector
#include <vpu/compatibility/types11.h> // VPUNN::Preprocessing_Interface11_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
struct PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t : public VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL> {
	using VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL>::Preprocessing_Interface11_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_31(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Preprocessing_Interface11_Archetype file:vpu/compatibility/types11.h line:298
		pybind11::class_<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL>, std::shared_ptr<VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>, PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>> cl(M("VPUNN"), "Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface11_Archetype_float_VPUNN_NN27_159_InputAdapter_VPUNN_NNVersions_VERSION_11_V89_COMPTBL_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL> const &o){ return new VPUNN::Preprocessing_Interface11_Archetype<float,VPUNN::NN27_159_InputAdapter,VPUNN::NNVersions::VERSION_11_V89_COMPTBL>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface11_Archetype<float, VPUNN::NN27_159_InputAdapter, VPUNN::NNVersions::VERSION_11_V89_COMPTBL> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_32.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::DataType
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::ExecutionMode
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::Layout
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::Operation
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::convert
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::mapFromText
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::mapToLogicalText
#include <vpu/compatibility/types12.h> // VPUNN::intf_12::mapToText

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_32(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_12::mapFromText() file:vpu/compatibility/types12.h line:53
	M("VPUNN::intf_12").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_12::mapFromText<VPUNN::intf_12::Operation>, "C++: VPUNN::intf_12::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapFromText() file:vpu/compatibility/types12.h line:53
	M("VPUNN::intf_12").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_12::mapFromText<VPUNN::intf_12::DataType>, "C++: VPUNN::intf_12::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapFromText() file:vpu/compatibility/types12.h line:53
	M("VPUNN::intf_12").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_12::mapFromText<VPUNN::intf_12::ExecutionMode>, "C++: VPUNN::intf_12::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapFromText() file:vpu/compatibility/types12.h line:53
	M("VPUNN::intf_12").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_12::mapFromText<VPUNN::intf_12::Layout>, "C++: VPUNN::intf_12::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::DataType file:vpu/compatibility/types12.h line:62
	pybind11::enum_<VPUNN::intf_12::DataType>(M("VPUNN::intf_12"), "DataType", "Supported Datatypes in the Descriptor as One hot representation\n\n ")
		.value("UINT8", VPUNN::intf_12::DataType::UINT8)
		.value("FLOAT16", VPUNN::intf_12::DataType::FLOAT16)
		.value("HF8", VPUNN::intf_12::DataType::HF8)
		.value("__size", VPUNN::intf_12::DataType::__size);

;

	// VPUNN::intf_12::mapToText() file:vpu/compatibility/types12.h line:71
	M("VPUNN::intf_12").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_12::mapToText<VPUNN::intf_12::DataType>, "C++: VPUNN::intf_12::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapToLogicalText() file:vpu/compatibility/types12.h line:92
	M("VPUNN::intf_12").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_12::mapToLogicalText<VPUNN::intf_12::DataType>, "C++: VPUNN::intf_12::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::Operation file:vpu/compatibility/types12.h line:100
	pybind11::enum_<VPUNN::intf_12::Operation>(M("VPUNN::intf_12"), "Operation", "HW operations\n\n ")
		.value("CONVOLUTION", VPUNN::intf_12::Operation::CONVOLUTION)
		.value("DW_CONVOLUTION", VPUNN::intf_12::Operation::DW_CONVOLUTION)
		.value("ELTWISE", VPUNN::intf_12::Operation::ELTWISE)
		.value("ELTWISE_MUL", VPUNN::intf_12::Operation::ELTWISE_MUL)
		.value("MAXPOOL", VPUNN::intf_12::Operation::MAXPOOL)
		.value("CM_CONVOLUTION", VPUNN::intf_12::Operation::CM_CONVOLUTION)
		.value("LAYER_NORM", VPUNN::intf_12::Operation::LAYER_NORM)
		.value("__size", VPUNN::intf_12::Operation::__size);

;

	// VPUNN::intf_12::mapToText() file:vpu/compatibility/types12.h line:117
	M("VPUNN::intf_12").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_12::mapToText<VPUNN::intf_12::Operation>, "C++: VPUNN::intf_12::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapToLogicalText() file:vpu/compatibility/types12.h line:131
	M("VPUNN::intf_12").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_12::mapToLogicalText<VPUNN::intf_12::Operation>, "C++: VPUNN::intf_12::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::ExecutionMode file:vpu/compatibility/types12.h line:138
	pybind11::enum_<VPUNN::intf_12::ExecutionMode>(M("VPUNN::intf_12"), "ExecutionMode", "DPU execution modes , see SAS/HAS")
		.value("CUBOID_16x16", VPUNN::intf_12::ExecutionMode::CUBOID_16x16)
		.value("CUBOID_8x16", VPUNN::intf_12::ExecutionMode::CUBOID_8x16)
		.value("CUBOID_4x16", VPUNN::intf_12::ExecutionMode::CUBOID_4x16)
		.value("__size", VPUNN::intf_12::ExecutionMode::__size);

;

	// VPUNN::intf_12::mapToText() file:vpu/compatibility/types12.h line:150
	M("VPUNN::intf_12").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_12::mapToText<VPUNN::intf_12::ExecutionMode>, "C++: VPUNN::intf_12::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapToLogicalText() file:vpu/compatibility/types12.h line:157
	M("VPUNN::intf_12").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_12::mapToLogicalText<VPUNN::intf_12::ExecutionMode>, "C++: VPUNN::intf_12::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::Layout file:vpu/compatibility/types12.h line:178
	pybind11::enum_<VPUNN::intf_12::Layout>(M("VPUNN::intf_12"), "Layout", "Data layout\n\n ZMAJOR and CMAJOR are coming from VPU2.0, legacy layouts\n\n  XYZ, XZY, YXZ, YZX, ZXY, ZYX  were introduced for 2.7\n They are to interpreted as from  innermost(contiguous) to outermost dimension of the tensor\n eg: XYZ  is NCHW;   N=Batch is always outermost,  then channels (Z), height (Y), width (X)\n\n INVALID is first usage is exposure to VPUNN in some cases where Layout does not matter, is neither good Like (for\n input_1 when MAXPOOL).\n\n Equivalence legacy to xyz permutations:\n ZMAJOR is Z,X,Y\n CMAJOR is X,Y,Z\n\n ")
		.value("XYZ", VPUNN::intf_12::Layout::XYZ)
		.value("XZY", VPUNN::intf_12::Layout::XZY)
		.value("YXZ", VPUNN::intf_12::Layout::YXZ)
		.value("YZX", VPUNN::intf_12::Layout::YZX)
		.value("ZXY", VPUNN::intf_12::Layout::ZXY)
		.value("ZYX", VPUNN::intf_12::Layout::ZYX)
		.value("__size", VPUNN::intf_12::Layout::__size);

;

	// VPUNN::intf_12::mapToText() file:vpu/compatibility/types12.h line:182
	M("VPUNN::intf_12").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_12::mapToText<VPUNN::intf_12::Layout>, "C++: VPUNN::intf_12::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::mapToLogicalText() file:vpu/compatibility/types12.h line:190
	M("VPUNN::intf_12").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_12::mapToLogicalText<VPUNN::intf_12::Layout>, "C++: VPUNN::intf_12::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_12::convert(enum VPUNN::DataType) file:vpu/compatibility/types12.h line:200
	M("VPUNN::intf_12").def("convert", (enum VPUNN::intf_12::DataType (*)(enum VPUNN::DataType)) &VPUNN::intf_12::convert<VPUNN::intf_12::DataType,VPUNN::DataType>, "C++: VPUNN::intf_12::convert(enum VPUNN::DataType) --> enum VPUNN::intf_12::DataType", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_12::convert(enum VPUNN::ExecutionMode) file:vpu/compatibility/types12.h line:200
	M("VPUNN::intf_12").def("convert", (enum VPUNN::intf_12::ExecutionMode (*)(enum VPUNN::ExecutionMode)) &VPUNN::intf_12::convert<VPUNN::intf_12::ExecutionMode,VPUNN::ExecutionMode>, "C++: VPUNN::intf_12::convert(enum VPUNN::ExecutionMode) --> enum VPUNN::intf_12::ExecutionMode", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_12::convert(enum VPUNN::Layout) file:vpu/compatibility/types12.h line:200
	M("VPUNN::intf_12").def("convert", (enum VPUNN::intf_12::Layout (*)(enum VPUNN::Layout)) &VPUNN::intf_12::convert<VPUNN::intf_12::Layout,VPUNN::Layout>, "C++: VPUNN::intf_12::convert(enum VPUNN::Layout) --> enum VPUNN::intf_12::Layout", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_12::convert(enum VPUNN::Operation) file:vpu/compatibility/types12.h line:200
	M("VPUNN::intf_12").def("convert", (enum VPUNN::intf_12::Operation (*)(enum VPUNN::Operation)) &VPUNN::intf_12::convert<VPUNN::intf_12::Operation,VPUNN::Operation>, "C++: VPUNN::intf_12::convert(enum VPUNN::Operation) --> enum VPUNN::intf_12::Operation", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_33.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types12.h> // VPUNN::Inserter_Interface12
#include <vpu/compatibility/types12.h> // VPUNN::Preprocessing_Interface12_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface12_Archetype file:vpu/compatibility/types12.h line:288
struct PyCallBack_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t : public VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51> {
	using VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51>::Preprocessing_Interface12_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_33(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface12 file:vpu/compatibility/types12.h line:252
		pybind11::class_<VPUNN::Inserter_Interface12<float,VPUNN::NN5XInputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface12<float,VPUNN::NN5XInputAdapter>>> cl(M("VPUNN"), "Inserter_Interface12_float_VPUNN_NN5XInputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface12<float,VPUNN::NN5XInputAdapter> const &o){ return new VPUNN::Inserter_Interface12<float,VPUNN::NN5XInputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface12<float,VPUNN::NN5XInputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface12<float, VPUNN::NN5XInputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface12<float, VPUNN::NN5XInputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Preprocessing_Interface12_Archetype file:vpu/compatibility/types12.h line:288
		pybind11::class_<VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51>, std::shared_ptr<VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51>>, PyCallBack_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>> cl(M("VPUNN"), "Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface12_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_12_NPU51_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51> const &o){ return new VPUNN::Preprocessing_Interface12_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_12_NPU51>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface12_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_12_NPU51> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_34.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types13.h> // VPUNN::intf_13::DataType
#include <vpu/compatibility/types13.h> // VPUNN::intf_13::convert
#include <vpu/compatibility/types13.h> // VPUNN::intf_13::mapFromText
#include <vpu/compatibility/types13.h> // VPUNN::intf_13::mapToLogicalText
#include <vpu/compatibility/types13.h> // VPUNN::intf_13::mapToText

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_34(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_13::mapFromText() file:vpu/compatibility/types13.h line:56
	M("VPUNN::intf_13").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_13::mapFromText<VPUNN::intf_13::DataType>, "C++: VPUNN::intf_13::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_13::DataType file:vpu/compatibility/types13.h line:65
	pybind11::enum_<VPUNN::intf_13::DataType>(M("VPUNN::intf_13"), "DataType", "Supported Datatypes in the Descriptor as One hot representation\n\n ")
		.value("UINT8", VPUNN::intf_13::DataType::UINT8)
		.value("FLOAT16", VPUNN::intf_13::DataType::FLOAT16)
		.value("HF8", VPUNN::intf_13::DataType::HF8)
		.value("FLOAT32", VPUNN::intf_13::DataType::FLOAT32)
		.value("__size", VPUNN::intf_13::DataType::__size);

;

	// VPUNN::intf_13::mapToText() file:vpu/compatibility/types13.h line:79
	M("VPUNN::intf_13").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_13::mapToText<VPUNN::intf_13::DataType>, "C++: VPUNN::intf_13::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_13::mapToLogicalText() file:vpu/compatibility/types13.h line:100
	M("VPUNN::intf_13").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_13::mapToLogicalText<VPUNN::intf_13::DataType>, "C++: VPUNN::intf_13::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_13::convert(enum VPUNN::DataType) file:vpu/compatibility/types13.h line:110
	M("VPUNN::intf_13").def("convert", (enum VPUNN::intf_13::DataType (*)(enum VPUNN::DataType)) &VPUNN::intf_13::convert<VPUNN::intf_13::DataType,VPUNN::DataType>, "C++: VPUNN::intf_13::convert(enum VPUNN::DataType) --> enum VPUNN::intf_13::DataType", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_35.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types13.h> // VPUNN::Inserter_Interface13
#include <vpu/compatibility/types13.h> // VPUNN::Preprocessing_Interface13_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface13_Archetype file:vpu/compatibility/types13.h line:188
struct PyCallBack_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t : public VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51> {
	using VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51>::Preprocessing_Interface13_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_35(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface13 file:vpu/compatibility/types13.h line:162
		pybind11::class_<VPUNN::Inserter_Interface13<float,VPUNN::NN5XInputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface13<float,VPUNN::NN5XInputAdapter>>> cl(M("VPUNN"), "Inserter_Interface13_float_VPUNN_NN5XInputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface13<float,VPUNN::NN5XInputAdapter> const &o){ return new VPUNN::Inserter_Interface13<float,VPUNN::NN5XInputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface13<float,VPUNN::NN5XInputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface13<float, VPUNN::NN5XInputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface13<float, VPUNN::NN5XInputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Preprocessing_Interface13_Archetype file:vpu/compatibility/types13.h line:188
		pybind11::class_<VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51>, std::shared_ptr<VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51>>, PyCallBack_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>> cl(M("VPUNN"), "Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface13_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_13_NPU51_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51> const &o){ return new VPUNN::Preprocessing_Interface13_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_13_NPU51>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface13_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_13_NPU51> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_36.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types14.h> // VPUNN::intf_14::DataType
#include <vpu/compatibility/types14.h> // VPUNN::intf_14::convert
#include <vpu/compatibility/types14.h> // VPUNN::intf_14::mapFromText
#include <vpu/compatibility/types14.h> // VPUNN::intf_14::mapToLogicalText
#include <vpu/compatibility/types14.h> // VPUNN::intf_14::mapToText

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_36(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_14::mapFromText() file:vpu/compatibility/types14.h line:57
	M("VPUNN::intf_14").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_14::mapFromText<VPUNN::intf_14::DataType>, "C++: VPUNN::intf_14::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_14::DataType file:vpu/compatibility/types14.h line:66
	pybind11::enum_<VPUNN::intf_14::DataType>(M("VPUNN::intf_14"), "DataType", "Supported Datatypes in the Descriptor as One hot representation\n\n ")
		.value("UINT8", VPUNN::intf_14::DataType::UINT8)
		.value("FLOAT16", VPUNN::intf_14::DataType::FLOAT16)
		.value("HF8", VPUNN::intf_14::DataType::HF8)
		.value("FLOAT32", VPUNN::intf_14::DataType::FLOAT32)
		.value("UINT4", VPUNN::intf_14::DataType::UINT4)
		.value("__size", VPUNN::intf_14::DataType::__size);

;

	// VPUNN::intf_14::mapToText() file:vpu/compatibility/types14.h line:82
	M("VPUNN::intf_14").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_14::mapToText<VPUNN::intf_14::DataType>, "C++: VPUNN::intf_14::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_14::mapToLogicalText() file:vpu/compatibility/types14.h line:103
	M("VPUNN::intf_14").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_14::mapToLogicalText<VPUNN::intf_14::DataType>, "C++: VPUNN::intf_14::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_14::convert(enum VPUNN::DataType) file:vpu/compatibility/types14.h line:113
	M("VPUNN::intf_14").def("convert", (enum VPUNN::intf_14::DataType (*)(enum VPUNN::DataType)) &VPUNN::intf_14::convert<VPUNN::intf_14::DataType,VPUNN::DataType>, "C++: VPUNN::intf_14::convert(enum VPUNN::DataType) --> enum VPUNN::intf_14::DataType", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_37.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types14.h> // VPUNN::Inserter_Interface14
#include <vpu/compatibility/types14.h> // VPUNN::Preprocessing_Interface14_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface14_Archetype file:vpu/compatibility/types14.h line:188
struct PyCallBack_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t : public VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51> {
	using VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51>::Preprocessing_Interface14_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_37(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface14 file:vpu/compatibility/types14.h line:161
		pybind11::class_<VPUNN::Inserter_Interface14<float,VPUNN::NN5XInputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface14<float,VPUNN::NN5XInputAdapter>>> cl(M("VPUNN"), "Inserter_Interface14_float_VPUNN_NN5XInputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface14<float,VPUNN::NN5XInputAdapter> const &o){ return new VPUNN::Inserter_Interface14<float,VPUNN::NN5XInputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface14<float,VPUNN::NN5XInputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface14<float, VPUNN::NN5XInputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface14<float, VPUNN::NN5XInputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Preprocessing_Interface14_Archetype file:vpu/compatibility/types14.h line:188
		pybind11::class_<VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51>, std::shared_ptr<VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51>>, PyCallBack_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>> cl(M("VPUNN"), "Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface14_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_14_NPU51_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51> const &o){ return new VPUNN::Preprocessing_Interface14_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_14_NPU51>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface14_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_14_NPU51> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_38.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::DataType
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::ExecutionMode
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::convert
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::mapFromText
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::mapToLogicalText
#include <vpu/compatibility/types15.h> // VPUNN::intf_15::mapToText

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_38(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_15::mapFromText() file:vpu/compatibility/types15.h line:57
	M("VPUNN::intf_15").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_15::mapFromText<VPUNN::intf_15::DataType>, "C++: VPUNN::intf_15::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_15::mapFromText() file:vpu/compatibility/types15.h line:57
	M("VPUNN::intf_15").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_15::mapFromText<VPUNN::intf_15::ExecutionMode>, "C++: VPUNN::intf_15::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_15::DataType file:vpu/compatibility/types15.h line:66
	pybind11::enum_<VPUNN::intf_15::DataType>(M("VPUNN::intf_15"), "DataType", "Supported Datatypes in the Descriptor as One hot representation\n\n ")
		.value("UINT8", VPUNN::intf_15::DataType::UINT8)
		.value("FLOAT16", VPUNN::intf_15::DataType::FLOAT16)
		.value("HF8", VPUNN::intf_15::DataType::HF8)
		.value("FLOAT32", VPUNN::intf_15::DataType::FLOAT32)
		.value("UINT4", VPUNN::intf_15::DataType::UINT4)
		.value("__size", VPUNN::intf_15::DataType::__size);

;

	// VPUNN::intf_15::mapToText() file:vpu/compatibility/types15.h line:84
	M("VPUNN::intf_15").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_15::mapToText<VPUNN::intf_15::DataType>, "C++: VPUNN::intf_15::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_15::mapToLogicalText() file:vpu/compatibility/types15.h line:107
	M("VPUNN::intf_15").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_15::mapToLogicalText<VPUNN::intf_15::DataType>, "C++: VPUNN::intf_15::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_15::ExecutionMode file:vpu/compatibility/types15.h line:114
	pybind11::enum_<VPUNN::intf_15::ExecutionMode>(M("VPUNN::intf_15"), "ExecutionMode", "DPU execution modes , see SAS/HAS")
		.value("CUBOID_16x16", VPUNN::intf_15::ExecutionMode::CUBOID_16x16)
		.value("CUBOID_8x16", VPUNN::intf_15::ExecutionMode::CUBOID_8x16)
		.value("CUBOID_4x16", VPUNN::intf_15::ExecutionMode::CUBOID_4x16)
		.value("__size", VPUNN::intf_15::ExecutionMode::__size);

;

	// VPUNN::intf_15::mapToText() file:vpu/compatibility/types15.h line:129
	M("VPUNN::intf_15").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_15::mapToText<VPUNN::intf_15::ExecutionMode>, "C++: VPUNN::intf_15::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_15::mapToLogicalText() file:vpu/compatibility/types15.h line:137
	M("VPUNN::intf_15").def("mapToLogicalText", (const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > & (*)()) &VPUNN::intf_15::mapToLogicalText<VPUNN::intf_15::ExecutionMode>, "C++: VPUNN::intf_15::mapToLogicalText() --> const class std::map<const std::string, const std::string, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_15::convert(enum VPUNN::DataType) file:vpu/compatibility/types15.h line:147
	M("VPUNN::intf_15").def("convert", (enum VPUNN::intf_15::DataType (*)(enum VPUNN::DataType)) &VPUNN::intf_15::convert<VPUNN::intf_15::DataType,VPUNN::DataType>, "C++: VPUNN::intf_15::convert(enum VPUNN::DataType) --> enum VPUNN::intf_15::DataType", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_15::convert(enum VPUNN::ExecutionMode) file:vpu/compatibility/types15.h line:147
	M("VPUNN::intf_15").def("convert", (enum VPUNN::intf_15::ExecutionMode (*)(enum VPUNN::ExecutionMode)) &VPUNN::intf_15::convert<VPUNN::intf_15::ExecutionMode,VPUNN::ExecutionMode>, "C++: VPUNN::intf_15::convert(enum VPUNN::ExecutionMode) --> enum VPUNN::intf_15::ExecutionMode", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_39.cpp
#include <array> // std::array
#include <chrono> // std::chrono::_V2::system_clock
#include <chrono> // std::chrono::duration
#include <chrono> // std::chrono::time_point
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <ratio> // std::ratio
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector
#include <vpu/compatibility/types15.h> // VPUNN::Inserter_Interface15
#include <vpu/compatibility/types15.h> // VPUNN::Preprocessing_Interface15_Archetype

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface15_Archetype file:vpu/compatibility/types15.h line:222
struct PyCallBack_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t : public VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> {
	using VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>::Preprocessing_Interface15_Archetype;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserter::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DPUWorkload & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserter::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_39(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface15 file:vpu/compatibility/types15.h line:195
		pybind11::class_<VPUNN::Inserter_Interface15<float,VPUNN::NN5XInputAdapter>, std::shared_ptr<VPUNN::Inserter_Interface15<float,VPUNN::NN5XInputAdapter>>> cl(M("VPUNN"), "Inserter_Interface15_float_VPUNN_NN5XInputAdapter_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface15<float,VPUNN::NN5XInputAdapter> const &o){ return new VPUNN::Inserter_Interface15<float,VPUNN::NN5XInputAdapter>(o); } ) );
		cl.def("insert", (unsigned long (VPUNN::Inserter_Interface15<float,VPUNN::NN5XInputAdapter>::*)(const class VPUNN::VPUTensor &, unsigned long)) &VPUNN::Inserter_Interface15<float, VPUNN::NN5XInputAdapter>::insert<false>, "C++: VPUNN::Inserter_Interface15<float, VPUNN::NN5XInputAdapter>::insert(const class VPUNN::VPUTensor &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::Preprocessing_Interface15_Archetype file:vpu/compatibility/types15.h line:222
		pybind11::class_<VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>, std::shared_ptr<VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>, PyCallBack_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t, VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>> cl(M("VPUNN"), "Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface15_Archetype_float_VPUNN_NN5XInputAdapter_VPUNN_NNVersions_VERSION_15_NPU_RESERVED_11_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> const &o){ return new VPUNN::Preprocessing_Interface15_Archetype<float,VPUNN::NN5XInputAdapter,VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>> const &o, const struct VPUNN::DPUWorkload & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>::*)() const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::interface_version, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserter<float,VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11>>::*)(const struct VPUNN::DPUWorkload &, unsigned long &) const) &VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::generate_descriptor, "C++: VPUNN::PreprocessingInserter<float, VPUNN::Preprocessing_Interface15_Archetype<float, VPUNN::NN5XInputAdapter, VPUNN::NNVersions::VERSION_15_NPU_RESERVED_11> >::generate_descriptor(const struct VPUNN::DPUWorkload &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::interface_version, "C++: VPUNN::Preprocessing<float>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::Preprocessing<float>::*)() const) &VPUNN::Preprocessing<float>::output_size, "C++: VPUNN::Preprocessing<float>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::Preprocessing<float>::transformSingle, "C++: VPUNN::Preprocessing<float>::transformSingle(const struct VPUNN::DPUWorkload &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::Preprocessing<float> const &o, const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::Preprocessing<float>::*)(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const) &VPUNN::Preprocessing<float>::transformBatch, "C++: VPUNN::Preprocessing<float>::transformBatch(const class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	// VPUNN::tick() file: line:22
	M("VPUNN").def("tick", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > (*)()) &VPUNN::tick, "Get the current timestamp\n\n \n auto\n\nC++: VPUNN::tick() --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >");

	// VPUNN::no_tick() file: line:25
	M("VPUNN").def("no_tick", (struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > > (*)()) &VPUNN::no_tick, "C++: VPUNN::no_tick() --> struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >");

	// VPUNN::tock(struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >) file: line:35
	M("VPUNN").def("tock", (double (*)(struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >)) &VPUNN::tock, "Get the current timestamp and return the elapsed time with the previous timestamp\n\n \n the previous timestamp\n \n\n double the elapsed time in millisecond\n\nC++: VPUNN::tock(struct std::chrono::time_point<struct std::chrono::_V2::system_clock, struct std::chrono::duration<long, struct std::ratio<1, 1000000000> > >) --> double", pybind11::arg("t1"));

	{ // VPUNN::Tensor file: line:31
		pybind11::class_<VPUNN::Tensor<float>, std::shared_ptr<VPUNN::Tensor<float>>> cl(M("VPUNN"), "Tensor_float_t", "");
		cl.def( pybind11::init<const class std::vector<unsigned int, class std::allocator<unsigned int> > &>(), pybind11::arg("dimensions") );

		cl.def( pybind11::init<float *, const class std::vector<unsigned int, class std::allocator<unsigned int> > &>(), pybind11::arg("data"), pybind11::arg("dimensions") );

		cl.def( pybind11::init<const class std::vector<unsigned int, class std::allocator<unsigned int> > &, float>(), pybind11::arg("dimensions"), pybind11::arg("value") );

		cl.def( pybind11::init( [](VPUNN::Tensor<float> const &o){ return new VPUNN::Tensor<float>(o); } ) );
		cl.def("assign", (class VPUNN::Tensor<float> & (VPUNN::Tensor<float>::*)(const class VPUNN::Tensor<float> &)) &VPUNN::Tensor<float>::operator=, "C++: VPUNN::Tensor<float>::operator=(const class VPUNN::Tensor<float> &) --> class VPUNN::Tensor<float> &", pybind11::return_value_policy::reference, pybind11::arg("tensor"));
		cl.def("data", (float * (VPUNN::Tensor<float>::*)()) &VPUNN::Tensor<float>::data, "C++: VPUNN::Tensor<float>::data() --> float *", pybind11::return_value_policy::automatic_reference);
		cl.def("data_vector", (class std::vector<float, class std::allocator<float> > (VPUNN::Tensor<float>::*)() const) &VPUNN::Tensor<float>::data_vector, "C++: VPUNN::Tensor<float>::data_vector() const --> class std::vector<float, class std::allocator<float> >");
		cl.def("c_ptr", (const float * (VPUNN::Tensor<float>::*)() const) &VPUNN::Tensor<float>::c_ptr, "C++: VPUNN::Tensor<float>::c_ptr() const --> const float *", pybind11::return_value_policy::automatic_reference);
		cl.def("assign", (class VPUNN::Tensor<float> & (VPUNN::Tensor<float>::*)(const float *, const unsigned int)) &VPUNN::Tensor<float>::assign, "C++: VPUNN::Tensor<float>::assign(const float *, const unsigned int) --> class VPUNN::Tensor<float> &", pybind11::return_value_policy::reference, pybind11::arg("data"), pybind11::arg("size_in_bytes"));
		cl.def("__getitem__", (float & (VPUNN::Tensor<float>::*)(const int)) &VPUNN::Tensor<float>::operator[], "C++: VPUNN::Tensor<float>::operator[](const int) --> float &", pybind11::return_value_policy::reference, pybind11::arg("idx"));
		cl.def("size", (int (VPUNN::Tensor<float>::*)() const) &VPUNN::Tensor<float>::size, "C++: VPUNN::Tensor<float>::size() const --> int");
		cl.def("shape", (const class std::vector<unsigned int, class std::allocator<unsigned int> > & (VPUNN::Tensor<float>::*)() const) &VPUNN::Tensor<float>::shape, "C++: VPUNN::Tensor<float>::shape() const --> const class std::vector<unsigned int, class std::allocator<unsigned int> > &", pybind11::return_value_policy::reference);
		cl.def("fill", (class VPUNN::Tensor<float> & (VPUNN::Tensor<float>::*)(float)) &VPUNN::Tensor<float>::fill, "C++: VPUNN::Tensor<float>::fill(float) --> class VPUNN::Tensor<float> &", pybind11::return_value_policy::reference, pybind11::arg("value"));

		cl.def("__str__", [](VPUNN::Tensor<float> const &o) -> std::string { std::ostringstream s; operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::BiasOpBuffer file: line:18
		pybind11::class_<VPUNN::BiasOpBuffer, std::shared_ptr<VPUNN::BiasOpBuffer>> cl(M("VPUNN"), "BiasOpBuffer", "Floating point bias layer (float). The instance has a helper memory for the constant buffer");
		cl.def( pybind11::init( [](VPUNN::BiasOpBuffer const &o){ return new VPUNN::BiasOpBuffer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::BiasOpBuffer(); } ) );
		cl.def("reserve_bias_space", [](VPUNN::BiasOpBuffer &o, int const & a0) -> void { return o.reserve_bias_space(a0); }, "", pybind11::arg("space_required"));
		cl.def("reserve_bias_space", (void (VPUNN::BiasOpBuffer::*)(int, float)) &VPUNN::BiasOpBuffer::reserve_bias_space, "ensures a minimim allocated space for the constant bias buffer\n\nC++: VPUNN::BiasOpBuffer::reserve_bias_space(int, float) --> void", pybind11::arg("space_required"), pybind11::arg("fill_value"));
	}
	{ // VPUNN::BiasOp file: line:33
		pybind11::class_<VPUNN::BiasOp, std::shared_ptr<VPUNN::BiasOp>> cl(M("VPUNN"), "BiasOp", "Floating point bias layer (float). The instance has a helper memory for the constant buffer");
		cl.def( pybind11::init( [](){ return new VPUNN::BiasOp(); } ) );
		cl.def_static("Bias", (void (*)(const class VPUNN::Tensor<float> *, class VPUNN::Tensor<float> *, class VPUNN::BiasOpBuffer &)) &VPUNN::BiasOp::Bias, "Floating point bias layer (float). The operation is done implace in the output tensor\n\n \n a VPUNN::Tensor containing the bias\n \n\n the input/output tensor\n\nC++: VPUNN::BiasOp::Bias(const class VPUNN::Tensor<float> *, class VPUNN::Tensor<float> *, class VPUNN::BiasOpBuffer &) --> void", pybind11::arg("bias"), pybind11::arg("output"), pybind11::arg("batch_buff"));
	}
}


// File: VPUNN_40.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_40(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::InferenceExecutionData file: line:32
		pybind11::class_<VPUNN::InferenceExecutionData, std::shared_ptr<VPUNN::InferenceExecutionData>> cl(M("VPUNN"), "InferenceExecutionData", "holds the RW memory that reflects INference model and is used to execute the Model on it.");
		cl.def("set_inputs", (void (VPUNN::InferenceExecutionData::*)(const float *, const unsigned int)) &VPUNN::InferenceExecutionData::set_inputs<float>, "C++: VPUNN::InferenceExecutionData::set_inputs(const float *, const unsigned int) --> void", pybind11::arg("inputs"), pybind11::arg("size"));
		cl.def("get_outputs", (const float * (VPUNN::InferenceExecutionData::*)() const) &VPUNN::InferenceExecutionData::get_outputs<float>, "C++: VPUNN::InferenceExecutionData::get_outputs() const --> const float *", pybind11::return_value_policy::automatic_reference);
		cl.def("get_outputs_copy_as_vector", (const class std::vector<float, class std::allocator<float> > (VPUNN::InferenceExecutionData::*)() const) &VPUNN::InferenceExecutionData::get_outputs_copy_as_vector<float>, "C++: VPUNN::InferenceExecutionData::get_outputs_copy_as_vector() const --> const class std::vector<float, class std::allocator<float> >");
		cl.def("input_shapes", (class std::vector<class std::vector<unsigned int, class std::allocator<unsigned int> >, class std::allocator<class std::vector<unsigned int, class std::allocator<unsigned int> > > > (VPUNN::InferenceExecutionData::*)() const) &VPUNN::InferenceExecutionData::input_shapes, "Get the model input tensors shapes\n\n \n std::vector<std::vector<unsigned int>>\n\nC++: VPUNN::InferenceExecutionData::input_shapes() const --> class std::vector<class std::vector<unsigned int, class std::allocator<unsigned int> >, class std::allocator<class std::vector<unsigned int, class std::allocator<unsigned int> > > >");
		cl.def("output_shapes", (class std::vector<class std::vector<unsigned int, class std::allocator<unsigned int> >, class std::allocator<class std::vector<unsigned int, class std::allocator<unsigned int> > > > (VPUNN::InferenceExecutionData::*)() const) &VPUNN::InferenceExecutionData::output_shapes, "Get the model output tensors shapes\n\n \n std::vector<std::vector<unsigned int>>\n\nC++: VPUNN::InferenceExecutionData::output_shapes() const --> class std::vector<class std::vector<unsigned int, class std::allocator<unsigned int> >, class std::allocator<class std::vector<unsigned int, class std::allocator<unsigned int> > > >");
	}
	{ // VPUNN::InferenceModel file: line:37
		pybind11::class_<VPUNN::InferenceModel, std::shared_ptr<VPUNN::InferenceModel>> cl(M("VPUNN"), "InferenceModel", "VPUNN inference model\n After creation can be used only if the model was initialized, otherwise will crash\n\n ");
		cl.def( pybind11::init<const char *>(), pybind11::arg("filename") );

		cl.def( pybind11::init<const char *, unsigned long, bool>(), pybind11::arg("data"), pybind11::arg("length"), pybind11::arg("with_copy") );

		cl.def( pybind11::init( [](VPUNN::InferenceModel const &o){ return new VPUNN::InferenceModel(o); } ) );
		cl.def("network_name", (std::string (VPUNN::InferenceModel::*)() const) &VPUNN::InferenceModel::network_name, "Name of the network stored in the model\n\n \n unaltered name of the model as it is stored in the source/filename of the loaded model\n\nC++: VPUNN::InferenceModel::network_name() const --> std::string");
		cl.def("is_initialized", (bool (VPUNN::InferenceModel::*)() const) &VPUNN::InferenceModel::is_initialized, "Check if the NN model is initialized\n\n \n true if the NN model is initialized\n \n\n false if the NN model is not initialized\n\nC++: VPUNN::InferenceModel::is_initialized() const --> bool");
		cl.def("predict", (void (VPUNN::InferenceModel::*)(class VPUNN::InferenceExecutionData &) const) &VPUNN::InferenceModel::predict, "Run the inference\n\n     \n\nC++: VPUNN::InferenceModel::predict(class VPUNN::InferenceExecutionData &) const --> void", pybind11::arg("execution_memory"));
		cl.def("assign", (class VPUNN::InferenceModel & (VPUNN::InferenceModel::*)(const class VPUNN::InferenceModel &)) &VPUNN::InferenceModel::operator=, "C++: VPUNN::InferenceModel::operator=(const class VPUNN::InferenceModel &) --> class VPUNN::InferenceModel &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ModelVersion file: line:23
		pybind11::class_<VPUNN::ModelVersion, std::shared_ptr<VPUNN::ModelVersion>> cl(M("VPUNN"), "ModelVersion", "Extracts and keeps  the version out of a NN raw name");
		cl.def( pybind11::init( [](){ return new VPUNN::ModelVersion(); } ) );
		cl.def( pybind11::init( [](VPUNN::ModelVersion const &o){ return new VPUNN::ModelVersion(o); } ) );
		cl.def("get_input_interface_version", (int (VPUNN::ModelVersion::*)() const) &VPUNN::ModelVersion::get_input_interface_version, "value of input interface version, the one for the input descriptor\n\nC++: VPUNN::ModelVersion::get_input_interface_version() const --> int");
		cl.def("get_output_interface_version", (int (VPUNN::ModelVersion::*)() const) &VPUNN::ModelVersion::get_output_interface_version, "value of output interface version, the one for the NN provided value(s)\n\nC++: VPUNN::ModelVersion::get_output_interface_version() const --> int");
		cl.def("get_NN_name", (std::string (VPUNN::ModelVersion::*)() const) &VPUNN::ModelVersion::get_NN_name, "name of the NN, without version info\n\nC++: VPUNN::ModelVersion::get_NN_name() const --> std::string");
		cl.def("get_raw_name", (std::string (VPUNN::ModelVersion::*)() const) &VPUNN::ModelVersion::get_raw_name, "initial, raw name of the VPUNN model. contains version info\n\nC++: VPUNN::ModelVersion::get_raw_name() const --> std::string");
		cl.def("parse_name", (void (VPUNN::ModelVersion::*)(const std::string &)) &VPUNN::ModelVersion::parse_name, "parsed the name and extracts the information\n get the name based on separator \"-\", template: NNNNNNN-VI-VO[and here to be a string with nickname&serialNo\n without impacting the crt implementation]\n Template extension: NNNNNNN-VI-VO $v0000.0000 Nickname26chars$\n with 26 chars between $ signs\n VI and VO must be integers, and only the integers part will be\n considered when converting NNNNNN cannot be empty, it will be replaced with \"none\" if empty Only first three\n parts of the name are considered, rest are ignored. Missing pars will be considered default: none-1-1\n\n \n invalid_argument, out_of_range\n\nC++: VPUNN::ModelVersion::parse_name(const std::string &) --> void", pybind11::arg("raw_NN_name"));
	}
	{ // VPUNN::Runtime file: line:28
		pybind11::class_<VPUNN::Runtime, std::shared_ptr<VPUNN::Runtime>> cl(M("VPUNN"), "Runtime", "VPUNN runtime model\n\n ");
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::Runtime(a0); } ), "doc" , pybind11::arg("filename"));
		cl.def( pybind11::init<const std::string &, bool>(), pybind11::arg("filename"), pybind11::arg("profile") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2){ return new VPUNN::Runtime(a0, a1, a2); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"));
		cl.def( pybind11::init<const char *, unsigned long, bool, bool>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile") );

		cl.def( pybind11::init( [](VPUNN::Runtime const &o){ return new VPUNN::Runtime(o); } ) );
		cl.def("predict", (const float * (VPUNN::Runtime::*)(const float *, const unsigned int, class VPUNN::InferenceExecutionData &) const) &VPUNN::Runtime::predict<float>, "C++: VPUNN::Runtime::predict(const float *, const unsigned int, class VPUNN::InferenceExecutionData &) const --> const float *", pybind11::return_value_policy::automatic_reference, pybind11::arg("input_array"), pybind11::arg("input_size"), pybind11::arg("current_model_buffer_data"));
		cl.def("predict", (const class std::vector<float, class std::allocator<float> > (VPUNN::Runtime::*)(const class std::vector<float, class std::allocator<float> > &, class VPUNN::InferenceExecutionData &) const) &VPUNN::Runtime::predict<float>, "C++: VPUNN::Runtime::predict(const class std::vector<float, class std::allocator<float> > &, class VPUNN::InferenceExecutionData &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("input_tensor"), pybind11::arg("current_model_buffer_data"));
		cl.def("model_version_info", (const class VPUNN::ModelVersion & (VPUNN::Runtime::*)() const) &VPUNN::Runtime::model_version_info, "provides version info for loaded model\n The provided reference is always up to date with the loaded model\n The info are conditioned(otherwise default) by the successful loading of the model.\n\n \n a long lived reference to the version information\n\nC++: VPUNN::Runtime::model_version_info() const --> const class VPUNN::ModelVersion &", pybind11::return_value_policy::reference);
		cl.def("initialized", (bool (VPUNN::Runtime::*)() const) &VPUNN::Runtime::initialized, "Check if the NN model is initialized\n\n \n true if the NN model is initialized\n \n\n false if the NN model is not initialized\n\nC++: VPUNN::Runtime::initialized() const --> bool");
		cl.def("createNewInferenceExecutionData", (class VPUNN::InferenceExecutionData (VPUNN::Runtime::*)(const unsigned int) const) &VPUNN::Runtime::createNewInferenceExecutionData, "C++: VPUNN::Runtime::createNewInferenceExecutionData(const unsigned int) const --> class VPUNN::InferenceExecutionData", pybind11::arg("batch"));
		cl.def("predict", (void (VPUNN::Runtime::*)(class VPUNN::InferenceExecutionData &) const) &VPUNN::Runtime::predict, "just a wrapper for the model prediction. The buffer has to be with input data  and will contain output data\n\nC++: VPUNN::Runtime::predict(class VPUNN::InferenceExecutionData &) const --> void", pybind11::arg("current_model_buffer_data"));
	}
	{ // VPUNN::HWCharacteristicsRawData file: line:23
		pybind11::class_<VPUNN::HWCharacteristicsRawData, std::shared_ptr<VPUNN::HWCharacteristicsRawData>> cl(M("VPUNN"), "HWCharacteristicsRawData", "this struct contains all hardware characteristics a device can have\n     we use a struct to hold together all characteristics, and we will create a HWcharateristics object with specific\n     values for each device in a device HW characteristics dedicated header file");
		cl.def( pybind11::init( [](){ return new VPUNN::HWCharacteristicsRawData(); } ) );
		cl.def_readwrite("dpu_freq_clk", &VPUNN::HWCharacteristicsRawData::dpu_freq_clk);
		cl.def_readwrite("cmx_freq_clk", &VPUNN::HWCharacteristicsRawData::cmx_freq_clk);
		cl.def_readwrite("cmx_word_size_B", &VPUNN::HWCharacteristicsRawData::cmx_word_size_B);
		cl.def_readwrite("DMA_engine_B", &VPUNN::HWCharacteristicsRawData::DMA_engine_B);
		cl.def_readwrite("dpu_cmx_num_read_ports", &VPUNN::HWCharacteristicsRawData::dpu_cmx_num_read_ports);
		cl.def_readwrite("dram_bandwidth_MBps", &VPUNN::HWCharacteristicsRawData::dram_bandwidth_MBps);
		cl.def_readwrite("nr_macs", &VPUNN::HWCharacteristicsRawData::nr_macs);
		cl.def_readwrite("fp_ratio", &VPUNN::HWCharacteristicsRawData::fp_ratio);
		cl.def_readwrite("nr_ppe", &VPUNN::HWCharacteristicsRawData::nr_ppe);
		cl.def_readwrite("input_channels_mac", &VPUNN::HWCharacteristicsRawData::input_channels_mac);
		cl.def_readwrite("nDPU_per_tile", &VPUNN::HWCharacteristicsRawData::nDPU_per_tile);
		cl.def_readwrite("dma_ports", &VPUNN::HWCharacteristicsRawData::dma_ports);
		cl.def_readwrite("profiling_clk_MHz", &VPUNN::HWCharacteristicsRawData::profiling_clk_MHz);
		cl.def_readwrite("profiling_clk_Hz", &VPUNN::HWCharacteristicsRawData::profiling_clk_Hz);
	}
	{ // VPUNN::LatencyValuesRawData file: line:41
		pybind11::class_<VPUNN::LatencyValuesRawData, std::shared_ptr<VPUNN::LatencyValuesRawData>> cl(M("VPUNN"), "LatencyValuesRawData", "");
		cl.def( pybind11::init( [](){ return new VPUNN::LatencyValuesRawData(); } ) );
		cl.def_readwrite("dramLatency_Nanoseconds", &VPUNN::LatencyValuesRawData::dramLatency_Nanoseconds);
		cl.def_readwrite("cmxLatency_CMXClockCycles", &VPUNN::LatencyValuesRawData::cmxLatency_CMXClockCycles);
		cl.def_readwrite("postTimeLatency_CMXClockCycles", &VPUNN::LatencyValuesRawData::postTimeLatency_CMXClockCycles);
		cl.def_readwrite("mixedMemoryEfficiency", &VPUNN::LatencyValuesRawData::mixedMemoryEfficiency);
	}
	{ // VPUNN::DeviceHWCharacteristicsBase file: line:51
		pybind11::class_<VPUNN::DeviceHWCharacteristicsBase, std::shared_ptr<VPUNN::DeviceHWCharacteristicsBase>> cl(M("VPUNN"), "DeviceHWCharacteristicsBase", "Base class for device hardware characteristics, providing access to various hardware parameters and common\n computations.\n All have to be constexpr");
		cl.def( pybind11::init<const struct VPUNN::HWCharacteristicsRawData &, const struct VPUNN::LatencyValuesRawData &>(), pybind11::arg("hw_characteristics_"), pybind11::arg("latency_values_") );

		cl.def( pybind11::init( [](VPUNN::DeviceHWCharacteristicsBase const &o){ return new VPUNN::DeviceHWCharacteristicsBase(o); } ) );
		cl.def("get_dpu_freq_clk", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_dpu_freq_clk, "C++: VPUNN::DeviceHWCharacteristicsBase::get_dpu_freq_clk() const --> unsigned int");
		cl.def("get_cmx_freq_clk", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_cmx_freq_clk, "C++: VPUNN::DeviceHWCharacteristicsBase::get_cmx_freq_clk() const --> unsigned int");
		cl.def("get_cmx_word_size_B", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_cmx_word_size_B, "C++: VPUNN::DeviceHWCharacteristicsBase::get_cmx_word_size_B() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_DMA_DDR_interface_bytes, "C++: VPUNN::DeviceHWCharacteristicsBase::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_dpu_cmx_num_read_ports, "C++: VPUNN::DeviceHWCharacteristicsBase::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_dram_bandwidth_MBps, "C++: VPUNN::DeviceHWCharacteristicsBase::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_nr_macs, "C++: VPUNN::DeviceHWCharacteristicsBase::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_fp_ratio, "C++: VPUNN::DeviceHWCharacteristicsBase::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_nr_ppe, "C++: VPUNN::DeviceHWCharacteristicsBase::get_nr_ppe() const --> unsigned int");
		cl.def("get_input_channels_mac", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_input_channels_mac, "C++: VPUNN::DeviceHWCharacteristicsBase::get_input_channels_mac() const --> unsigned int");
		cl.def("get_nDPU_per_tile", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_nDPU_per_tile, "C++: VPUNN::DeviceHWCharacteristicsBase::get_nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_dma_ports, "C++: VPUNN::DeviceHWCharacteristicsBase::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_profiling_clk_MHz, "C++: VPUNN::DeviceHWCharacteristicsBase::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::DeviceHWCharacteristicsBase::*)() const) &VPUNN::DeviceHWCharacteristicsBase::get_profiling_clk_Hz, "C++: VPUNN::DeviceHWCharacteristicsBase::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::DeviceHWCharacteristicsBase::*)(enum VPUNN::MemoryLocation) const) &VPUNN::DeviceHWCharacteristicsBase::get_DMA_latency, "C++: VPUNN::DeviceHWCharacteristicsBase::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::DeviceHWCharacteristicsBase::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::DeviceHWCharacteristicsBase::getDMATRansferEfficiency, "C++: VPUNN::DeviceHWCharacteristicsBase::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
	}
}


// File: VPUNN_41.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IDeviceHWCharacteristics file: line:22
struct PyCallBack_VPUNN_IDeviceHWCharacteristics : public VPUNN::IDeviceHWCharacteristics {
	using VPUNN::IDeviceHWCharacteristics::IDeviceHWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_dpu_fclk\"");
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_cmx_fclk\"");
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_cmx_word_size_bytes\"");
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes\"");
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports\"");
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_dram_bandwidth_MBps\"");
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_nr_macs\"");
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_fp_ratio\"");
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_nr_ppe\"");
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::input_channels_mac\"");
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::nDPU_per_tile\"");
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_dma_ports\"");
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_profiling_clk_MHz\"");
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_profiling_clk_Hz\"");
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::get_DMA_latency\"");
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDeviceHWCharacteristics *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDeviceHWCharacteristics::getDMATRansferEfficiency\"");
	}
};

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

void bind_VPUNN_41(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::IDeviceHWCharacteristics file: line:22
		pybind11::class_<VPUNN::IDeviceHWCharacteristics, std::shared_ptr<VPUNN::IDeviceHWCharacteristics>, PyCallBack_VPUNN_IDeviceHWCharacteristics> cl(M("VPUNN"), "IDeviceHWCharacteristics", "Device based characteristics");
		cl.def(pybind11::init<PyCallBack_VPUNN_IDeviceHWCharacteristics const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IDeviceHWCharacteristics(); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_42.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

void bind_VPUNN_42(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_43.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

void bind_VPUNN_43(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_44.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

void bind_VPUNN_44(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_45.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

void bind_VPUNN_45(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_46.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
struct PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_t : public VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> {
	using VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::ALT_VPUXX_HWCharacteristics;

	unsigned int get_dpu_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_dpu_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_fclk();
	}
	unsigned int get_cmx_fclk() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_cmx_fclk");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_fclk();
	}
	unsigned int get_cmx_word_size_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_cmx_word_size_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_cmx_word_size_bytes();
	}
	int get_DMA_DDR_interface_bytes() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_DMA_DDR_interface_bytes");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_DDR_interface_bytes();
	}
	unsigned int get_dpu_cmx_num_read_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_dpu_cmx_num_read_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dpu_cmx_num_read_ports();
	}
	float get_dram_bandwidth_MBps() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_dram_bandwidth_MBps");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dram_bandwidth_MBps();
	}
	unsigned int get_nr_macs() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_nr_macs");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_macs();
	}
	unsigned int get_fp_ratio() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_fp_ratio");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_fp_ratio();
	}
	unsigned int get_nr_ppe() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_nr_ppe");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_nr_ppe();
	}
	unsigned int input_channels_mac() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "input_channels_mac");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::input_channels_mac();
	}
	unsigned int nDPU_per_tile() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "nDPU_per_tile");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::nDPU_per_tile();
	}
	int get_dma_ports() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_dma_ports");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_dma_ports();
	}
	float get_profiling_clk_MHz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_profiling_clk_MHz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<float>::value) {
				static pybind11::detail::override_caster_t<float> caster;
				return pybind11::detail::cast_ref<float>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<float>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_MHz();
	}
	int get_profiling_clk_Hz() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_profiling_clk_Hz");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_profiling_clk_Hz();
	}
	unsigned int get_DMA_latency(enum VPUNN::MemoryLocation a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "get_DMA_latency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::get_DMA_latency(a0);
	}
	using _binder_ret_0 = class std::tuple<float, float>;
	_binder_ret_0 getDMATRansferEfficiency(const enum VPUNN::MemoryLocation a0, const enum VPUNN::MemoryLocation a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> *>(this), "getDMATRansferEfficiency");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ALT_VPUXX_HWCharacteristics::getDMATRansferEfficiency(a0, a1);
	}
};

void bind_VPUNN_46(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ALT_VPUXX_HWCharacteristics file: line:24
		pybind11::class_<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>, std::shared_ptr<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>>, PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_t, VPUNN::IDeviceHWCharacteristics> cl(M("VPUNN"), "ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>(); }, [](){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_t const &o){ return new PyCallBack_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> const &o){ return new VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>(o); } ) );
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dpu_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_cmx_fclk, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_cmx_word_size_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_DMA_DDR_interface_bytes, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dpu_cmx_num_read_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dram_bandwidth_MBps, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_nr_macs, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_fp_ratio, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_nr_ppe, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::input_channels_mac, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::nDPU_per_tile, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dma_ports, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_profiling_clk_MHz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)() const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_profiling_clk_Hz, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)(enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_DMA_latency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::getDMATRansferEfficiency, "C++: VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics>::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("get_dpu_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_fclk() const --> unsigned int");
		cl.def("get_cmx_fclk", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_fclk, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_fclk() const --> unsigned int");
		cl.def("get_cmx_word_size_bytes", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_cmx_word_size_bytes() const --> unsigned int");
		cl.def("get_DMA_DDR_interface_bytes", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_DDR_interface_bytes() const --> int");
		cl.def("get_dpu_cmx_num_read_ports", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dpu_cmx_num_read_ports() const --> unsigned int");
		cl.def("get_dram_bandwidth_MBps", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps, "C++: VPUNN::IDeviceHWCharacteristics::get_dram_bandwidth_MBps() const --> float");
		cl.def("get_nr_macs", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_macs, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_macs() const --> unsigned int");
		cl.def("get_fp_ratio", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_fp_ratio, "C++: VPUNN::IDeviceHWCharacteristics::get_fp_ratio() const --> unsigned int");
		cl.def("get_nr_ppe", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_nr_ppe, "C++: VPUNN::IDeviceHWCharacteristics::get_nr_ppe() const --> unsigned int");
		cl.def("input_channels_mac", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::input_channels_mac, "C++: VPUNN::IDeviceHWCharacteristics::input_channels_mac() const --> unsigned int");
		cl.def("nDPU_per_tile", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::nDPU_per_tile, "C++: VPUNN::IDeviceHWCharacteristics::nDPU_per_tile() const --> unsigned int");
		cl.def("get_dma_ports", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_dma_ports, "C++: VPUNN::IDeviceHWCharacteristics::get_dma_ports() const --> int");
		cl.def("get_profiling_clk_MHz", (float (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_MHz() const --> float");
		cl.def("get_profiling_clk_Hz", (int (VPUNN::IDeviceHWCharacteristics::*)() const) &VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz, "C++: VPUNN::IDeviceHWCharacteristics::get_profiling_clk_Hz() const --> int");
		cl.def("get_DMA_latency", (unsigned int (VPUNN::IDeviceHWCharacteristics::*)(enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::get_DMA_latency, "C++: VPUNN::IDeviceHWCharacteristics::get_DMA_latency(enum VPUNN::MemoryLocation) const --> unsigned int", pybind11::arg("location"));
		cl.def("getDMATRansferEfficiency", (class std::tuple<float, float> (VPUNN::IDeviceHWCharacteristics::*)(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const) &VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency, "C++: VPUNN::IDeviceHWCharacteristics::getDMATRansferEfficiency(const enum VPUNN::MemoryLocation, const enum VPUNN::MemoryLocation) const --> class std::tuple<float, float>", pybind11::arg("s"), pybind11::arg("d"));
		cl.def("assign", (class VPUNN::IDeviceHWCharacteristics & (VPUNN::IDeviceHWCharacteristics::*)(const class VPUNN::IDeviceHWCharacteristics &)) &VPUNN::IDeviceHWCharacteristics::operator=, "C++: VPUNN::IDeviceHWCharacteristics::operator=(const class VPUNN::IDeviceHWCharacteristics &) --> class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPU2_0_HWCharacteristics file: line:25
		pybind11::class_<VPUNN::VPU2_0_HWCharacteristics, std::shared_ptr<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU2_0_HWCharacteristics", "specific VPU 2.0 HW characteristics values");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU2_0_HWCharacteristics(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_0_HWCharacteristics const &o){ return new VPUNN::VPU2_0_HWCharacteristics(o); } ) );
	}
	{ // VPUNN::VPU2_1_HWCharacteristics file: line:25
		pybind11::class_<VPUNN::VPU2_1_HWCharacteristics, std::shared_ptr<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU2_1_HWCharacteristics", "specific VPU 2.1 HW characteristics values");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU2_1_HWCharacteristics(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_1_HWCharacteristics const &o){ return new VPUNN::VPU2_1_HWCharacteristics(o); } ) );
	}
	{ // VPUNN::VPU2_7_HWCharacteristics file: line:25
		pybind11::class_<VPUNN::VPU2_7_HWCharacteristics, std::shared_ptr<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU2_7_HWCharacteristics", "specific VPU 2.7 HW characteristics values");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU2_7_HWCharacteristics(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_7_HWCharacteristics const &o){ return new VPUNN::VPU2_7_HWCharacteristics(o); } ) );
	}
	{ // VPUNN::VPU2_7_HWCharacteristics_legacy file: line:54
		pybind11::class_<VPUNN::VPU2_7_HWCharacteristics_legacy, std::shared_ptr<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU2_7_HWCharacteristics_legacy", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU2_7_HWCharacteristics_legacy(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU2_7_HWCharacteristics_legacy const &o){ return new VPUNN::VPU2_7_HWCharacteristics_legacy(o); } ) );
	}
	{ // VPUNN::VPU4_0_HWCharacteristics_v0 file: line:25
		pybind11::class_<VPUNN::VPU4_0_HWCharacteristics_v0, std::shared_ptr<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU4_0_HWCharacteristics_v0", "specific NPU 4.0 HW characteristics values");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU4_0_HWCharacteristics_v0(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU4_0_HWCharacteristics_v0 const &o){ return new VPUNN::VPU4_0_HWCharacteristics_v0(o); } ) );
	}
	{ // VPUNN::VPU4_0_HWCharacteristics_v1 file: line:56
		pybind11::class_<VPUNN::VPU4_0_HWCharacteristics_v1, std::shared_ptr<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU4_0_HWCharacteristics_v1", "Evolution considering post latency and imperfect efficiency for DMA");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU4_0_HWCharacteristics_v1(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU4_0_HWCharacteristics_v1 const &o){ return new VPUNN::VPU4_0_HWCharacteristics_v1(o); } ) );
	}
	{ // VPUNN::VPU4_0_HWCharacteristics_legacy file: line:86
		pybind11::class_<VPUNN::VPU4_0_HWCharacteristics_legacy, std::shared_ptr<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU4_0_HWCharacteristics_legacy", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU4_0_HWCharacteristics_legacy(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU4_0_HWCharacteristics_legacy const &o){ return new VPUNN::VPU4_0_HWCharacteristics_legacy(o); } ) );
	}
	{ // VPUNN::VPU5_0_HWCharacteristics_v0 file: line:25
		pybind11::class_<VPUNN::VPU5_0_HWCharacteristics_v0, std::shared_ptr<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU5_0_HWCharacteristics_v0", "specific NPU 5.0 HW characteristics values");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU5_0_HWCharacteristics_v0(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU5_0_HWCharacteristics_v0 const &o){ return new VPUNN::VPU5_0_HWCharacteristics_v0(o); } ) );
	}
	{ // VPUNN::VPU5_0_HWCharacteristics_v1 file: line:57
		pybind11::class_<VPUNN::VPU5_0_HWCharacteristics_v1, std::shared_ptr<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU5_0_HWCharacteristics_v1", "Evolution considering post latency and imperfect efficiency for DMA");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU5_0_HWCharacteristics_v1(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU5_0_HWCharacteristics_v1 const &o){ return new VPUNN::VPU5_0_HWCharacteristics_v1(o); } ) );
	}
	{ // VPUNN::VPU5_0_HWCharacteristics_legacy file: line:88
		pybind11::class_<VPUNN::VPU5_0_HWCharacteristics_legacy, std::shared_ptr<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "VPU5_0_HWCharacteristics_legacy", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU5_0_HWCharacteristics_legacy(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPU5_0_HWCharacteristics_legacy const &o){ return new VPUNN::VPU5_0_HWCharacteristics_legacy(o); } ) );
	}
	{ // VPUNN::Default_HWCharacteristics file: line:25
		pybind11::class_<VPUNN::Default_HWCharacteristics, std::shared_ptr<VPUNN::Default_HWCharacteristics>, VPUNN::DeviceHWCharacteristicsBase> cl(M("VPUNN"), "Default_HWCharacteristics", "default/basic HW characteristics values\n here we have HW characteristics for unknown devices");
		cl.def( pybind11::init( [](){ return new VPUNN::Default_HWCharacteristics(); } ) );
		cl.def( pybind11::init( [](VPUNN::Default_HWCharacteristics const &o){ return new VPUNN::Default_HWCharacteristics(o); } ) );
	}
}


// File: VPUNN_47.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple
#include <variant> // std::variant

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_47(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::IndexMap file: line:20
		pybind11::class_<VPUNN::IndexMap, std::shared_ptr<VPUNN::IndexMap>> cl(M("VPUNN"), "IndexMap", "This class provides a mapping from VPUDevice enum values to indices in the tuple of HW characteristics.\n assumes a fixed order of the Devices  in the Tuple");
		cl.def( pybind11::init( [](){ return new VPUNN::IndexMap(); } ) );
		cl.def_static("get_device_index", (unsigned long (*)()) &VPUNN::IndexMap::get_device_index<VPUNN::VPUDevice::VPU_2_0>, "C++: VPUNN::IndexMap::get_device_index() --> unsigned long");
		cl.def_static("get_device_index", (unsigned long (*)()) &VPUNN::IndexMap::get_device_index<VPUNN::VPUDevice::VPU_2_1>, "C++: VPUNN::IndexMap::get_device_index() --> unsigned long");
		cl.def_static("get_device_index", (unsigned long (*)()) &VPUNN::IndexMap::get_device_index<VPUNN::VPUDevice::VPU_2_7>, "C++: VPUNN::IndexMap::get_device_index() --> unsigned long");
		cl.def_static("get_device_index", (unsigned long (*)()) &VPUNN::IndexMap::get_device_index<VPUNN::VPUDevice::VPU_4_0>, "C++: VPUNN::IndexMap::get_device_index() --> unsigned long");
		cl.def_static("get_device_index", (unsigned long (*)()) &VPUNN::IndexMap::get_device_index<VPUNN::VPUDevice::NPU_5_0>, "C++: VPUNN::IndexMap::get_device_index() --> unsigned long");
		cl.def_static("get_device_index", (unsigned long (*)()) &VPUNN::IndexMap::get_device_index<VPUNN::VPUDevice::__size>, "C++: VPUNN::IndexMap::get_device_index() --> unsigned long");
		cl.def_static("extract_tuple_content", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::Default_HWCharacteristics> &)) &VPUNN::IndexMap::extract_tuple_content<std::variant<VPUNN::VPU2_0_HWCharacteristics, VPUNN::VPU2_1_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics_legacy, VPUNN::VPU4_0_HWCharacteristics_v0, VPUNN::VPU4_0_HWCharacteristics_v1, VPUNN::VPU4_0_HWCharacteristics_legacy, VPUNN::VPU5_0_HWCharacteristics_v0, VPUNN::VPU5_0_HWCharacteristics_v1, VPUNN::VPU5_0_HWCharacteristics_legacy, VPUNN::Default_HWCharacteristics>,std::tuple<VPUNN::VPU2_0_HWCharacteristics, VPUNN::VPU2_1_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics, VPUNN::VPU4_0_HWCharacteristics_v0, VPUNN::VPU5_0_HWCharacteristics_v0, VPUNN::Default_HWCharacteristics>>, "C++: VPUNN::IndexMap::extract_tuple_content(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::Default_HWCharacteristics> &) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"), pybind11::arg("theTuple"));
		cl.def_static("extract_tuple_content", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::Default_HWCharacteristics> &)) &VPUNN::IndexMap::extract_tuple_content<std::variant<VPUNN::VPU2_0_HWCharacteristics, VPUNN::VPU2_1_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics_legacy, VPUNN::VPU4_0_HWCharacteristics_v0, VPUNN::VPU4_0_HWCharacteristics_v1, VPUNN::VPU4_0_HWCharacteristics_legacy, VPUNN::VPU5_0_HWCharacteristics_v0, VPUNN::VPU5_0_HWCharacteristics_v1, VPUNN::VPU5_0_HWCharacteristics_legacy, VPUNN::Default_HWCharacteristics>,std::tuple<VPUNN::VPU2_0_HWCharacteristics, VPUNN::VPU2_1_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics, VPUNN::VPU4_0_HWCharacteristics_v1, VPUNN::VPU5_0_HWCharacteristics_v1, VPUNN::Default_HWCharacteristics>>, "C++: VPUNN::IndexMap::extract_tuple_content(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::Default_HWCharacteristics> &) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"), pybind11::arg("theTuple"));
		cl.def_static("extract_tuple_content", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> &)) &VPUNN::IndexMap::extract_tuple_content<std::variant<VPUNN::VPU2_0_HWCharacteristics, VPUNN::VPU2_1_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics_legacy, VPUNN::VPU4_0_HWCharacteristics_v0, VPUNN::VPU4_0_HWCharacteristics_v1, VPUNN::VPU4_0_HWCharacteristics_legacy, VPUNN::VPU5_0_HWCharacteristics_v0, VPUNN::VPU5_0_HWCharacteristics_v1, VPUNN::VPU5_0_HWCharacteristics_legacy, VPUNN::Default_HWCharacteristics>,std::tuple<VPUNN::VPU2_0_HWCharacteristics, VPUNN::VPU2_1_HWCharacteristics, VPUNN::VPU2_7_HWCharacteristics_legacy, VPUNN::VPU4_0_HWCharacteristics_legacy, VPUNN::VPU5_0_HWCharacteristics_legacy, VPUNN::Default_HWCharacteristics>>, "C++: VPUNN::IndexMap::extract_tuple_content(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> &) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"), pybind11::arg("theTuple"));
		cl.def_static("extract_tuple_content", (const class VPUNN::IDeviceHWCharacteristics & (*)(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &)) &VPUNN::IndexMap::extract_tuple_content<const VPUNN::IDeviceHWCharacteristics &,std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >>, "C++: VPUNN::IndexMap::extract_tuple_content(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &) --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"), pybind11::arg("theTuple"));
		cl.def_static("extract_tuple_content", (const class VPUNN::IDeviceHWCharacteristics & (*)(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &)) &VPUNN::IndexMap::extract_tuple_content<const VPUNN::IDeviceHWCharacteristics &,std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >>, "C++: VPUNN::IndexMap::extract_tuple_content(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &) --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"), pybind11::arg("theTuple"));
		cl.def_static("extract_tuple_content", (const class VPUNN::IDeviceHWCharacteristics & (*)(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &)) &VPUNN::IndexMap::extract_tuple_content<const VPUNN::IDeviceHWCharacteristics &,std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >>, "C++: VPUNN::IndexMap::extract_tuple_content(enum VPUNN::VPUDevice, const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &) --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"), pybind11::arg("theTuple"));
	}
	{ // VPUNN::DeviceHWCHaracteristicsConstRepo file: line:42
		pybind11::class_<VPUNN::DeviceHWCHaracteristicsConstRepo, std::shared_ptr<VPUNN::DeviceHWCHaracteristicsConstRepo>> cl(M("VPUNN"), "DeviceHWCHaracteristicsConstRepo", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DeviceHWCHaracteristicsConstRepo(); } ) );
		cl.def_static("get_HWCharacteristics", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice)) &VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristics, "get device specific HW characteristics, active by default\n\nC++: VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristics(enum VPUNN::VPUDevice) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"));
		cl.def_static("get_HWCharacteristicsEvo0", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice)) &VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristicsEvo0, "C++: VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristicsEvo0(enum VPUNN::VPUDevice) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"));
		cl.def_static("get_HWCharacteristicsEvo1", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice)) &VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristicsEvo1, "C++: VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristicsEvo1(enum VPUNN::VPUDevice) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"));
		cl.def_static("get_HWCharacteristics_Legacy", (class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics> (*)(enum VPUNN::VPUDevice)) &VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristics_Legacy, "get device specific HW characteristics for legacy mode\n\nC++: VPUNN::DeviceHWCHaracteristicsConstRepo::get_HWCharacteristics_Legacy(enum VPUNN::VPUDevice) --> class std::variant<class VPUNN::VPU2_0_HWCharacteristics, class VPUNN::VPU2_1_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics, class VPUNN::VPU2_7_HWCharacteristics_legacy, class VPUNN::VPU4_0_HWCharacteristics_v0, class VPUNN::VPU4_0_HWCharacteristics_v1, class VPUNN::VPU4_0_HWCharacteristics_legacy, class VPUNN::VPU5_0_HWCharacteristics_v0, class VPUNN::VPU5_0_HWCharacteristics_v1, class VPUNN::VPU5_0_HWCharacteristics_legacy, class VPUNN::Default_HWCharacteristics>", pybind11::arg("device"));
	}
}


// File: VPUNN_48.cpp
#include <sstream> // __str__
#include <tuple> // std::tuple
#include <variant> // std::variant

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IHWCharacteristicsSet file: line:18
struct PyCallBack_VPUNN_IHWCharacteristicsSet : public VPUNN::IHWCharacteristicsSet {
	using VPUNN::IHWCharacteristicsSet::IHWCharacteristicsSet;

	const class VPUNN::IDeviceHWCharacteristics & device(enum VPUNN::VPUDevice a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IHWCharacteristicsSet *>(this), "device");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceHWCharacteristics &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceHWCharacteristics &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IHWCharacteristicsSet::device\"");
	}
};

// VPUNN::Base_HWCharacteristicsSet file: line:39
struct PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t : public VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> {
	using VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>::Base_HWCharacteristicsSet;

	const class VPUNN::IDeviceHWCharacteristics & device(enum VPUNN::VPUDevice a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> *>(this), "device");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceHWCharacteristics &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceHWCharacteristics &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o));
		}
		return Base_HWCharacteristicsSet::device(a0);
	}
};

// VPUNN::Base_HWCharacteristicsSet file: line:39
struct PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t : public VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> {
	using VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>::Base_HWCharacteristicsSet;

	const class VPUNN::IDeviceHWCharacteristics & device(enum VPUNN::VPUDevice a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> *>(this), "device");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceHWCharacteristics &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceHWCharacteristics &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o));
		}
		return Base_HWCharacteristicsSet::device(a0);
	}
};

void bind_VPUNN_48(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::GlobalHarwdwareCharacteristics file: line:30
		pybind11::class_<VPUNN::GlobalHarwdwareCharacteristics, std::shared_ptr<VPUNN::GlobalHarwdwareCharacteristics>> cl(M("VPUNN"), "GlobalHarwdwareCharacteristics", "USes the global defaults configurations");
		cl.def_static("get_dpu_fclk", (unsigned int (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::get_dpu_fclk, "Get the DPU default frequency in MHz\n Used in VPUX\n \n\n a VPUDevice\n \n\n unsigned int\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::get_dpu_fclk(enum VPUNN::VPUDevice) --> unsigned int", pybind11::arg("device"));
		cl.def_static("get_dram_bandwidth_MBps", (float (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::get_dram_bandwidth_MBps, "Get the DRAM bandwidth in MB/s for a specific VPU IP\n Actual speed is limited also by the CMX clock  bandwidth\n Used in VPUX\n \n\n a VPUDevice\n \n\n float\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::get_dram_bandwidth_MBps(enum VPUNN::VPUDevice) --> float", pybind11::arg("device"));
		cl.def_static("get_dram_bandwidth_MBps_Legacy", (float (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::get_dram_bandwidth_MBps_Legacy, "Get the DRAM bandwidth in MB/s for a specific VPU IP\n Actual speed is limited also by the CMX clock  bandwidth\n Used in VPUX\n \n\n a VPUDevice\n \n\n float\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::get_dram_bandwidth_MBps_Legacy(enum VPUNN::VPUDevice) --> float", pybind11::arg("device"));
		cl.def_static("get_cmx_fclk", (unsigned int (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::get_cmx_fclk, "Get the CMX default frequency in MHz\n\n \n a VPUDevice\n \n\n unsigned int\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::get_cmx_fclk(enum VPUNN::VPUDevice) --> unsigned int", pybind11::arg("device"));
		cl.def_static("nDPU_per_tile", (unsigned int (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::nDPU_per_tile, "Get the MAC/input channels/cycles for a specific VPU IP\n\n \n a VPUDevice\n \n\n unsigned int\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::nDPU_per_tile(enum VPUNN::VPUDevice) --> unsigned int", pybind11::arg("device"));
		cl.def_static("get_dma_ports", (int (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::get_dma_ports, "Get the channels/Ports of DMA.\n Can be used to run one channel per separate tile (like for DDR to CM in case of weights for SOK),\n cannot be used to run multiple channels when transferring to same tile\n \n\n a VPUDevice\n \n\n int\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::get_dma_ports(enum VPUNN::VPUDevice) --> int", pybind11::arg("device"));
		cl.def_static("get_DMA_DDR_interface_bytes", (int (*)(enum VPUNN::VPUDevice)) &VPUNN::GlobalHarwdwareCharacteristics::get_DMA_DDR_interface_bytes, "Get DMA engine bytes per cycle\n\n \n a VPUDevice\n \n\n unsigned int\n\nC++: VPUNN::GlobalHarwdwareCharacteristics::get_DMA_DDR_interface_bytes(enum VPUNN::VPUDevice) --> int", pybind11::arg("device"));
	}
	// VPUNN::get_dpu_fclk(enum VPUNN::VPUDevice) file: line:179
	M("VPUNN").def("get_dpu_fclk", (unsigned int (*)(enum VPUNN::VPUDevice)) &VPUNN::get_dpu_fclk, "/ global functions temporary kept here due to VPUX compatibility\n\nC++: VPUNN::get_dpu_fclk(enum VPUNN::VPUDevice) --> unsigned int", pybind11::arg("device"));

	// VPUNN::get_dram_bandwidth_MBps_Legacy(enum VPUNN::VPUDevice) file: line:183
	M("VPUNN").def("get_dram_bandwidth_MBps_Legacy", (float (*)(enum VPUNN::VPUDevice)) &VPUNN::get_dram_bandwidth_MBps_Legacy, "C++: VPUNN::get_dram_bandwidth_MBps_Legacy(enum VPUNN::VPUDevice) --> float", pybind11::arg("device"));

	// VPUNN::get_dram_bandwidth_MBps(enum VPUNN::VPUDevice) file: line:187
	M("VPUNN").def("get_dram_bandwidth_MBps", (float (*)(enum VPUNN::VPUDevice)) &VPUNN::get_dram_bandwidth_MBps, "C++: VPUNN::get_dram_bandwidth_MBps(enum VPUNN::VPUDevice) --> float", pybind11::arg("device"));

	{ // VPUNN::PerformanceMode file: line:15
		pybind11::class_<VPUNN::PerformanceMode, std::shared_ptr<VPUNN::PerformanceMode>> cl(M("VPUNN"), "PerformanceMode", "");
		cl.def( pybind11::init( [](){ return new VPUNN::PerformanceMode(); } ) );
	}
	{ // VPUNN::IHWCharacteristicsSet file: line:18
		pybind11::class_<VPUNN::IHWCharacteristicsSet, VPUNN::IHWCharacteristicsSet*, PyCallBack_VPUNN_IHWCharacteristicsSet> cl(M("VPUNN"), "IHWCharacteristicsSet", "interface that holds a complete set of device HW performance providers");
		cl.def(pybind11::init<PyCallBack_VPUNN_IHWCharacteristicsSet const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IHWCharacteristicsSet(); } ) );
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::IHWCharacteristicsSet::*)(enum VPUNN::VPUDevice) const) &VPUNN::IHWCharacteristicsSet::device, "C++: VPUNN::IHWCharacteristicsSet::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IHWCharacteristicsSet & (VPUNN::IHWCharacteristicsSet::*)(const class VPUNN::IHWCharacteristicsSet &)) &VPUNN::IHWCharacteristicsSet::operator=, "C++: VPUNN::IHWCharacteristicsSet::operator=(const class VPUNN::IHWCharacteristicsSet &) --> class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::Base_HWCharacteristicsSet file: line:39
		pybind11::class_<VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>, std::shared_ptr<VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>>, PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t, VPUNN::IHWCharacteristicsSet> cl(M("VPUNN"), "Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>(); }, [](){ return new PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t(); } ), "doc");
		cl.def( pybind11::init<const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &>(), pybind11::arg("configs") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t const &o){ return new PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v0_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> const &o){ return new VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>(o); } ) );
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >, VPUNN::IndexMap>::device, "C++: VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v0>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >, VPUNN::IndexMap>::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::IHWCharacteristicsSet::*)(enum VPUNN::VPUDevice) const) &VPUNN::IHWCharacteristicsSet::device, "C++: VPUNN::IHWCharacteristicsSet::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IHWCharacteristicsSet & (VPUNN::IHWCharacteristicsSet::*)(const class VPUNN::IHWCharacteristicsSet &)) &VPUNN::IHWCharacteristicsSet::operator=, "C++: VPUNN::IHWCharacteristicsSet::operator=(const class VPUNN::IHWCharacteristicsSet &) --> class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::Base_HWCharacteristicsSet file: line:39
		pybind11::class_<VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>, std::shared_ptr<VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>>, PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t, VPUNN::IHWCharacteristicsSet> cl(M("VPUNN"), "Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>(); }, [](){ return new PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t(); } ), "doc");
		cl.def( pybind11::init<const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &>(), pybind11::arg("configs") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t const &o){ return new PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_v1_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> const &o){ return new VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>(o); } ) );
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >, VPUNN::IndexMap>::device, "C++: VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_v1>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >, VPUNN::IndexMap>::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::IHWCharacteristicsSet::*)(enum VPUNN::VPUDevice) const) &VPUNN::IHWCharacteristicsSet::device, "C++: VPUNN::IHWCharacteristicsSet::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IHWCharacteristicsSet & (VPUNN::IHWCharacteristicsSet::*)(const class VPUNN::IHWCharacteristicsSet &)) &VPUNN::IHWCharacteristicsSet::operator=, "C++: VPUNN::IHWCharacteristicsSet::operator=(const class VPUNN::IHWCharacteristicsSet &) --> class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_49.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <variant> // std::variant

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Base_HWCharacteristicsSet file: line:39
struct PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t : public VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> {
	using VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>::Base_HWCharacteristicsSet;

	const class VPUNN::IDeviceHWCharacteristics & device(enum VPUNN::VPUDevice a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> *>(this), "device");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::IDeviceHWCharacteristics &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::IDeviceHWCharacteristics &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::IDeviceHWCharacteristics &>(std::move(o));
		}
		return Base_HWCharacteristicsSet::device(a0);
	}
};

void bind_VPUNN_49(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Base_HWCharacteristicsSet file: line:39
		pybind11::class_<VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>, std::shared_ptr<VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>>, PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t, VPUNN::IHWCharacteristicsSet> cl(M("VPUNN"), "Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>(); }, [](){ return new PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t(); } ), "doc");
		cl.def( pybind11::init<const class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> > &>(), pybind11::arg("configs") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t const &o){ return new PyCallBack_VPUNN_Base_HWCharacteristicsSet_std_tuple_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_0_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_1_HWCharacteristics_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU2_7_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU4_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_VPU5_0_HWCharacteristics_legacy_VPUNN_ALT_VPUXX_HWCharacteristics_VPUNN_Default_HWCharacteristics_VPUNN_IndexMap_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap> const &o){ return new VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>(o); } ) );
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >,VPUNN::IndexMap>::*)(enum VPUNN::VPUDevice) const) &VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >, VPUNN::IndexMap>::device, "C++: VPUNN::Base_HWCharacteristicsSet<std::tuple<VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_0_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_1_HWCharacteristics>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU2_7_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU4_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::VPU5_0_HWCharacteristics_legacy>, VPUNN::ALT_VPUXX_HWCharacteristics<VPUNN::Default_HWCharacteristics> >, VPUNN::IndexMap>::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("device", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::IHWCharacteristicsSet::*)(enum VPUNN::VPUDevice) const) &VPUNN::IHWCharacteristicsSet::device, "C++: VPUNN::IHWCharacteristicsSet::device(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IHWCharacteristicsSet & (VPUNN::IHWCharacteristicsSet::*)(const class VPUNN::IHWCharacteristicsSet &)) &VPUNN::IHWCharacteristicsSet::operator=, "C++: VPUNN::IHWCharacteristicsSet::operator=(const class VPUNN::IHWCharacteristicsSet &) --> class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::HWCharacteristicsSuperSets file: line:20
		pybind11::class_<VPUNN::HWCharacteristicsSuperSets, std::shared_ptr<VPUNN::HWCharacteristicsSuperSets>> cl(M("VPUNN"), "HWCharacteristicsSuperSets", "Holds multiple HW characteristics configurations (main, legacy, etc.)");
		cl.def( pybind11::init( [](){ return new VPUNN::HWCharacteristicsSuperSets(); } ) );
		cl.def_static("mainConfiguration", (const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> & (*)()) &VPUNN::HWCharacteristicsSuperSets::mainConfiguration, "C++: VPUNN::HWCharacteristicsSuperSets::mainConfiguration() --> const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> &", pybind11::return_value_policy::reference);
		cl.def_static("get_mainConfigurationRef", (const class VPUNN::IHWCharacteristicsSet & (*)()) &VPUNN::HWCharacteristicsSuperSets::get_mainConfigurationRef, "C++: VPUNN::HWCharacteristicsSuperSets::get_mainConfigurationRef() --> const class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference);
		cl.def_static("mainEvo0Configuration", (const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> & (*)()) &VPUNN::HWCharacteristicsSuperSets::mainEvo0Configuration, "C++: VPUNN::HWCharacteristicsSuperSets::mainEvo0Configuration() --> const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v0>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> &", pybind11::return_value_policy::reference);
		cl.def_static("get_mainEvo0ConfigurationRef", (const class VPUNN::IHWCharacteristicsSet & (*)()) &VPUNN::HWCharacteristicsSuperSets::get_mainEvo0ConfigurationRef, "C++: VPUNN::HWCharacteristicsSuperSets::get_mainEvo0ConfigurationRef() --> const class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference);
		cl.def_static("mainEvo1Configuration", (const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> & (*)()) &VPUNN::HWCharacteristicsSuperSets::mainEvo1Configuration, "C++: VPUNN::HWCharacteristicsSuperSets::mainEvo1Configuration() --> const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_v1>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> &", pybind11::return_value_policy::reference);
		cl.def_static("get_mainEvo1ConfigurationRef", (const class VPUNN::IHWCharacteristicsSet & (*)()) &VPUNN::HWCharacteristicsSuperSets::get_mainEvo1ConfigurationRef, "C++: VPUNN::HWCharacteristicsSuperSets::get_mainEvo1ConfigurationRef() --> const class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference);
		cl.def_static("legacyConfiguration", (const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> & (*)()) &VPUNN::HWCharacteristicsSuperSets::legacyConfiguration, "C++: VPUNN::HWCharacteristicsSuperSets::legacyConfiguration() --> const class VPUNN::Base_HWCharacteristicsSet<class std::tuple<class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_0_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_1_HWCharacteristics>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU2_7_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU4_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::VPU5_0_HWCharacteristics_legacy>, class VPUNN::ALT_VPUXX_HWCharacteristics<class VPUNN::Default_HWCharacteristics> >, class VPUNN::IndexMap> &", pybind11::return_value_policy::reference);
		cl.def_static("get_legacyConfigurationRef", (const class VPUNN::IHWCharacteristicsSet & (*)()) &VPUNN::HWCharacteristicsSuperSets::get_legacyConfigurationRef, "C++: VPUNN::HWCharacteristicsSuperSets::get_legacyConfigurationRef() --> const class VPUNN::IHWCharacteristicsSet &", pybind11::return_value_policy::reference);
	}
	{ // VPUNN::HWPerformanceModel file: line:46
		pybind11::class_<VPUNN::HWPerformanceModel, std::shared_ptr<VPUNN::HWPerformanceModel>> cl(M("VPUNN"), "HWPerformanceModel", "Provides idealized performance modeling for DPU workloads.\n IT is based on main set of HW characteristics\n\n This class is responsible for estimating the theoretical, best-case execution characteristics of DPU operations,\n such as the number of cycles required and the number of MAC operations performed.\n It serves as a reference model, ignoring non-ideal hardware effects and focusing on the maximum achievable\n performance under optimal conditions (e.g., full MAC utilization, ideal sparsity handling).\n\n An instance of this class is intended to be use as a provider for performance modeling for DPU workloads.\n DEvice dependent configuration is provided by the hw_characteristics sets.\n IN case Performance depends on Devices this should be redesigned");
		cl.def( pybind11::init( [](){ return new VPUNN::HWPerformanceModel(); } ) );
		cl.def( pybind11::init( [](VPUNN::HWPerformanceModel const &o){ return new VPUNN::HWPerformanceModel(o); } ) );
		cl.def("get_hw_info", (const class VPUNN::IDeviceHWCharacteristics & (VPUNN::HWPerformanceModel::*)(enum VPUNN::VPUDevice) const) &VPUNN::HWPerformanceModel::get_hw_info, "C++: VPUNN::HWPerformanceModel::get_hw_info(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceHWCharacteristics &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("DPU_Power_IdealCycles", (unsigned long (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::DPU_Power_IdealCycles, "Compute the DPU ideal cycles, considers HW optimizations like sparsity\n \n\n Calculates cycles that a single issue scalar CPU would require to execute\n a DPUWorkload then divides by number of MACs which can be performed in\n parallel by DPU. All operations are base-lined in the same manner with no\n non ideal factors considered at all.\n Like: Number of cycles if all the MAC resources are used 100%.\n Sparsity is considered for inputs and weights\n\n \n a DPUWorkload\n \n\n  ideal execution DPU cycles\n\nC++: VPUNN::HWPerformanceModel::DPU_Power_IdealCycles(const struct VPUNN::DPUWorkload &) const --> unsigned long", pybind11::arg("wl"));
		cl.def("DPU_Efficency_IdealCycles", (unsigned long (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::DPU_Efficency_IdealCycles, "Compute the DPU ideal cycles, pure MAC based, no hw optimizations\n \n\n Calculates cycles that a single issue scalar CPU would require to execute\n a DPUWorkload then divides by number of MACs which can be performed in\n parallel by DPU. All operations are base-lined in the same manner with no\n non ideal factors considered at all.\n Like: Number of cycles if all the MAC resources are used 100%.\n\n \n a DPUWorkload\n \n\n  ideal execution DPU cycles\n\nC++: VPUNN::HWPerformanceModel::DPU_Efficency_IdealCycles(const struct VPUNN::DPUWorkload &) const --> unsigned long", pybind11::arg("wl"));
		cl.def("DPU_MAC_based_cycles", (unsigned long (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &, const unsigned long) const) &VPUNN::HWPerformanceModel::DPU_MAC_based_cycles, "Compute the DPU ideal cycles\n \n\n Calculates cycles that a single issue scalar CPU would require to execute\n a DPUWorkload then divides by number of MACs which can be performed in\n parallel by DPU. All operations are base-lined in the same manner with no\n non ideal factors considered at all.\n Like: Number of cycles if all the MAC resources are used 100%.\n\n \n a DPUWorkload\n \n\n how many MAC operations are required to do for the wl. (computed outsided, may or may not\n consider HW optimizations like sparsity)\n \n\n  ideal execution DPU cycles\n\nC++: VPUNN::HWPerformanceModel::DPU_MAC_based_cycles(const struct VPUNN::DPUWorkload &, const unsigned long) const --> unsigned long", pybind11::arg("wl"), pybind11::arg("MACs_to_compute"));
		cl.def("compute_Ideal_MAC_operations_cnt", (unsigned long (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::compute_Ideal_MAC_operations_cnt, "Computes how many MACs are required to generate this output\n \n\n Calculates operations that a single issue scalar CPU would require to execute a DPUWorkload, no sparsity\n or other HW details are taken in consideration\n\n \n a DPUWorkload\n \n\n number of operations\n\nC++: VPUNN::HWPerformanceModel::compute_Ideal_MAC_operations_cnt(const struct VPUNN::DPUWorkload &) const --> unsigned long", pybind11::arg("wl"));
		cl.def("compute_HW_MAC_operations_cnt", (unsigned long (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::compute_HW_MAC_operations_cnt, "Computes how many MACs are required to generate this output\n \n\n Calculates operations that a single issue scalar CPU would require to execute a DPUWorkload considering\n hardware details like sparsity.\n\n \n a DPUWorkload\n \n\n number of operations\n\nC++: VPUNN::HWPerformanceModel::compute_HW_MAC_operations_cnt(const struct VPUNN::DPUWorkload &) const --> unsigned long", pybind11::arg("wl"));
		cl.def("native_comp_is_any_fp", (bool (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::native_comp_is_any_fp, "Determine whether native computation for workload is floating point or int\n\n \n a DPUWorkload\n \n\n bool\n\nC++: VPUNN::HWPerformanceModel::native_comp_is_any_fp(const struct VPUNN::DPUWorkload &) const --> bool", pybind11::arg("wl"));
		cl.def("native_comp_on_fp16", (bool (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::native_comp_on_fp16, "C++: VPUNN::HWPerformanceModel::native_comp_on_fp16(const struct VPUNN::DPUWorkload &) const --> bool", pybind11::arg("wl"));
		cl.def("native_comp_on_fp8", (bool (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::native_comp_on_fp8, "C++: VPUNN::HWPerformanceModel::native_comp_on_fp8(const struct VPUNN::DPUWorkload &) const --> bool", pybind11::arg("wl"));
		cl.def("native_comp_on_i8", (bool (VPUNN::HWPerformanceModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::HWPerformanceModel::native_comp_on_i8, "C++: VPUNN::HWPerformanceModel::native_comp_on_i8(const struct VPUNN::DPUWorkload &) const --> bool", pybind11::arg("wl"));
	}
}


// File: VPUNN_50.cpp
#include <array> // std::array
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SWOperation file: line:25
struct PyCallBack_VPUNN_SWOperation : public VPUNN::SWOperation {
	using VPUNN::SWOperation::SWOperation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SWOperation *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"SWOperation::cycles\"");
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_4_15829_t : public VPUNN::SHVElementwise<4,15829> {
	using VPUNN::SHVElementwise<4,15829>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<4,15829> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_1000_0_t : public VPUNN::SHVElementwise<1000,0> {
	using VPUNN::SHVElementwise<1000,0>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<1000,0> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_12_11587_t : public VPUNN::SHVElementwise<12,11587> {
	using VPUNN::SHVElementwise<12,11587>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<12,11587> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_8_13192_t : public VPUNN::SHVElementwise<8,13192> {
	using VPUNN::SHVElementwise<8,13192>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<8,13192> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_8_13036_t : public VPUNN::SHVElementwise<8,13036> {
	using VPUNN::SHVElementwise<8,13036>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<8,13036> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

void bind_VPUNN_50(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPUPowerFactorLUT file: line:33
		pybind11::class_<VPUNN::VPUPowerFactorLUT, std::shared_ptr<VPUNN::VPUPowerFactorLUT>> cl(M("VPUNN"), "VPUPowerFactorLUT", "VPU Power factor LUTs\n \n\n The power factor LUT is lookup table that will be indexed by operation\n and will return another LUT that will be indexed by the number of input channels\n When there is no entry in the second LUT, the value returned will be the interpolation between its smaller and\n greater match in table");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUPowerFactorLUT(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUPowerFactorLUT const &o){ return new VPUNN::VPUPowerFactorLUT(o); } ) );
		cl.def_static("getOperationAndPowerVirusAdjustementFactor", (float (*)(const struct VPUNN::DPUWorkload &, const class VPUNN::HWPerformanceModel &)) &VPUNN::VPUPowerFactorLUT::getOperationAndPowerVirusAdjustementFactor, "Get the value from the LUT+ extra info for a specific workload, represents the relative power factor\n adjustment towards the PowerVirus (INT8). The factor will take in consideration all aspects of the WL ,\n operation, type, etc\n\n \n the workload for which to compute the factor.\n \n\n  the adjustment factor\n\nC++: VPUNN::VPUPowerFactorLUT::getOperationAndPowerVirusAdjustementFactor(const struct VPUNN::DPUWorkload &, const class VPUNN::HWPerformanceModel &) --> float", pybind11::arg("wl"), pybind11::arg("performanceInfo"));
		cl.def_static("get_PowerVirus_exceed_factor", (float (*)(enum VPUNN::VPUDevice)) &VPUNN::VPUPowerFactorLUT::get_PowerVirus_exceed_factor, "C++: VPUNN::VPUPowerFactorLUT::get_PowerVirus_exceed_factor(enum VPUNN::VPUDevice) --> float", pybind11::arg("device"));
		cl.def("assign", (class VPUNN::VPUPowerFactorLUT & (VPUNN::VPUPowerFactorLUT::*)(const class VPUNN::VPUPowerFactorLUT &)) &VPUNN::VPUPowerFactorLUT::operator=, "C++: VPUNN::VPUPowerFactorLUT::operator=(const class VPUNN::VPUPowerFactorLUT &) --> class VPUNN::VPUPowerFactorLUT &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::DPUInfoPack file: line:25
		pybind11::class_<VPUNN::DPUInfoPack, std::shared_ptr<VPUNN::DPUInfoPack>> cl(M("VPUNN"), "DPUInfoPack", "L1API info for a DPUWorkload.\n intention is to obtain all info at once, in a more efficient way.\n Zero values means either error or value could not be obtained\n See the original interface method for each field to understand its meaning");
		cl.def( pybind11::init( [](VPUNN::DPUInfoPack const &o){ return new VPUNN::DPUInfoPack(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DPUInfoPack(); } ) );
		cl.def_readwrite("DPUCycles", &VPUNN::DPUInfoPack::DPUCycles);
		cl.def_readwrite("errInfo", &VPUNN::DPUInfoPack::errInfo);
		cl.def_readwrite("energy", &VPUNN::DPUInfoPack::energy);
		cl.def_readwrite("power_activity_factor", &VPUNN::DPUInfoPack::power_activity_factor);
		cl.def_readwrite("power_mac_utilization", &VPUNN::DPUInfoPack::power_mac_utilization);
		cl.def_readwrite("power_ideal_cycles", &VPUNN::DPUInfoPack::power_ideal_cycles);
		cl.def_readwrite("sparse_mac_operations", &VPUNN::DPUInfoPack::sparse_mac_operations);
		cl.def_readwrite("efficiency_activity_factor", &VPUNN::DPUInfoPack::efficiency_activity_factor);
		cl.def_readwrite("efficiency_mac_utilization", &VPUNN::DPUInfoPack::efficiency_mac_utilization);
		cl.def_readwrite("efficiency_ideal_cycles", &VPUNN::DPUInfoPack::efficiency_ideal_cycles);
		cl.def_readwrite("dense_mac_operations", &VPUNN::DPUInfoPack::dense_mac_operations);
		cl.def_readwrite("hw_theoretical_cycles", &VPUNN::DPUInfoPack::hw_theoretical_cycles);

		cl.def("__str__", [](VPUNN::DPUInfoPack const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::DPU_OperationSanitizer file: line:25
		pybind11::class_<VPUNN::DPU_OperationSanitizer, std::shared_ptr<VPUNN::DPU_OperationSanitizer>> cl(M("VPUNN"), "DPU_OperationSanitizer", "Sanitizes a Workload  based on device rules");
		cl.def( pybind11::init( [](VPUNN::DPU_OperationSanitizer const &o){ return new VPUNN::DPU_OperationSanitizer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DPU_OperationSanitizer(); } ) );
		cl.def("check_and_sanitize", (void (VPUNN::DPU_OperationSanitizer::*)(struct VPUNN::DPUWorkload &, struct VPUNN::SanityReport &) const) &VPUNN::DPU_OperationSanitizer::check_and_sanitize, "Checks if the workload is usable, makes sanitization changes , and lets the user know the sanitized\n workload and its conclusion\n\n Sanitization means that some parameters of the workload are automatically adjusted, but still the new WL is\n relevant (or equivalent regarding cost) to the original one. Sanitization performed:\n - input and output tensors data type are restricted to one type per category. UINT8 for ints on 8 bit, FLOAT16\n for all16 bit floats. \n\n IDeviceValidValues around valid_datatypes usage\n  - ...\n\n Usability checks will check general characteristics:\n - if the device is supported\n - if workload fits in CMX memory\n - if the operation is supported\n - ...\n\n \n [in, out] the workload to analyze and sanitize\n \n\n [out] status of check. if not OK (not NO_ERROR) the wl cannot be used\n\nC++: VPUNN::DPU_OperationSanitizer::check_and_sanitize(struct VPUNN::DPUWorkload &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("wl"), pybind11::arg("result"));
		cl.def("check_data_consistency", (void (VPUNN::DPU_OperationSanitizer::*)(struct VPUNN::DPUWorkload &, struct VPUNN::SanityReport &) const) &VPUNN::DPU_OperationSanitizer::check_data_consistency, "C++: VPUNN::DPU_OperationSanitizer::check_data_consistency(struct VPUNN::DPUWorkload &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("wl"), pybind11::arg("result"));
		cl.def("getDeviceConfiguration", (const class VPUNN::IDeviceValidValues & (VPUNN::DPU_OperationSanitizer::*)(enum VPUNN::VPUDevice) const) &VPUNN::DPU_OperationSanitizer::getDeviceConfiguration, "C++: VPUNN::DPU_OperationSanitizer::getDeviceConfiguration(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
	}
	{ // VPUNN::SWOperation file: line:25
		pybind11::class_<VPUNN::SWOperation, std::shared_ptr<VPUNN::SWOperation>, PyCallBack_VPUNN_SWOperation> cl(M("VPUNN"), "SWOperation", "The base structure that encodes a Software layer\n \n\n\n\n\n ");
		cl.def( pybind11::init( [](const enum VPUNN::VPUDevice & a0, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a1, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > & a2){ return new PyCallBack_VPUNN_SWOperation(a0, a1, a2); } ), "doc");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const std::string &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("loc_name") );

		cl.def(pybind11::init<PyCallBack_VPUNN_SWOperation const &>());
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<4,15829>, std::shared_ptr<VPUNN::SHVElementwise<4,15829>>, PyCallBack_VPUNN_SHVElementwise_4_15829_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_4_15829_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_4_15829_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_4_15829_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<4,15829> const &o){ return new VPUNN::SHVElementwise<4,15829>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<4,15829>::*)() const) &VPUNN::SHVElementwise<4, 15829>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<4, 15829>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<4,15829>::*)() const) &VPUNN::SHVElementwise<4, 15829>::getLatency, "C++: VPUNN::SHVElementwise<4, 15829>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<4,15829>::*)() const) &VPUNN::SHVElementwise<4, 15829>::cycles, "C++: VPUNN::SHVElementwise<4, 15829>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<1000,0>, std::shared_ptr<VPUNN::SHVElementwise<1000,0>>, PyCallBack_VPUNN_SHVElementwise_1000_0_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_1000_0_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_1000_0_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_1000_0_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<1000,0> const &o){ return new VPUNN::SHVElementwise<1000,0>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<1000,0>::*)() const) &VPUNN::SHVElementwise<1000, 0>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<1000, 0>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<1000,0>::*)() const) &VPUNN::SHVElementwise<1000, 0>::getLatency, "C++: VPUNN::SHVElementwise<1000, 0>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<1000,0>::*)() const) &VPUNN::SHVElementwise<1000, 0>::cycles, "C++: VPUNN::SHVElementwise<1000, 0>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<12,11587>, std::shared_ptr<VPUNN::SHVElementwise<12,11587>>, PyCallBack_VPUNN_SHVElementwise_12_11587_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_12_11587_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_12_11587_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_12_11587_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<12,11587> const &o){ return new VPUNN::SHVElementwise<12,11587>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<12,11587>::*)() const) &VPUNN::SHVElementwise<12, 11587>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<12, 11587>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<12,11587>::*)() const) &VPUNN::SHVElementwise<12, 11587>::getLatency, "C++: VPUNN::SHVElementwise<12, 11587>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<12,11587>::*)() const) &VPUNN::SHVElementwise<12, 11587>::cycles, "C++: VPUNN::SHVElementwise<12, 11587>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<8,13192>, std::shared_ptr<VPUNN::SHVElementwise<8,13192>>, PyCallBack_VPUNN_SHVElementwise_8_13192_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_8_13192_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_8_13192_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_8_13192_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<8,13192> const &o){ return new VPUNN::SHVElementwise<8,13192>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<8,13192>::*)() const) &VPUNN::SHVElementwise<8, 13192>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<8, 13192>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<8,13192>::*)() const) &VPUNN::SHVElementwise<8, 13192>::getLatency, "C++: VPUNN::SHVElementwise<8, 13192>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<8,13192>::*)() const) &VPUNN::SHVElementwise<8, 13192>::cycles, "C++: VPUNN::SHVElementwise<8, 13192>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<8,13036>, std::shared_ptr<VPUNN::SHVElementwise<8,13036>>, PyCallBack_VPUNN_SHVElementwise_8_13036_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_8_13036_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_8_13036_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_8_13036_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<8,13036> const &o){ return new VPUNN::SHVElementwise<8,13036>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<8,13036>::*)() const) &VPUNN::SHVElementwise<8, 13036>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<8, 13036>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<8,13036>::*)() const) &VPUNN::SHVElementwise<8, 13036>::getLatency, "C++: VPUNN::SHVElementwise<8, 13036>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<8,13036>::*)() const) &VPUNN::SHVElementwise<8, 13036>::cycles, "C++: VPUNN::SHVElementwise<8, 13036>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
}


// File: VPUNN_51.cpp
#include <array> // std::array
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_45_30591_t : public VPUNN::SHVElementwise<45,30591> {
	using VPUNN::SHVElementwise<45,30591>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<45,30591> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_15_11047_t : public VPUNN::SHVElementwise<15,11047> {
	using VPUNN::SHVElementwise<15,11047>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<15,11047> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_15_11000_t : public VPUNN::SHVElementwise<15,11000> {
	using VPUNN::SHVElementwise<15,11000>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<15,11000> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVElementwise file: line:27
struct PyCallBack_VPUNN_SHVElementwise_789_12946_t : public VPUNN::SHVElementwise<789,12946> {
	using VPUNN::SHVElementwise<789,12946>::SHVElementwise;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVElementwise<789,12946> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::ShaveOpExecutor file: line:21
struct PyCallBack_VPUNN_ShaveOpExecutor : public VPUNN::ShaveOpExecutor {
	using VPUNN::ShaveOpExecutor::ShaveOpExecutor;

	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveOpExecutor *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"ShaveOpExecutor::dpuCycles\"");
	}
	std::string getName() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveOpExecutor *>(this), "getName");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return ShaveOpExecutor::getName();
	}
	std::string toString() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveOpExecutor *>(this), "toString");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"ShaveOpExecutor::toString\"");
	}
	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0, const int a1, const int a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveOpExecutor *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"ShaveOpExecutor::dpuCycles\"");
	}
};

void bind_VPUNN_51(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<45,30591>, std::shared_ptr<VPUNN::SHVElementwise<45,30591>>, PyCallBack_VPUNN_SHVElementwise_45_30591_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_45_30591_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_45_30591_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_45_30591_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<45,30591> const &o){ return new VPUNN::SHVElementwise<45,30591>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<45,30591>::*)() const) &VPUNN::SHVElementwise<45, 30591>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<45, 30591>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<45,30591>::*)() const) &VPUNN::SHVElementwise<45, 30591>::getLatency, "C++: VPUNN::SHVElementwise<45, 30591>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<45,30591>::*)() const) &VPUNN::SHVElementwise<45, 30591>::cycles, "C++: VPUNN::SHVElementwise<45, 30591>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<15,11047>, std::shared_ptr<VPUNN::SHVElementwise<15,11047>>, PyCallBack_VPUNN_SHVElementwise_15_11047_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_15_11047_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_15_11047_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_15_11047_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<15,11047> const &o){ return new VPUNN::SHVElementwise<15,11047>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<15,11047>::*)() const) &VPUNN::SHVElementwise<15, 11047>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<15, 11047>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<15,11047>::*)() const) &VPUNN::SHVElementwise<15, 11047>::getLatency, "C++: VPUNN::SHVElementwise<15, 11047>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<15,11047>::*)() const) &VPUNN::SHVElementwise<15, 11047>::cycles, "C++: VPUNN::SHVElementwise<15, 11047>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<15,11000>, std::shared_ptr<VPUNN::SHVElementwise<15,11000>>, PyCallBack_VPUNN_SHVElementwise_15_11000_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_15_11000_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_15_11000_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_15_11000_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<15,11000> const &o){ return new VPUNN::SHVElementwise<15,11000>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<15,11000>::*)() const) &VPUNN::SHVElementwise<15, 11000>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<15, 11000>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<15,11000>::*)() const) &VPUNN::SHVElementwise<15, 11000>::getLatency, "C++: VPUNN::SHVElementwise<15, 11000>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<15,11000>::*)() const) &VPUNN::SHVElementwise<15, 11000>::cycles, "C++: VPUNN::SHVElementwise<15, 11000>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVElementwise file: line:27
		pybind11::class_<VPUNN::SHVElementwise<789,12946>, std::shared_ptr<VPUNN::SHVElementwise<789,12946>>, PyCallBack_VPUNN_SHVElementwise_789_12946_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVElementwise_789_12946_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVElementwise_789_12946_t const &o){ return new PyCallBack_VPUNN_SHVElementwise_789_12946_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVElementwise<789,12946> const &o){ return new VPUNN::SHVElementwise<789,12946>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVElementwise<789,12946>::*)() const) &VPUNN::SHVElementwise<789, 12946>::getKernelEfficiency, "C++: VPUNN::SHVElementwise<789, 12946>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVElementwise<789,12946>::*)() const) &VPUNN::SHVElementwise<789, 12946>::getLatency, "C++: VPUNN::SHVElementwise<789, 12946>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVElementwise<789,12946>::*)() const) &VPUNN::SHVElementwise<789, 12946>::cycles, "C++: VPUNN::SHVElementwise<789, 12946>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::ShaveOpExecutor file: line:21
		pybind11::class_<VPUNN::ShaveOpExecutor, VPUNN::ShaveOpExecutor*, PyCallBack_VPUNN_ShaveOpExecutor> cl(M("VPUNN"), "ShaveOpExecutor", "Interface for a shave model from the execution(obtaining the runtime) perspective.\n Instances are properly configured Shave models, for a particular model.\n Cannot be deleted by the user.");
		cl.def(pybind11::init<PyCallBack_VPUNN_ShaveOpExecutor const &>());
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n\n \n cycles in dpu frequency\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("getName", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getName, "the name of the modeled SHAVE function\n\nC++: VPUNN::ShaveOpExecutor::getName() const --> std::string");
		cl.def("toString", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::toString, "provides a string with details of implementation, name parameters, frequencies, etc\n\nC++: VPUNN::ShaveOpExecutor::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation considering that the nominal freq were altered with the\n passed ones as params\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n \n\n  the new DPU freq\n \n\n the new shave (VPU) freq\n\n \n cycles in dpu frequency as specified by present_dpu_frq\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("getNumExpectedParams", (unsigned int (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getNumExpectedParams, "C++: VPUNN::ShaveOpExecutor::getNumExpectedParams() const --> unsigned int");
	}
	{ // VPUNN::CostFunction3SlopesDescriptor file: line:8
		pybind11::class_<VPUNN::CostFunction3SlopesDescriptor, std::shared_ptr<VPUNN::CostFunction3SlopesDescriptor>> cl(M("VPUNN"), "CostFunction3SlopesDescriptor", "");
		cl.def( pybind11::init( [](int const & a0, float const & a1, struct std::array<float, 3> const & a2){ return new VPUNN::CostFunction3SlopesDescriptor(a0, a1, a2); } ), "doc" , pybind11::arg("unroll"), pybind11::arg("offset"), pybind11::arg("slope"));
		cl.def( pybind11::init<int, float, struct std::array<float, 3>, int>(), pybind11::arg("unroll"), pybind11::arg("offset"), pybind11::arg("slope"), pybind11::arg("loop_offset") );

		cl.def( pybind11::init( [](VPUNN::CostFunction3SlopesDescriptor const &o){ return new VPUNN::CostFunction3SlopesDescriptor(o); } ) );
		cl.def_readwrite("unroll_", &VPUNN::CostFunction3SlopesDescriptor::unroll_);
		cl.def_readwrite("offset_", &VPUNN::CostFunction3SlopesDescriptor::offset_);
		cl.def_readwrite("slope_", &VPUNN::CostFunction3SlopesDescriptor::slope_);
		cl.def_readwrite("loop_offset_", &VPUNN::CostFunction3SlopesDescriptor::loop_offset_);
		cl.def("assign", (struct VPUNN::CostFunction3SlopesDescriptor & (VPUNN::CostFunction3SlopesDescriptor::*)(const struct VPUNN::CostFunction3SlopesDescriptor &)) &VPUNN::CostFunction3SlopesDescriptor::operator=, "C++: VPUNN::CostFunction3SlopesDescriptor::operator=(const struct VPUNN::CostFunction3SlopesDescriptor &) --> struct VPUNN::CostFunction3SlopesDescriptor &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPUEMSoftmaxParamsDesciptor file: line:19
		pybind11::class_<VPUNN::VPUEMSoftmaxParamsDesciptor, std::shared_ptr<VPUNN::VPUEMSoftmaxParamsDesciptor>> cl(M("VPUNN"), "VPUEMSoftmaxParamsDesciptor", "");
		cl.def( pybind11::init<int, int, int, int, int, int, int, int, int, int, int, int>(), pybind11::arg("unroll"), pybind11::arg("unroll_offset"), pybind11::arg("unroll_slope"), pybind11::arg("unroll_overhead"), pybind11::arg("vector_offset"), pybind11::arg("vector_slope0"), pybind11::arg("vector_slope"), pybind11::arg("vector_overhead"), pybind11::arg("scalar_offset"), pybind11::arg("scalar_slope0"), pybind11::arg("scalar_slope"), pybind11::arg("scalar_overhead") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSoftmaxParamsDesciptor const &o){ return new VPUNN::VPUEMSoftmaxParamsDesciptor(o); } ) );
		cl.def_readwrite("unroll_", &VPUNN::VPUEMSoftmaxParamsDesciptor::unroll_);
		cl.def_readwrite("unroll_offset_", &VPUNN::VPUEMSoftmaxParamsDesciptor::unroll_offset_);
		cl.def_readwrite("unroll_slope_", &VPUNN::VPUEMSoftmaxParamsDesciptor::unroll_slope_);
		cl.def_readwrite("unroll_overhead_", &VPUNN::VPUEMSoftmaxParamsDesciptor::unroll_overhead_);
		cl.def_readwrite("vector_offset_", &VPUNN::VPUEMSoftmaxParamsDesciptor::vector_offset_);
		cl.def_readwrite("vector_slope0_", &VPUNN::VPUEMSoftmaxParamsDesciptor::vector_slope0_);
		cl.def_readwrite("vector_slope_", &VPUNN::VPUEMSoftmaxParamsDesciptor::vector_slope_);
		cl.def_readwrite("vector_overhead_", &VPUNN::VPUEMSoftmaxParamsDesciptor::vector_overhead_);
		cl.def_readwrite("scalar_offset_", &VPUNN::VPUEMSoftmaxParamsDesciptor::scalar_offset_);
		cl.def_readwrite("scalar_slope0_", &VPUNN::VPUEMSoftmaxParamsDesciptor::scalar_slope0_);
		cl.def_readwrite("scalar_slope_", &VPUNN::VPUEMSoftmaxParamsDesciptor::scalar_slope_);
		cl.def_readwrite("scalar_overhead_", &VPUNN::VPUEMSoftmaxParamsDesciptor::scalar_overhead_);
		cl.def("assign", (struct VPUNN::VPUEMSoftmaxParamsDesciptor & (VPUNN::VPUEMSoftmaxParamsDesciptor::*)(const struct VPUNN::VPUEMSoftmaxParamsDesciptor &)) &VPUNN::VPUEMSoftmaxParamsDesciptor::operator=, "C++: VPUNN::VPUEMSoftmaxParamsDesciptor::operator=(const struct VPUNN::VPUEMSoftmaxParamsDesciptor &) --> struct VPUNN::VPUEMSoftmaxParamsDesciptor &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::CostFunctionSoftmaxDescriptor file: line:50
		pybind11::class_<VPUNN::CostFunctionSoftmaxDescriptor, std::shared_ptr<VPUNN::CostFunctionSoftmaxDescriptor>> cl(M("VPUNN"), "CostFunctionSoftmaxDescriptor", "");
		cl.def( pybind11::init<bool, int, class std::vector<struct VPUNN::VPUEMSoftmaxParamsDesciptor, class std::allocator<struct VPUNN::VPUEMSoftmaxParamsDesciptor> >>(), pybind11::arg("spatial"), pybind11::arg("simd"), pybind11::arg("functionParams") );

		cl.def( pybind11::init( [](VPUNN::CostFunctionSoftmaxDescriptor const &o){ return new VPUNN::CostFunctionSoftmaxDescriptor(o); } ) );
		cl.def_readwrite("spatial_", &VPUNN::CostFunctionSoftmaxDescriptor::spatial_);
		cl.def_readwrite("simd_", &VPUNN::CostFunctionSoftmaxDescriptor::simd_);
		cl.def_readwrite("functionParams_", &VPUNN::CostFunctionSoftmaxDescriptor::functionParams_);
		cl.def("assign", (struct VPUNN::CostFunctionSoftmaxDescriptor & (VPUNN::CostFunctionSoftmaxDescriptor::*)(const struct VPUNN::CostFunctionSoftmaxDescriptor &)) &VPUNN::CostFunctionSoftmaxDescriptor::operator=, "C++: VPUNN::CostFunctionSoftmaxDescriptor::operator=(const struct VPUNN::CostFunctionSoftmaxDescriptor &) --> struct VPUNN::CostFunctionSoftmaxDescriptor &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::CostFunctionSpatialDescriptor file: line:60
		pybind11::class_<VPUNN::CostFunctionSpatialDescriptor, std::shared_ptr<VPUNN::CostFunctionSpatialDescriptor>> cl(M("VPUNN"), "CostFunctionSpatialDescriptor", "");
		cl.def( pybind11::init( [](VPUNN::CostFunctionSpatialDescriptor const &o){ return new VPUNN::CostFunctionSpatialDescriptor(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::CostFunctionSpatialDescriptor(); } ) );
		cl.def_readwrite("C_divider", &VPUNN::CostFunctionSpatialDescriptor::C_divider);
		cl.def_readwrite("C_offset", &VPUNN::CostFunctionSpatialDescriptor::C_offset);
		cl.def_readwrite("C_factor", &VPUNN::CostFunctionSpatialDescriptor::C_factor);
		cl.def_readwrite("Order", &VPUNN::CostFunctionSpatialDescriptor::Order);
		cl.def_readwrite("slope", &VPUNN::CostFunctionSpatialDescriptor::slope);
		cl.def("assign", (struct VPUNN::CostFunctionSpatialDescriptor & (VPUNN::CostFunctionSpatialDescriptor::*)(const struct VPUNN::CostFunctionSpatialDescriptor &)) &VPUNN::CostFunctionSpatialDescriptor::operator=, "C++: VPUNN::CostFunctionSpatialDescriptor::operator=(const struct VPUNN::CostFunctionSpatialDescriptor &) --> struct VPUNN::CostFunctionSpatialDescriptor &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_52.cpp
#include <array> // std::array
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::char_traits
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_52(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::FirstDegreeEquation file: line:33
		pybind11::class_<VPUNN::FirstDegreeEquation, std::shared_ptr<VPUNN::FirstDegreeEquation>> cl(M("VPUNN"), "FirstDegreeEquation", "Defines the structure of the first degree equation of the line for each shave operation.\n The equation is slope_ * size + intercept_\n \n\n is defined by time in us divided by size of output bytes\n \n\n is defined  by time in us");
		cl.def( pybind11::init( [](VPUNN::FirstDegreeEquation const &o){ return new VPUNN::FirstDegreeEquation(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::FirstDegreeEquation(); } ) );
		cl.def_readwrite("slope_", &VPUNN::FirstDegreeEquation::slope_);
		cl.def_readwrite("intercept_", &VPUNN::FirstDegreeEquation::intercept_);
		cl.def("__call__", (float (VPUNN::FirstDegreeEquation::*)(const int &) const) &VPUNN::FirstDegreeEquation::operator(), "Overload for operator() which calculates the time based on the first degree equation of the Shave\n activation and the size in bytes of the output\n\n \n of output in bytes\n \n\n the time in us\n\nC++: VPUNN::FirstDegreeEquation::operator()(const int &) const --> float", pybind11::arg("size"));
		cl.def("assign", (class VPUNN::FirstDegreeEquation & (VPUNN::FirstDegreeEquation::*)(const class VPUNN::FirstDegreeEquation &)) &VPUNN::FirstDegreeEquation::operator=, "C++: VPUNN::FirstDegreeEquation::operator=(const class VPUNN::FirstDegreeEquation &) --> class VPUNN::FirstDegreeEquation &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VariableSlopeFirstDegreeEquation file: line:56
		pybind11::class_<VPUNN::VariableSlopeFirstDegreeEquation, std::shared_ptr<VPUNN::VariableSlopeFirstDegreeEquation>> cl(M("VPUNN"), "VariableSlopeFirstDegreeEquation", "Defines the structure of the first degree equation of the line for each shave operation.\n The ecuation is slope_ * size + intercept_\n \n\n is defined by time in us divided by size of output bytes\n \n\n is defined  by time in us");
		cl.def( pybind11::init( [](){ return new VPUNN::VariableSlopeFirstDegreeEquation(); } ) );
		cl.def( pybind11::init( [](VPUNN::VariableSlopeFirstDegreeEquation const &o){ return new VPUNN::VariableSlopeFirstDegreeEquation(o); } ) );
		cl.def_readwrite("slope_", &VPUNN::VariableSlopeFirstDegreeEquation::slope_);
		cl.def_readwrite("intercept_", &VPUNN::VariableSlopeFirstDegreeEquation::intercept_);
		cl.def_readwrite("alpha_", &VPUNN::VariableSlopeFirstDegreeEquation::alpha_);
		cl.def_readwrite("maximum_diff_slope", &VPUNN::VariableSlopeFirstDegreeEquation::maximum_diff_slope);
		cl.def("__call__", (float (VPUNN::VariableSlopeFirstDegreeEquation::*)(const int &, const int &) const) &VPUNN::VariableSlopeFirstDegreeEquation::operator(), "Overload for operator() which calculates the time based on the first degree equation of the Shave\n activation and the size of the output\n\n \n of output elements\n \n\n it is the special dimension's size that influences the slope\n \n\n the time in us\n\nC++: VPUNN::VariableSlopeFirstDegreeEquation::operator()(const int &, const int &) const --> float", pybind11::arg("size"), pybind11::arg("selected_dimension"));
		cl.def("getCoeff", (float (VPUNN::VariableSlopeFirstDegreeEquation::*)(const int &, const int &) const) &VPUNN::VariableSlopeFirstDegreeEquation::getCoeff, "C++: VPUNN::VariableSlopeFirstDegreeEquation::getCoeff(const int &, const int &) const --> float", pybind11::arg("size"), pybind11::arg("selected_dimension"));
		cl.def("getSlope", (float (VPUNN::VariableSlopeFirstDegreeEquation::*)(const float &) const) &VPUNN::VariableSlopeFirstDegreeEquation::getSlope, "C++: VPUNN::VariableSlopeFirstDegreeEquation::getSlope(const float &) const --> float", pybind11::arg("coeff"));
		cl.def("assign", (class VPUNN::VariableSlopeFirstDegreeEquation & (VPUNN::VariableSlopeFirstDegreeEquation::*)(const class VPUNN::VariableSlopeFirstDegreeEquation &)) &VPUNN::VariableSlopeFirstDegreeEquation::operator=, "C++: VPUNN::VariableSlopeFirstDegreeEquation::operator=(const class VPUNN::VariableSlopeFirstDegreeEquation &) --> class VPUNN::VariableSlopeFirstDegreeEquation &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq file: line:88
		pybind11::class_<VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq, std::shared_ptr<VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq>> cl(M("VPUNN"), "VariableSlopeMiddleCommonAxesFrstDegEq", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq(); } ) );
		cl.def( pybind11::init( [](VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq const &o){ return new VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq(o); } ) );
		cl.def_readwrite("best_case_slope", &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::best_case_slope);
		cl.def_readwrite("intercept", &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::intercept);
		cl.def_readwrite("worst_case_slope", &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::worst_case_slope);
		cl.def_readwrite("intermediate_case_slope", &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::intermediate_case_slope);
		cl.def("__call__", (float (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const int &, const struct std::array<int, 4> &) const) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::operator(), "Overload for operator() which calculates the time based on the first degree equation of the Shave\n activation and the size of the output\n\n \n of output elements\n \n\n it is the special dimension's size that influences the slope\n \n\n the time in us\n\nC++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::operator()(const int &, const struct std::array<int, 4> &) const --> float", pybind11::arg("size"), pybind11::arg("selected_dim"));
		cl.def("compute_worst_coeff", (float (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const int &, const int &) const) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::compute_worst_coeff, "C++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::compute_worst_coeff(const int &, const int &) const --> float", pybind11::arg("outermostDim"), pybind11::arg("totalVolume"));
		cl.def("compute_intermediate_coeff", (float (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const struct std::array<int, 4> &) const) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::compute_intermediate_coeff, "C++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::compute_intermediate_coeff(const struct std::array<int, 4> &) const --> float", pybind11::arg("selected_dim"));
		cl.def("get_slope", (float (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const struct std::array<float, 2> &) const) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::get_slope, "C++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::get_slope(const struct std::array<float, 2> &) const --> float", pybind11::arg("c"));
		cl.def("dim_val", (int (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const int &) const) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::dim_val, "filter not to let dimension smaller than 1. (like zero), destroy the selected volume\n\nC++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::dim_val(const int &) const --> int", pybind11::arg("dimension_value"));
		cl.def("volume_ratio", (float (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const float &, const float &) const) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::volume_ratio, "C++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::volume_ratio(const float &, const float &) const --> float", pybind11::arg("numerator"), pybind11::arg("denominator"));
		cl.def("assign", (class VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq & (VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::*)(const class VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq &)) &VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::operator=, "C++: VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq::operator=(const class VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq &) --> class VPUNN::VariableSlopeMiddleCommonAxesFrstDegEq &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VariableSlope4MultiAxesFrstDegEq file: line:149
		pybind11::class_<VPUNN::VariableSlope4MultiAxesFrstDegEq, std::shared_ptr<VPUNN::VariableSlope4MultiAxesFrstDegEq>> cl(M("VPUNN"), "VariableSlope4MultiAxesFrstDegEq", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VariableSlope4MultiAxesFrstDegEq(); } ) );
		cl.def( pybind11::init( [](VPUNN::VariableSlope4MultiAxesFrstDegEq const &o){ return new VPUNN::VariableSlope4MultiAxesFrstDegEq(o); } ) );
		cl.def_readwrite("best_case_slope", &VPUNN::VariableSlope4MultiAxesFrstDegEq::best_case_slope);
		cl.def_readwrite("intercept", &VPUNN::VariableSlope4MultiAxesFrstDegEq::intercept);
		cl.def_readwrite("alpha", &VPUNN::VariableSlope4MultiAxesFrstDegEq::alpha);
		cl.def_readwrite("worst_case_slope", &VPUNN::VariableSlope4MultiAxesFrstDegEq::worst_case_slope);
		cl.def_readwrite("slope_delta_diff", &VPUNN::VariableSlope4MultiAxesFrstDegEq::slope_delta_diff);
		cl.def("get_delta_max", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)() const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::get_delta_max, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::get_delta_max() const --> float");
		cl.def("__call__", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const int &, const struct std::array<int, 4> &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::operator(), "Overload for operator() which calculates the time based on the first degree equation of the Shave\n activation and the size of the output\n\n \n of output elements\n \n\n it is the special dimension's size that influences the slope\n \n\n the time in us\n\nC++: VPUNN::VariableSlope4MultiAxesFrstDegEq::operator()(const int &, const struct std::array<int, 4> &) const --> float", pybind11::arg("size"), pybind11::arg("selected_dim"));
		cl.def("compute_coef_0", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const int &, const int &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_0, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_0(const int &, const int &) const --> float", pybind11::arg("v_total"), pybind11::arg("v_selected"));
		cl.def("compute_coef_1", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const struct std::array<int, 4> &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_1, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_1(const struct std::array<int, 4> &) const --> float", pybind11::arg("sel_dim"));
		cl.def("compute_coef_2", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const struct std::array<int, 4> &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_2, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_2(const struct std::array<int, 4> &) const --> float", pybind11::arg("sel_dim"));
		cl.def("compute_coef_3", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const struct std::array<int, 4> &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_3, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::compute_coef_3(const struct std::array<int, 4> &) const --> float", pybind11::arg("sel_dim"));
		cl.def("get_slope", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const struct std::array<float, 4> &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::get_slope, "there are more variants to combine coefficients\n\nC++: VPUNN::VariableSlope4MultiAxesFrstDegEq::get_slope(const struct std::array<float, 4> &) const --> float", pybind11::arg("c"));
		cl.def("dim_val", (int (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const int &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::dim_val, "filter not to let dimension smaller than 1. (like zero), destroy the selected volume\n\nC++: VPUNN::VariableSlope4MultiAxesFrstDegEq::dim_val(const int &) const --> int", pybind11::arg("dimension_value"));
		cl.def("volume_ratio", (float (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const float &, const float &) const) &VPUNN::VariableSlope4MultiAxesFrstDegEq::volume_ratio, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::volume_ratio(const float &, const float &) const --> float", pybind11::arg("numerator"), pybind11::arg("denominator"));
		cl.def("assign", (class VPUNN::VariableSlope4MultiAxesFrstDegEq & (VPUNN::VariableSlope4MultiAxesFrstDegEq::*)(const class VPUNN::VariableSlope4MultiAxesFrstDegEq &)) &VPUNN::VariableSlope4MultiAxesFrstDegEq::operator=, "C++: VPUNN::VariableSlope4MultiAxesFrstDegEq::operator=(const class VPUNN::VariableSlope4MultiAxesFrstDegEq &) --> class VPUNN::VariableSlope4MultiAxesFrstDegEq &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::VariableSlope4MultiAxesFrstDegEq const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::VPUEMPiecewiseEq file: line:242
		pybind11::class_<VPUNN::VPUEMPiecewiseEq, std::shared_ptr<VPUNN::VPUEMPiecewiseEq>> cl(M("VPUNN"), "VPUEMPiecewiseEq", "");
		cl.def( pybind11::init<const struct VPUNN::CostFunction3SlopesDescriptor &>(), pybind11::arg("costFunction3SlopesData") );

		cl.def( pybind11::init( [](VPUNN::VPUEMPiecewiseEq const &o){ return new VPUNN::VPUEMPiecewiseEq(o); } ) );
		cl.def_readonly("costFunction3SlopesData_", &VPUNN::VPUEMPiecewiseEq::costFunction3SlopesData_);
		cl.def("compute_shave_cycles", (int (VPUNN::VPUEMPiecewiseEq::*)(enum VPUNN::DataType, const int, const float) const) &VPUNN::VPUEMPiecewiseEq::compute_shave_cycles, "C++: VPUNN::VPUEMPiecewiseEq::compute_shave_cycles(enum VPUNN::DataType, const int, const float) const --> int", pybind11::arg("dtype"), pybind11::arg("output_size_bytes"), pybind11::arg("cost_curve_ratio"));
	}
	{ // VPUNN::VPUEMSoftmaxEq file: line:276
		pybind11::class_<VPUNN::VPUEMSoftmaxEq, std::shared_ptr<VPUNN::VPUEMSoftmaxEq>> cl(M("VPUNN"), "VPUEMSoftmaxEq", "");
		cl.def( pybind11::init<const struct VPUNN::CostFunctionSoftmaxDescriptor &>(), pybind11::arg("costFunctionSoftmaxData") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSoftmaxEq const &o){ return new VPUNN::VPUEMSoftmaxEq(o); } ) );
		cl.def_readonly("costFunctionSoftmaxData_", &VPUNN::VPUEMSoftmaxEq::costFunctionSoftmaxData_);
		cl.def("compute_softmax_shave_cycles", [](VPUNN::VPUEMSoftmaxEq &o, enum VPUNN::DataType const & a0, const int & a1, const int & a2, const int & a3) -> int { return o.compute_softmax_shave_cycles(a0, a1, a2, a3); }, "", pybind11::arg("dtype"), pybind11::arg("h_output_size_bytes"), pybind11::arg("hw_output_size_bytes"), pybind11::arg("c_output_size_bytes"));
		cl.def("compute_softmax_shave_cycles", (int (VPUNN::VPUEMSoftmaxEq::*)(enum VPUNN::DataType, const int, const int, const int, float)) &VPUNN::VPUEMSoftmaxEq::compute_softmax_shave_cycles, "C++: VPUNN::VPUEMSoftmaxEq::compute_softmax_shave_cycles(enum VPUNN::DataType, const int, const int, const int, float) --> int", pybind11::arg("dtype"), pybind11::arg("h_output_size_bytes"), pybind11::arg("hw_output_size_bytes"), pybind11::arg("c_output_size_bytes"), pybind11::arg("cost_ratio"));
	}
	{ // VPUNN::VPUEMSpatialEq file: line:370
		pybind11::class_<VPUNN::VPUEMSpatialEq, std::shared_ptr<VPUNN::VPUEMSpatialEq>> cl(M("VPUNN"), "VPUEMSpatialEq", "");
		cl.def( pybind11::init<const struct VPUNN::CostFunctionSpatialDescriptor &>(), pybind11::arg("costFunctionSpatialData") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSpatialEq const &o){ return new VPUNN::VPUEMSpatialEq(o); } ) );
		cl.def_readonly("costFunctionSpatialData_", &VPUNN::VPUEMSpatialEq::costFunctionSpatialData_);
		cl.def("compute_spatial_shave_cycles", (int (VPUNN::VPUEMSpatialEq::*)(enum VPUNN::DataType, const int)) &VPUNN::VPUEMSpatialEq::compute_spatial_shave_cycles, "C++: VPUNN::VPUEMSpatialEq::compute_spatial_shave_cycles(enum VPUNN::DataType, const int) --> int", pybind11::arg("dtype"), pybind11::arg("output_size_bytes"));
	}
	{ // VPUNN::ShaveConverter file: line:20
		pybind11::class_<VPUNN::ShaveConverter, std::shared_ptr<VPUNN::ShaveConverter>> cl(M("VPUNN"), "ShaveConverter", "converts to Cycles knowing frequencies (at acquisition and at present intended  target)");
		cl.def( pybind11::init( [](VPUNN::ShaveConverter const &o){ return new VPUNN::ShaveConverter(o); } ) );
		cl.def_readonly("dpu_freq_", &VPUNN::ShaveConverter::dpu_freq_);
		cl.def_readonly("shv_freq_", &VPUNN::ShaveConverter::shv_freq_);
		cl.def("toDPUCycles", (unsigned int (VPUNN::ShaveConverter::*)(const float) const) &VPUNN::ShaveConverter::toDPUCycles, "Determines the number of cycles related to the profiling DPU freq,\n \n\n the number of cycles required based on CyclesInterfaceType\n\nC++: VPUNN::ShaveConverter::toDPUCycles(const float) const --> unsigned int", pybind11::arg("us"));
		cl.def("toDPUCycles", (unsigned int (VPUNN::ShaveConverter::*)(const float, const int) const) &VPUNN::ShaveConverter::toDPUCycles, "Determines the number of cycles related to the input value of a DPU freq given as a parameter\n\n \n the number of cycles required based on CyclesInterfaceType\n\nC++: VPUNN::ShaveConverter::toDPUCycles(const float, const int) const --> unsigned int", pybind11::arg("us"), pybind11::arg("present_dpu_frq"));
		cl.def("toDPUCycles", (unsigned int (VPUNN::ShaveConverter::*)(const float, const int, const int) const) &VPUNN::ShaveConverter::toDPUCycles, "Determines the number of cycles related to the input value of a DPU freq and SHV freq given as a\n parameter. In order to get accurate numbers we use a change factor based on the\n freq we made profile and the given value for the profiling\n\n \n the number of cycles required based on CyclesInterfaceType\n\nC++: VPUNN::ShaveConverter::toDPUCycles(const float, const int, const int) const --> unsigned int", pybind11::arg("us"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("toDPUCyclesFromShaveCycles", (unsigned int (VPUNN::ShaveConverter::*)(const int, const int, const int) const) &VPUNN::ShaveConverter::toDPUCyclesFromShaveCycles, "C++: VPUNN::ShaveConverter::toDPUCyclesFromShaveCycles(const int, const int, const int) const --> unsigned int", pybind11::arg("shaveCycles"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));

		cl.def("__str__", [](VPUNN::ShaveConverter const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
}


// File: VPUNN_53.cpp
#include <array> // std::array
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_53(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_GatherModel_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::GatherModel> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::*)(const int, const int, unsigned int, struct std::array<int, 4>) const) &VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int, std::array<int, 4>>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int, struct std::array<int, 4>) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_MVN6OneAxisModel_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::*)(const int, const int, unsigned int, unsigned int) const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int, unsigned int>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int, unsigned int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_MVN6MultiAxisModel_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>(o); } ) );
		cl.def("getDPUCycles", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::*)(unsigned int, struct std::array<int, 4>) const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getDPUCycles<unsigned int, std::array<int, 4>>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getDPUCycles(unsigned int, struct std::array<int, 4>) const --> unsigned int", pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::*)(const int, const int, unsigned int, struct std::array<int, 4>) const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int, std::array<int, 4>>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int, struct std::array<int, 4>) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_MVNSimple2and3AxisModel_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::*)(const int, const int, int, int, int, int) const) &VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::getDPUCyclesAnotherFreqDPU_SHV<int, int, int, int>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, int, int, int, int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_NormalizeL2OnlyC_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::*)(const int, const int, int, int, int) const) &VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::getDPUCyclesAnotherFreqDPU_SHV<int, int, int>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, int, int, int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_ShaveModel1to1_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::*)(const int, const int, unsigned int) const) &VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_ShaveModel1to1NPU40_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::*)(const int, const int, unsigned int) const) &VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_SoftmaxModel_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::*)(const int, const int, int, int) const) &VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::getDPUCyclesAnotherFreqDPU_SHV<int, int>, "C++: VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, int, int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::ShaveCyclesProvider file: line:75
		pybind11::class_<VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>, std::shared_ptr<VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>>> cl(M("VPUNN"), "ShaveCyclesProvider_VPUNN_InterpolateWHModel_1_t", "");
		cl.def( pybind11::init( [](VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1> const &o){ return new VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>(o); } ) );
		cl.def("getNominalDPUFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>::getNominalDPUFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>::*)() const) &VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>::getNominalSHVFrq, "C++: VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::VPUEMShaveCyclesProvider file: line:129
		pybind11::class_<VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>, std::shared_ptr<VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>>> cl(M("VPUNN"), "VPUEMShaveCyclesProvider_VPUNN_PiecewiseModel_t", "");
		cl.def( pybind11::init( [](VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel> const &o){ return new VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::*)(const int, const int, class VPUNN::SHAVEWorkload) const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::getDPUCyclesAnotherFreqDPU_SHV<VPUNN::SHAVEWorkload>, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, class VPUNN::SHAVEWorkload) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::*)() const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::getNominalDPUFrq, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::*)() const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::getNominalSHVFrq, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::VPUEMShaveCyclesProvider file: line:129
		pybind11::class_<VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>, std::shared_ptr<VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>>> cl(M("VPUNN"), "VPUEMShaveCyclesProvider_VPUNN_VPUEMSoftmaxModel_t", "");
		cl.def( pybind11::init( [](VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel> const &o){ return new VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::*)(const int, const int, unsigned int, unsigned int, unsigned int) const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int, unsigned int, unsigned int>, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int, unsigned int, unsigned int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"), pybind11::arg("args"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::*)() const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::getNominalDPUFrq, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::*)() const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::getNominalSHVFrq, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>::getNominalSHVFrq() const --> int");
	}
}


// File: VPUNN_54.cpp
#include <array> // std::array
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::MVN_GenericActivationExec file: line:586
struct PyCallBack_VPUNN_MVN_GenericActivationExec : public VPUNN::MVN_GenericActivationExec {
	using VPUNN::MVN_GenericActivationExec::MVN_GenericActivationExec;

	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MVN_GenericActivationExec *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return MVN_GenericActivationExec::dpuCycles(a0);
	}
	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0, const int a1, const int a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MVN_GenericActivationExec *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return MVN_GenericActivationExec::dpuCycles(a0, a1, a2);
	}
	std::string toString() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MVN_GenericActivationExec *>(this), "toString");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return MVN_GenericActivationExec::toString();
	}
	std::string getName() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MVN_GenericActivationExec *>(this), "getName");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return ShaveOpExecutor::getName();
	}
};

void bind_VPUNN_54(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPUEMShaveCyclesProvider file: line:129
		pybind11::class_<VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>, std::shared_ptr<VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>>> cl(M("VPUNN"), "VPUEMShaveCyclesProvider_VPUNN_VPUEMSpatialModel_t", "");
		cl.def( pybind11::init( [](VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel> const &o){ return new VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>(o); } ) );
		cl.def("getDPUCyclesAnotherFreqDPU_SHV", (unsigned int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::*)(const int, const int, unsigned int) const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::getDPUCyclesAnotherFreqDPU_SHV<unsigned int>, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::getDPUCyclesAnotherFreqDPU_SHV(const int, const int, unsigned int) const --> unsigned int", pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("args"));
		cl.def("getNominalDPUFrq", (int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::*)() const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::getNominalDPUFrq, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::getNominalDPUFrq() const --> int");
		cl.def("getNominalSHVFrq", (int (VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::*)() const) &VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::getNominalSHVFrq, "C++: VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>::getNominalSHVFrq() const --> int");
	}
	{ // VPUNN::GatherModel file: line:25
		pybind11::class_<VPUNN::GatherModel, std::shared_ptr<VPUNN::GatherModel>, VPUNN::ShaveCyclesProvider<VPUNN::GatherModel>> cl(M("VPUNN"), "GatherModel", "");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, float, unsigned int, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("baseSlope"), pybind11::arg("baseIntercept"), pybind11::arg("worstSlope"), pybind11::arg("interSlope"), pybind11::arg("vectorOffset"), pybind11::arg("vector_size"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::GatherModel const &o){ return new VPUNN::GatherModel(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::GatherModel::*)(const int &, const struct std::array<int, 4> &) const) &VPUNN::GatherModel::getMicroSeconds, "C++: VPUNN::GatherModel::getMicroSeconds(const int &, const struct std::array<int, 4> &) const --> float", pybind11::arg("output_size_samples"), pybind11::arg("dimensions_size"));

		cl.def("__str__", [](VPUNN::GatherModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::MVN6OneAxisModel file: line:26
		pybind11::class_<VPUNN::MVN6OneAxisModel, std::shared_ptr<VPUNN::MVN6OneAxisModel>, VPUNN::ShaveCyclesProvider<VPUNN::MVN6OneAxisModel>> cl(M("VPUNN"), "MVN6OneAxisModel", "");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("slope"), pybind11::arg("intercept"), pybind11::arg("alpha"), pybind11::arg("maximum_diff_slope"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::MVN6OneAxisModel const &o){ return new VPUNN::MVN6OneAxisModel(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::MVN6OneAxisModel::*)(const int &, const int &) const) &VPUNN::MVN6OneAxisModel::getMicroSeconds, "gets us time, specific parameters\n\n \n the time in us\n\nC++: VPUNN::MVN6OneAxisModel::getMicroSeconds(const int &, const int &) const --> float", pybind11::arg("output_size_samples"), pybind11::arg("selected_dimension_size"));

		cl.def("__str__", [](VPUNN::MVN6OneAxisModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::MVN6MultiAxisModel file: line:67
		pybind11::class_<VPUNN::MVN6MultiAxisModel, std::shared_ptr<VPUNN::MVN6MultiAxisModel>, VPUNN::ShaveCyclesProvider<VPUNN::MVN6MultiAxisModel>> cl(M("VPUNN"), "MVN6MultiAxisModel", "MOdel for MVN 6 with 1,2,3,4 axis selected,\n the axis are always innermost");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, float, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("best_slope"), pybind11::arg("intercept"), pybind11::arg("alpha"), pybind11::arg("worst_case_slope"), pybind11::arg("slope_delta_diff"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::MVN6MultiAxisModel const &o){ return new VPUNN::MVN6MultiAxisModel(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::MVN6MultiAxisModel::*)(const int &, const struct std::array<int, 4> &) const) &VPUNN::MVN6MultiAxisModel::getMicroSeconds, "Get the time in us for the the activation based on the output size in bytes\n\n \n the time in us\n\nC++: VPUNN::MVN6MultiAxisModel::getMicroSeconds(const int &, const struct std::array<int, 4> &) const --> float", pybind11::arg("output_size_samples"), pybind11::arg("selected_dimensions_size"));

		cl.def("__str__", [](VPUNN::MVN6MultiAxisModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::MVNSimple2and3AxisModel file: line:111
		pybind11::class_<VPUNN::MVNSimple2and3AxisModel, std::shared_ptr<VPUNN::MVNSimple2and3AxisModel>, VPUNN::ShaveCyclesProvider<VPUNN::MVNSimple2and3AxisModel>> cl(M("VPUNN"), "MVNSimple2and3AxisModel", "");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, float, float, unsigned int, unsigned int, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("baseSlope"), pybind11::arg("baseIntercept"), pybind11::arg("thirdMostSupportSlope"), pybind11::arg("baseSupportSlope"), pybind11::arg("mod8SupportSlope"), pybind11::arg("vectorSlope"), pybind11::arg("vector_size"), pybind11::arg("unroll_size"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::MVNSimple2and3AxisModel const &o){ return new VPUNN::MVNSimple2and3AxisModel(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::MVNSimple2and3AxisModel::*)(const int &, const int &, const int &, const int &) const) &VPUNN::MVNSimple2and3AxisModel::getMicroSeconds, "Get the time in us for the activation based on formula. FOr Special 2dim or 3dim MVN.\n At least first 2 dims are selected\n Third dim might be selected or not, the formula can cancel the term of third dim by setting the slope =0\n Fourth dim is always unselected.\n\n \n the time in us\n\nC++: VPUNN::MVNSimple2and3AxisModel::getMicroSeconds(const int &, const int &, const int &, const int &) const --> float", pybind11::arg("selected_volume"), pybind11::arg("un_selected_volume"), pybind11::arg("outermost_dimension"), pybind11::arg("thirdmost_dimension"));

		cl.def("__str__", [](VPUNN::MVNSimple2and3AxisModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::NormalizeL2OnlyC file: line:29
		pybind11::class_<VPUNN::NormalizeL2OnlyC, std::shared_ptr<VPUNN::NormalizeL2OnlyC>, VPUNN::ShaveCyclesProvider<VPUNN::NormalizeL2OnlyC>> cl(M("VPUNN"), "NormalizeL2OnlyC", "This implementation reflects the NormalizeL2 activation operation time when the selected axes for\n normalization are only the Channels");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, float, float, float, float, float, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("baseTimeSlope"), pybind11::arg("baseTimeIntercept"), pybind11::arg("baseVectorOffset"), pybind11::arg("baseTimeSlopeW"), pybind11::arg("baseTimeInterceptW"), pybind11::arg("slopeW1"), pybind11::arg("slopeW8"), pybind11::arg("slopeW9"), pybind11::arg("baseVectorOffsetW"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::NormalizeL2OnlyC const &o){ return new VPUNN::NormalizeL2OnlyC(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::NormalizeL2OnlyC::*)(const int &, const int &, const int &) const) &VPUNN::NormalizeL2OnlyC::getMicroSeconds, "Get the time in us for the the activation based on the output size in bytes\n\n \n the time in us\n\nC++: VPUNN::NormalizeL2OnlyC::getMicroSeconds(const int &, const int &, const int &) const --> float", pybind11::arg("channels_elements"), pybind11::arg("width_elements"), pybind11::arg("rem_elements"));

		cl.def("__str__", [](VPUNN::NormalizeL2OnlyC const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::ShaveModel1to1 file: line:27
		pybind11::class_<VPUNN::ShaveModel1to1, std::shared_ptr<VPUNN::ShaveModel1to1>, VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1>> cl(M("VPUNN"), "ShaveModel1to1", "");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, unsigned int, unsigned int, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("slope"), pybind11::arg("intercept"), pybind11::arg("offset_scalar"), pybind11::arg("offset_unroll"), pybind11::arg("VectorSize"), pybind11::arg("UnrollSize"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::ShaveModel1to1 const &o){ return new VPUNN::ShaveModel1to1(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::ShaveModel1to1::*)(const int &) const) &VPUNN::ShaveModel1to1::getMicroSeconds, "Get the time in us for the the activation based on the output size in bytes\n\n \n the time in us\n\nC++: VPUNN::ShaveModel1to1::getMicroSeconds(const int &) const --> float", pybind11::arg("output_size_bytes"));

		cl.def("__str__", [](VPUNN::ShaveModel1to1 const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::ShaveModel1to1NPU40 file: line:163
		pybind11::class_<VPUNN::ShaveModel1to1NPU40, std::shared_ptr<VPUNN::ShaveModel1to1NPU40>, VPUNN::ShaveCyclesProvider<VPUNN::ShaveModel1to1NPU40>> cl(M("VPUNN"), "ShaveModel1to1NPU40", "TODO: Refactor idea in here, quite similar code\n For NPU40 we observed a different behaviour for our simple models\n This class have the role to modelate the new discovered behaviour");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, float, float, float, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("slope"), pybind11::arg("intercept"), pybind11::arg("offset_unroll"), pybind11::arg("intra_block_offset"), pybind11::arg("vector_offset"), pybind11::arg("displacement_size"), pybind11::arg("VectorSize"), pybind11::arg("UnrollSize"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::ShaveModel1to1NPU40 const &o){ return new VPUNN::ShaveModel1to1NPU40(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::ShaveModel1to1NPU40::*)(const int &) const) &VPUNN::ShaveModel1to1NPU40::getMicroSeconds, "Get the time in us for the the activation based on the output size in bytes\n\n \n the time in us\n\nC++: VPUNN::ShaveModel1to1NPU40::getMicroSeconds(const int &) const --> float", pybind11::arg("output_size_bytes"));

		cl.def("__str__", [](VPUNN::ShaveModel1to1NPU40 const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	// VPUNN::SoftmaxEquationType file: line:26
	pybind11::enum_<VPUNN::SoftmaxEquationType>(M("VPUNN"), "SoftmaxEquationType", "Enum class for the different types of softmax equations")
		.value("Type1", VPUNN::SoftmaxEquationType::Type1)
		.value("Type2", VPUNN::SoftmaxEquationType::Type2)
		.value("Type4", VPUNN::SoftmaxEquationType::Type4)
		.value("Type8", VPUNN::SoftmaxEquationType::Type8)
		.value("Type16", VPUNN::SoftmaxEquationType::Type16)
		.value("Type32", VPUNN::SoftmaxEquationType::Type32);

;

	{ // VPUNN::SoftmaxEquationParams file: line:45
		pybind11::class_<VPUNN::SoftmaxEquationParams, std::shared_ptr<VPUNN::SoftmaxEquationParams>> cl(M("VPUNN"), "SoftmaxEquationParams", "Struct for the parameters of a softmax equation for different types of unselected dimensions");
		cl.def( pybind11::init( [](){ return new VPUNN::SoftmaxEquationParams(); } ) );
		cl.def( pybind11::init( [](VPUNN::SoftmaxEquationParams const &o){ return new VPUNN::SoftmaxEquationParams(o); } ) );
		cl.def_readwrite("slopeEquation", &VPUNN::SoftmaxEquationParams::slopeEquation);
		cl.def_readwrite("interceptEquation", &VPUNN::SoftmaxEquationParams::interceptEquation);
		cl.def("assign", (class VPUNN::SoftmaxEquationParams & (VPUNN::SoftmaxEquationParams::*)(const class VPUNN::SoftmaxEquationParams &)) &VPUNN::SoftmaxEquationParams::operator=, "C++: VPUNN::SoftmaxEquationParams::operator=(const class VPUNN::SoftmaxEquationParams &) --> class VPUNN::SoftmaxEquationParams &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::SoftmaxModel file: line:52
		pybind11::class_<VPUNN::SoftmaxModel, std::shared_ptr<VPUNN::SoftmaxModel>, VPUNN::ShaveCyclesProvider<VPUNN::SoftmaxModel>> cl(M("VPUNN"), "SoftmaxModel", "");
		cl.def( pybind11::init<enum VPUNN::DataType, float, float, class VPUNN::SoftmaxEquationParams, class VPUNN::SoftmaxEquationParams, class VPUNN::SoftmaxEquationParams, class VPUNN::SoftmaxEquationParams, class VPUNN::SoftmaxEquationParams, class VPUNN::SoftmaxEquationParams, unsigned int, unsigned int>(), pybind11::arg("dataType"), pybind11::arg("baseSlope"), pybind11::arg("baseIntercept"), pybind11::arg("e1"), pybind11::arg("e2"), pybind11::arg("e4"), pybind11::arg("e8"), pybind11::arg("e16"), pybind11::arg("e32"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::SoftmaxModel const &o){ return new VPUNN::SoftmaxModel(o); } ) );
		cl.def("getMicroSeconds", (float (VPUNN::SoftmaxModel::*)(const int &, const int &) const) &VPUNN::SoftmaxModel::getMicroSeconds, "Returns the time based on the selected and unselected time.\n\n \n the time in us\n\nC++: VPUNN::SoftmaxModel::getMicroSeconds(const int &, const int &) const --> float", pybind11::arg("selected_dimension_size"), pybind11::arg("unselected_dimension_size"));

		cl.def("__str__", [](VPUNN::SoftmaxModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::InterpolateWHModel_1 file: line:26
		pybind11::class_<VPUNN::InterpolateWHModel_1, std::shared_ptr<VPUNN::InterpolateWHModel_1>, VPUNN::ShaveCyclesProvider<VPUNN::InterpolateWHModel_1>> cl(M("VPUNN"), "InterpolateWHModel_1", "");
		cl.def( pybind11::init<enum VPUNN::DataType, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::InterpolateWHModel_1 const &o){ return new VPUNN::InterpolateWHModel_1(o); } ) );
		cl.def_readonly("formula", &VPUNN::InterpolateWHModel_1::formula);
		cl.def("getMicroSeconds", (float (VPUNN::InterpolateWHModel_1::*)(const int &, const int &, const int &) const) &VPUNN::InterpolateWHModel_1::getMicroSeconds, "gets us time, specific parameters\n\n \n the time in us\n\nC++: VPUNN::InterpolateWHModel_1::getMicroSeconds(const int &, const int &, const int &) const --> float", pybind11::arg("wi"), pybind11::arg("hi"), pybind11::arg("out_size"));

		cl.def("__str__", [](VPUNN::InterpolateWHModel_1 const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::MVN6Parameters file: line:339
		pybind11::class_<VPUNN::MVN6Parameters, std::shared_ptr<VPUNN::MVN6Parameters>> cl(M("VPUNN"), "MVN6Parameters", "");
		cl.def( pybind11::init( [](){ return new VPUNN::MVN6Parameters(); } ) );
		cl.def_readwrite("slope", &VPUNN::MVN6Parameters::slope);
		cl.def_readwrite("intercept", &VPUNN::MVN6Parameters::intercept);
		cl.def_readwrite("alpha", &VPUNN::MVN6Parameters::alpha);
		cl.def_readwrite("worst_case_slope", &VPUNN::MVN6Parameters::worst_case_slope);
		cl.def_readwrite("slope_delta_diff", &VPUNN::MVN6Parameters::slope_delta_diff);
	}
	{ // VPUNN::MVN_GenericActivationExec file: line:586
		pybind11::class_<VPUNN::MVN_GenericActivationExec, std::shared_ptr<VPUNN::MVN_GenericActivationExec>, PyCallBack_VPUNN_MVN_GenericActivationExec, VPUNN::ShaveOpExecutor> cl(M("VPUNN"), "MVN_GenericActivationExec", "COMPOSITE MVN");
		cl.def( pybind11::init<const std::string &, const class VPUNN::ShaveOpExecutor &, const class VPUNN::ShaveOpExecutor &, const class VPUNN::ShaveOpExecutor &>(), pybind11::arg("name"), pybind11::arg("r_mvn_s2"), pybind11::arg("r_mvn_s3"), pybind11::arg("r_mvn6") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_MVN_GenericActivationExec const &o){ return new PyCallBack_VPUNN_MVN_GenericActivationExec(o); } ) );
		cl.def( pybind11::init( [](VPUNN::MVN_GenericActivationExec const &o){ return new VPUNN::MVN_GenericActivationExec(o); } ) );
		cl.def("dpuCycles", (unsigned int (VPUNN::MVN_GenericActivationExec::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::MVN_GenericActivationExec::dpuCycles, "C++: VPUNN::MVN_GenericActivationExec::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("dpuCycles", (unsigned int (VPUNN::MVN_GenericActivationExec::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::MVN_GenericActivationExec::dpuCycles, "C++: VPUNN::MVN_GenericActivationExec::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("dpuCycles", (unsigned int (VPUNN::MVN_GenericActivationExec::*)(const class VPUNN::SHAVEWorkload &, const int, const int, bool) const) &VPUNN::MVN_GenericActivationExec::dpuCycles, "C++: VPUNN::MVN_GenericActivationExec::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int, bool) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"), pybind11::arg("nominal_freqs"));
		cl.def("toString", (std::string (VPUNN::MVN_GenericActivationExec::*)() const) &VPUNN::MVN_GenericActivationExec::toString, "C++: VPUNN::MVN_GenericActivationExec::toString() const --> std::string");
	}
}


// File: VPUNN_55.cpp
#include <array> // std::array
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::NPUMockExecutor file: line:663
struct PyCallBack_VPUNN_NPUMockExecutor_1700_971_t : public VPUNN::NPUMockExecutor<1700,971> {
	using VPUNN::NPUMockExecutor<1700,971>::NPUMockExecutor;

	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1700,971> *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return NPUMockExecutor::dpuCycles(a0);
	}
	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0, const int a1, const int a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1700,971> *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return NPUMockExecutor::dpuCycles(a0, a1, a2);
	}
	std::string toString() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1700,971> *>(this), "toString");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return NPUMockExecutor::toString();
	}
	std::string getName() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1700,971> *>(this), "getName");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return ShaveOpExecutor::getName();
	}
};

// VPUNN::NPUMockExecutor file: line:663
struct PyCallBack_VPUNN_NPUMockExecutor_1950_1114_t : public VPUNN::NPUMockExecutor<1950,1114> {
	using VPUNN::NPUMockExecutor<1950,1114>::NPUMockExecutor;

	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1950,1114> *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return NPUMockExecutor::dpuCycles(a0);
	}
	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0, const int a1, const int a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1950,1114> *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return NPUMockExecutor::dpuCycles(a0, a1, a2);
	}
	std::string toString() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1950,1114> *>(this), "toString");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return NPUMockExecutor::toString();
	}
	std::string getName() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1950,1114> *>(this), "getName");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return ShaveOpExecutor::getName();
	}
};

// VPUNN::NPUMockExecutor file: line:663
struct PyCallBack_VPUNN_NPUMockExecutor_1_1_t : public VPUNN::NPUMockExecutor<1,1> {
	using VPUNN::NPUMockExecutor<1,1>::NPUMockExecutor;

	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1,1> *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return NPUMockExecutor::dpuCycles(a0);
	}
	unsigned int dpuCycles(const class VPUNN::SHAVEWorkload & a0, const int a1, const int a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1,1> *>(this), "dpuCycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return NPUMockExecutor::dpuCycles(a0, a1, a2);
	}
	std::string toString() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1,1> *>(this), "toString");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return NPUMockExecutor::toString();
	}
	std::string getName() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::NPUMockExecutor<1,1> *>(this), "getName");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<std::string>::value) {
				static pybind11::detail::override_caster_t<std::string> caster;
				return pybind11::detail::cast_ref<std::string>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<std::string>(std::move(o));
		}
		return ShaveOpExecutor::getName();
	}
};

void bind_VPUNN_55(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::NPUMockExecutor file: line:663
		pybind11::class_<VPUNN::NPUMockExecutor<1700,971>, std::shared_ptr<VPUNN::NPUMockExecutor<1700,971>>, PyCallBack_VPUNN_NPUMockExecutor_1700_971_t, VPUNN::ShaveOpExecutor> cl(M("VPUNN"), "NPUMockExecutor_1700_971_t", "");
		cl.def( pybind11::init<const std::string &, const class VPUNN::ShaveOpExecutor &, float>(), pybind11::arg("name"), pybind11::arg("npu_original"), pybind11::arg("speed_up") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_NPUMockExecutor_1700_971_t const &o){ return new PyCallBack_VPUNN_NPUMockExecutor_1700_971_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::NPUMockExecutor<1700,971> const &o){ return new VPUNN::NPUMockExecutor<1700,971>(o); } ) );
		cl.def("dpuCycles", (unsigned int (VPUNN::NPUMockExecutor<1700,971>::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::NPUMockExecutor<1700, 971>::dpuCycles, "C++: VPUNN::NPUMockExecutor<1700, 971>::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("dpuCycles", (unsigned int (VPUNN::NPUMockExecutor<1700,971>::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::NPUMockExecutor<1700, 971>::dpuCycles, "C++: VPUNN::NPUMockExecutor<1700, 971>::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("toString", (std::string (VPUNN::NPUMockExecutor<1700,971>::*)() const) &VPUNN::NPUMockExecutor<1700, 971>::toString, "C++: VPUNN::NPUMockExecutor<1700, 971>::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n\n \n cycles in dpu frequency\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("getName", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getName, "the name of the modeled SHAVE function\n\nC++: VPUNN::ShaveOpExecutor::getName() const --> std::string");
		cl.def("toString", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::toString, "provides a string with details of implementation, name parameters, frequencies, etc\n\nC++: VPUNN::ShaveOpExecutor::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation considering that the nominal freq were altered with the\n passed ones as params\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n \n\n  the new DPU freq\n \n\n the new shave (VPU) freq\n\n \n cycles in dpu frequency as specified by present_dpu_frq\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("getNumExpectedParams", (unsigned int (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getNumExpectedParams, "C++: VPUNN::ShaveOpExecutor::getNumExpectedParams() const --> unsigned int");
	}
	{ // VPUNN::NPUMockExecutor file: line:663
		pybind11::class_<VPUNN::NPUMockExecutor<1950,1114>, std::shared_ptr<VPUNN::NPUMockExecutor<1950,1114>>, PyCallBack_VPUNN_NPUMockExecutor_1950_1114_t, VPUNN::ShaveOpExecutor> cl(M("VPUNN"), "NPUMockExecutor_1950_1114_t", "");
		cl.def( pybind11::init<const std::string &, const class VPUNN::ShaveOpExecutor &, float>(), pybind11::arg("name"), pybind11::arg("npu_original"), pybind11::arg("speed_up") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_NPUMockExecutor_1950_1114_t const &o){ return new PyCallBack_VPUNN_NPUMockExecutor_1950_1114_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::NPUMockExecutor<1950,1114> const &o){ return new VPUNN::NPUMockExecutor<1950,1114>(o); } ) );
		cl.def("dpuCycles", (unsigned int (VPUNN::NPUMockExecutor<1950,1114>::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::NPUMockExecutor<1950, 1114>::dpuCycles, "C++: VPUNN::NPUMockExecutor<1950, 1114>::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("dpuCycles", (unsigned int (VPUNN::NPUMockExecutor<1950,1114>::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::NPUMockExecutor<1950, 1114>::dpuCycles, "C++: VPUNN::NPUMockExecutor<1950, 1114>::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("toString", (std::string (VPUNN::NPUMockExecutor<1950,1114>::*)() const) &VPUNN::NPUMockExecutor<1950, 1114>::toString, "C++: VPUNN::NPUMockExecutor<1950, 1114>::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n\n \n cycles in dpu frequency\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("getName", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getName, "the name of the modeled SHAVE function\n\nC++: VPUNN::ShaveOpExecutor::getName() const --> std::string");
		cl.def("toString", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::toString, "provides a string with details of implementation, name parameters, frequencies, etc\n\nC++: VPUNN::ShaveOpExecutor::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation considering that the nominal freq were altered with the\n passed ones as params\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n \n\n  the new DPU freq\n \n\n the new shave (VPU) freq\n\n \n cycles in dpu frequency as specified by present_dpu_frq\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("getNumExpectedParams", (unsigned int (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getNumExpectedParams, "C++: VPUNN::ShaveOpExecutor::getNumExpectedParams() const --> unsigned int");
	}
	{ // VPUNN::NPUMockExecutor file: line:663
		pybind11::class_<VPUNN::NPUMockExecutor<1,1>, std::shared_ptr<VPUNN::NPUMockExecutor<1,1>>, PyCallBack_VPUNN_NPUMockExecutor_1_1_t, VPUNN::ShaveOpExecutor> cl(M("VPUNN"), "NPUMockExecutor_1_1_t", "");
		cl.def( pybind11::init<const std::string &, const class VPUNN::ShaveOpExecutor &, float>(), pybind11::arg("name"), pybind11::arg("npu_original"), pybind11::arg("speed_up") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_NPUMockExecutor_1_1_t const &o){ return new PyCallBack_VPUNN_NPUMockExecutor_1_1_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::NPUMockExecutor<1,1> const &o){ return new VPUNN::NPUMockExecutor<1,1>(o); } ) );
		cl.def("dpuCycles", (unsigned int (VPUNN::NPUMockExecutor<1,1>::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::NPUMockExecutor<1, 1>::dpuCycles, "C++: VPUNN::NPUMockExecutor<1, 1>::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("dpuCycles", (unsigned int (VPUNN::NPUMockExecutor<1,1>::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::NPUMockExecutor<1, 1>::dpuCycles, "C++: VPUNN::NPUMockExecutor<1, 1>::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("toString", (std::string (VPUNN::NPUMockExecutor<1,1>::*)() const) &VPUNN::NPUMockExecutor<1, 1>::toString, "C++: VPUNN::NPUMockExecutor<1, 1>::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n\n \n cycles in dpu frequency\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("w"));
		cl.def("getName", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getName, "the name of the modeled SHAVE function\n\nC++: VPUNN::ShaveOpExecutor::getName() const --> std::string");
		cl.def("toString", (std::string (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::toString, "provides a string with details of implementation, name parameters, frequencies, etc\n\nC++: VPUNN::ShaveOpExecutor::toString() const --> std::string");
		cl.def("dpuCycles", (unsigned int (VPUNN::ShaveOpExecutor::*)(const class VPUNN::SHAVEWorkload &, const int, const int) const) &VPUNN::ShaveOpExecutor::dpuCycles, "Return the number of cycles of the sw operation considering that the nominal freq were altered with the\n passed ones as params\n\n \n the workload descriptor. Some fields may be ignored . Eg even if the Device is not matching the one that\n the model was built for, it will run the estimation as if it had a good device in workload\n \n\n  the new DPU freq\n \n\n the new shave (VPU) freq\n\n \n cycles in dpu frequency as specified by present_dpu_frq\n\nC++: VPUNN::ShaveOpExecutor::dpuCycles(const class VPUNN::SHAVEWorkload &, const int, const int) const --> unsigned int", pybind11::arg("w"), pybind11::arg("present_dpu_frq"), pybind11::arg("present_shv_frq"));
		cl.def("getNumExpectedParams", (unsigned int (VPUNN::ShaveOpExecutor::*)() const) &VPUNN::ShaveOpExecutor::getNumExpectedParams, "C++: VPUNN::ShaveOpExecutor::getNumExpectedParams() const --> unsigned int");
	}
	{ // VPUNN::VPUEM_CostFunction file: line:10
		pybind11::class_<VPUNN::VPUEM_CostFunction, std::shared_ptr<VPUNN::VPUEM_CostFunction>> cl(M("VPUNN"), "VPUEM_CostFunction", "");
		cl.def( pybind11::init<const struct VPUNN::CostFunction3SlopesDescriptor &>(), pybind11::arg("costFunction3SlopesData") );

		cl.def( pybind11::init( [](VPUNN::VPUEM_CostFunction const &o){ return new VPUNN::VPUEM_CostFunction(o); } ) );
		cl.def_readonly("costFunction3SlopesData_", &VPUNN::VPUEM_CostFunction::costFunction3SlopesData_);
		cl.def_readonly("piecewiseEq_", &VPUNN::VPUEM_CostFunction::piecewiseEq_);
		cl.def("getCycles", (int (VPUNN::VPUEM_CostFunction::*)(enum VPUNN::DataType, const int, const float) const) &VPUNN::VPUEM_CostFunction::getCycles, "C++: VPUNN::VPUEM_CostFunction::getCycles(enum VPUNN::DataType, const int, const float) const --> int", pybind11::arg("dtype"), pybind11::arg("output_size_bytes"), pybind11::arg("cost_curve_ratio"));
	}
	{ // VPUNN::VPUEMSoftmax_CostFunction file: line:26
		pybind11::class_<VPUNN::VPUEMSoftmax_CostFunction, std::shared_ptr<VPUNN::VPUEMSoftmax_CostFunction>> cl(M("VPUNN"), "VPUEMSoftmax_CostFunction", "");
		cl.def( pybind11::init<const struct VPUNN::CostFunctionSoftmaxDescriptor &>(), pybind11::arg("costFunctionSoftmaxData") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSoftmax_CostFunction const &o){ return new VPUNN::VPUEMSoftmax_CostFunction(o); } ) );
		cl.def_readonly("costFunctionSoftmaxData_", &VPUNN::VPUEMSoftmax_CostFunction::costFunctionSoftmaxData_);
		cl.def("getCycles", (int (VPUNN::VPUEMSoftmax_CostFunction::*)(enum VPUNN::DataType, const int, const int, const int) const) &VPUNN::VPUEMSoftmax_CostFunction::getCycles, "C++: VPUNN::VPUEMSoftmax_CostFunction::getCycles(enum VPUNN::DataType, const int, const int, const int) const --> int", pybind11::arg("dtype"), pybind11::arg("h_output_size_bytes"), pybind11::arg("hw_output_size_bytes"), pybind11::arg("c_output_size_bytes"));
	}
	{ // VPUNN::VPUEMSpatial_CostFunction file: line:41
		pybind11::class_<VPUNN::VPUEMSpatial_CostFunction, std::shared_ptr<VPUNN::VPUEMSpatial_CostFunction>> cl(M("VPUNN"), "VPUEMSpatial_CostFunction", "");
		cl.def( pybind11::init<const struct VPUNN::CostFunctionSpatialDescriptor &>(), pybind11::arg("costFunctionSpatialData") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSpatial_CostFunction const &o){ return new VPUNN::VPUEMSpatial_CostFunction(o); } ) );
		cl.def_readonly("costFunctionSpatialData_", &VPUNN::VPUEMSpatial_CostFunction::costFunctionSpatialData_);
		cl.def("getCycles", (int (VPUNN::VPUEMSpatial_CostFunction::*)(enum VPUNN::DataType, int) const) &VPUNN::VPUEMSpatial_CostFunction::getCycles, "C++: VPUNN::VPUEMSpatial_CostFunction::getCycles(enum VPUNN::DataType, int) const --> int", pybind11::arg("dtype"), pybind11::arg("output_size_bytes"));
	}
	{ // VPUNN::VPUEM_OpBaseDSP file: line:12
		pybind11::class_<VPUNN::VPUEM_OpBaseDSP, std::shared_ptr<VPUNN::VPUEM_OpBaseDSP>> cl(M("VPUNN"), "VPUEM_OpBaseDSP", "");
		cl.def( pybind11::init( [](class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > const & a0, class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > const & a1){ return new VPUNN::VPUEM_OpBaseDSP(a0, a1); } ), "doc" , pybind11::arg("inputs"), pybind11::arg("outputs"));
		cl.def( pybind11::init( [](class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > const & a0, class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > const & a1, bool const & a2){ return new VPUNN::VPUEM_OpBaseDSP(a0, a1, a2); } ), "doc" , pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("adaptive_blk_num_en"));
		cl.def( pybind11::init( [](class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > const & a0, class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > const & a1, bool const & a2, int const & a3){ return new VPUNN::VPUEM_OpBaseDSP(a0, a1, a2, a3); } ), "doc" , pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("adaptive_blk_num_en"), pybind11::arg("max_blk_num"));
		cl.def( pybind11::init<class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> >, class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> >, bool, int, int>(), pybind11::arg("inputs"), pybind11::arg("outputs"), pybind11::arg("adaptive_blk_num_en"), pybind11::arg("max_blk_num"), pybind11::arg("dspArch") );

		cl.def( pybind11::init( [](VPUNN::VPUEM_OpBaseDSP const &o){ return new VPUNN::VPUEM_OpBaseDSP(o); } ) );
		cl.def("setup_dsp", (void (VPUNN::VPUEM_OpBaseDSP::*)()) &VPUNN::VPUEM_OpBaseDSP::setup_dsp, "C++: VPUNN::VPUEM_OpBaseDSP::setup_dsp() --> void");
		cl.def("get_max_blk_num", (int (VPUNN::VPUEM_OpBaseDSP::*)()) &VPUNN::VPUEM_OpBaseDSP::get_max_blk_num, "C++: VPUNN::VPUEM_OpBaseDSP::get_max_blk_num() --> int");
	}
	{ // VPUNN::VPUEM_Subblk_Tensor file: line:23
		pybind11::class_<VPUNN::VPUEM_Subblk_Tensor, std::shared_ptr<VPUNN::VPUEM_Subblk_Tensor>> cl(M("VPUNN"), "VPUEM_Subblk_Tensor", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUEM_Subblk_Tensor(); } ), "doc" );
		cl.def( pybind11::init( [](const struct std::array<int, 3> & a0){ return new VPUNN::VPUEM_Subblk_Tensor(a0); } ), "doc" , pybind11::arg("shape"));
		cl.def( pybind11::init( [](const struct std::array<int, 3> & a0, enum VPUNN::DataType const & a1){ return new VPUNN::VPUEM_Subblk_Tensor(a0, a1); } ), "doc" , pybind11::arg("shape"), pybind11::arg("dtype"));
		cl.def( pybind11::init<const struct std::array<int, 3> &, enum VPUNN::DataType, enum VPUNN::Layout>(), pybind11::arg("shape"), pybind11::arg("dtype"), pybind11::arg("layout") );

		cl.def( pybind11::init( [](VPUNN::VPUEM_Subblk_Tensor const &o){ return new VPUNN::VPUEM_Subblk_Tensor(o); } ) );
		cl.def("get_shape", (const struct std::array<int, 3> & (VPUNN::VPUEM_Subblk_Tensor::*)() const) &VPUNN::VPUEM_Subblk_Tensor::get_shape, "C++: VPUNN::VPUEM_Subblk_Tensor::get_shape() const --> const struct std::array<int, 3> &", pybind11::return_value_policy::reference);
		cl.def("set_shape", (void (VPUNN::VPUEM_Subblk_Tensor::*)(const int &, const int &)) &VPUNN::VPUEM_Subblk_Tensor::set_shape, "C++: VPUNN::VPUEM_Subblk_Tensor::set_shape(const int &, const int &) --> void", pybind11::arg("m"), pybind11::arg("val"));
		cl.def("get_dtype_", (enum VPUNN::DataType (VPUNN::VPUEM_Subblk_Tensor::*)() const) &VPUNN::VPUEM_Subblk_Tensor::get_dtype_, "C++: VPUNN::VPUEM_Subblk_Tensor::get_dtype_() const --> enum VPUNN::DataType");
		cl.def("get_layout_", (enum VPUNN::Layout (VPUNN::VPUEM_Subblk_Tensor::*)() const) &VPUNN::VPUEM_Subblk_Tensor::get_layout_, "C++: VPUNN::VPUEM_Subblk_Tensor::get_layout_() const --> enum VPUNN::Layout");
		cl.def("get_output_size", (int (VPUNN::VPUEM_Subblk_Tensor::*)() const) &VPUNN::VPUEM_Subblk_Tensor::get_output_size, "C++: VPUNN::VPUEM_Subblk_Tensor::get_output_size() const --> int");
		cl.def("assign", (class VPUNN::VPUEM_Subblk_Tensor & (VPUNN::VPUEM_Subblk_Tensor::*)(const class VPUNN::VPUEM_Subblk_Tensor &)) &VPUNN::VPUEM_Subblk_Tensor::operator=, "C++: VPUNN::VPUEM_Subblk_Tensor::operator=(const class VPUNN::VPUEM_Subblk_Tensor &) --> class VPUNN::VPUEM_Subblk_Tensor &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_56.cpp
#include <array> // std::array
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <map> // std::map
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_56(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPUEMCalcSubblk file: line:18
		pybind11::class_<VPUNN::VPUEMCalcSubblk, std::shared_ptr<VPUNN::VPUEMCalcSubblk>> cl(M("VPUNN"), "VPUEMCalcSubblk", "");
		cl.def( pybind11::init<bool, int, int>(), pybind11::arg("adaptive_blk_num_en"), pybind11::arg("max_blk_num"), pybind11::arg("dspArch") );

		cl.def( pybind11::init( [](VPUNN::VPUEMCalcSubblk const &o){ return new VPUNN::VPUEMCalcSubblk(o); } ) );
		cl.def("round_dim", (int (VPUNN::VPUEMCalcSubblk::*)(const int &, const int &) const) &VPUNN::VPUEMCalcSubblk::round_dim, "C++: VPUNN::VPUEMCalcSubblk::round_dim(const int &, const int &) const --> int", pybind11::arg("d0"), pybind11::arg("d1"));
		cl.def("calc_ts_subblk_size", (class VPUNN::VPUEM_Subblk_Tensor (VPUNN::VPUEMCalcSubblk::*)(const int &, const int &, const class VPUNN::VPUTensor &) const) &VPUNN::VPUEMCalcSubblk::calc_ts_subblk_size, "C++: VPUNN::VPUEMCalcSubblk::calc_ts_subblk_size(const int &, const int &, const class VPUNN::VPUTensor &) const --> class VPUNN::VPUEM_Subblk_Tensor", pybind11::arg("max_num_data"), pybind11::arg("data_num"), pybind11::arg("ts"));
		cl.def("calc_last_subblk_size", (class VPUNN::VPUEM_Subblk_Tensor (VPUNN::VPUEMCalcSubblk::*)(const class VPUNN::VPUEM_Subblk_Tensor &, const class VPUNN::VPUTensor &) const) &VPUNN::VPUEMCalcSubblk::calc_last_subblk_size, "C++: VPUNN::VPUEMCalcSubblk::calc_last_subblk_size(const class VPUNN::VPUEM_Subblk_Tensor &, const class VPUNN::VPUTensor &) const --> class VPUNN::VPUEM_Subblk_Tensor", pybind11::arg("dim"), pybind11::arg("ts"));
		cl.def("calc_dsp_block_unit", (class std::tuple<class std::list<int, class std::allocator<int> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> > > (VPUNN::VPUEMCalcSubblk::*)(const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &) const) &VPUNN::VPUEMCalcSubblk::calc_dsp_block_unit, "C++: VPUNN::VPUEMCalcSubblk::calc_dsp_block_unit(const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &) const --> class std::tuple<class std::list<int, class std::allocator<int> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> >, class std::list<class VPUNN::VPUEM_Subblk_Tensor, class std::allocator<class VPUNN::VPUEM_Subblk_Tensor> > >", pybind11::arg("inputs"), pybind11::arg("outputs"));
	}
	{ // VPUNN::PiecewiseModel file: line:21
		pybind11::class_<VPUNN::PiecewiseModel, std::shared_ptr<VPUNN::PiecewiseModel>, VPUNN::VPUEMShaveCyclesProvider<VPUNN::PiecewiseModel>> cl(M("VPUNN"), "PiecewiseModel", "");
		cl.def( pybind11::init( [](enum VPUNN::DataType const & a0, unsigned int const & a1, unsigned int const & a2, const class std::vector<struct VPUNN::CostFunction3SlopesDescriptor, class std::allocator<struct VPUNN::CostFunction3SlopesDescriptor> > & a3, bool const & a4, int const & a5, int const & a6, float const & a7){ return new VPUNN::PiecewiseModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("dtype"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq"), pybind11::arg("costFunction3SlopesData"), pybind11::arg("adaptive_blk_num_en"), pybind11::arg("max_blk_num"), pybind11::arg("dspArch"), pybind11::arg("cost_curve_ratio"));
		cl.def( pybind11::init<enum VPUNN::DataType, unsigned int, unsigned int, const class std::vector<struct VPUNN::CostFunction3SlopesDescriptor, class std::allocator<struct VPUNN::CostFunction3SlopesDescriptor> > &, bool, int, int, float, int>(), pybind11::arg("dtype"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq"), pybind11::arg("costFunction3SlopesData"), pybind11::arg("adaptive_blk_num_en"), pybind11::arg("max_blk_num"), pybind11::arg("dspArch"), pybind11::arg("cost_curve_ratio"), pybind11::arg("unroll_mode") );

		cl.def( pybind11::init( [](VPUNN::PiecewiseModel const &o){ return new VPUNN::PiecewiseModel(o); } ) );
		cl.def("getCostFunction", (std::string (VPUNN::PiecewiseModel::*)() const) &VPUNN::PiecewiseModel::getCostFunction, "C++: VPUNN::PiecewiseModel::getCostFunction() const --> std::string");
		cl.def("find_VPUEM_CostFunctionObject", (const class VPUNN::VPUEM_CostFunction & (VPUNN::PiecewiseModel::*)(const int) const) &VPUNN::PiecewiseModel::find_VPUEM_CostFunctionObject, "C++: VPUNN::PiecewiseModel::find_VPUEM_CostFunctionObject(const int) const --> const class VPUNN::VPUEM_CostFunction &", pybind11::return_value_policy::reference, pybind11::arg("output_size_bytes"));
		cl.def("getShaveCycles", (int (VPUNN::PiecewiseModel::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::PiecewiseModel::getShaveCycles, "C++: VPUNN::PiecewiseModel::getShaveCycles(const class VPUNN::SHAVEWorkload &) const --> int", pybind11::arg("w"));
		cl.def("getIdealCycles", (int (VPUNN::PiecewiseModel::*)(const int) const) &VPUNN::PiecewiseModel::getIdealCycles, "C++: VPUNN::PiecewiseModel::getIdealCycles(const int) const --> int", pybind11::arg("output_size_bytes"));
		cl.def("calc_blk_cycles", (int (VPUNN::PiecewiseModel::*)(const class VPUNN::VPUEM_Subblk_Tensor &, const class VPUNN::VPUEM_CostFunction &) const) &VPUNN::PiecewiseModel::calc_blk_cycles, "C++: VPUNN::PiecewiseModel::calc_blk_cycles(const class VPUNN::VPUEM_Subblk_Tensor &, const class VPUNN::VPUEM_CostFunction &) const --> int", pybind11::arg("odim"), pybind11::arg("vpuemObject"));
		cl.def("getComputedCycles", (int (VPUNN::PiecewiseModel::*)(const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &) const) &VPUNN::PiecewiseModel::getComputedCycles, "C++: VPUNN::PiecewiseModel::getComputedCycles(const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &) const --> int", pybind11::arg("inputs"), pybind11::arg("outputs"));

		cl.def("__str__", [](VPUNN::PiecewiseModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::VPUEMSoftmaxModel file: line:171
		pybind11::class_<VPUNN::VPUEMSoftmaxModel, std::shared_ptr<VPUNN::VPUEMSoftmaxModel>, VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSoftmaxModel>> cl(M("VPUNN"), "VPUEMSoftmaxModel", "");
		cl.def( pybind11::init<enum VPUNN::DataType, const class std::vector<struct VPUNN::CostFunctionSoftmaxDescriptor, class std::allocator<struct VPUNN::CostFunctionSoftmaxDescriptor> >, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("costFunctionSoftmaxData"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSoftmaxModel const &o){ return new VPUNN::VPUEMSoftmaxModel(o); } ) );
		cl.def("getShaveCycles", (int (VPUNN::VPUEMSoftmaxModel::*)(const int, const int, const int) const) &VPUNN::VPUEMSoftmaxModel::getShaveCycles, "C++: VPUNN::VPUEMSoftmaxModel::getShaveCycles(const int, const int, const int) const --> int", pybind11::arg("h_output_size_bytes"), pybind11::arg("hw_output_size_bytes"), pybind11::arg("c_output_size_bytes"));

		cl.def("__str__", [](VPUNN::VPUEMSoftmaxModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::VPUEMSpatialModel file: line:207
		pybind11::class_<VPUNN::VPUEMSpatialModel, std::shared_ptr<VPUNN::VPUEMSpatialModel>, VPUNN::VPUEMShaveCyclesProvider<VPUNN::VPUEMSpatialModel>> cl(M("VPUNN"), "VPUEMSpatialModel", "");
		cl.def( pybind11::init<enum VPUNN::DataType, const struct VPUNN::CostFunctionSpatialDescriptor &, unsigned int, unsigned int>(), pybind11::arg("dtype"), pybind11::arg("costFunctionSpatialData"), pybind11::arg("DpuFreq"), pybind11::arg("ShvFreq") );

		cl.def( pybind11::init( [](VPUNN::VPUEMSpatialModel const &o){ return new VPUNN::VPUEMSpatialModel(o); } ) );
		cl.def("getShaveCycles", (int (VPUNN::VPUEMSpatialModel::*)(int) const) &VPUNN::VPUEMSpatialModel::getShaveCycles, "C++: VPUNN::VPUEMSpatialModel::getShaveCycles(int) const --> int", pybind11::arg("output_size_bytes"));

		cl.def("__str__", [](VPUNN::VPUEMSpatialModel const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::DeviceShaveContainer file: line:33
		pybind11::class_<VPUNN::DeviceShaveContainer, std::shared_ptr<VPUNN::DeviceShaveContainer>> cl(M("VPUNN"), "DeviceShaveContainer", "list of shaves attached to a device\n must have access to the destructor of the ShaveOpExecutor.\n     owns the executor concrete instances (creation and destruction is in its responsibility)");
		cl.def( pybind11::init<enum VPUNN::VPUDevice>(), pybind11::arg("device") );

		cl.def("getDevice", (enum VPUNN::VPUDevice (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getDevice, "C++: VPUNN::DeviceShaveContainer::getDevice() const --> enum VPUNN::VPUDevice");
		cl.def("existsShave", (bool (VPUNN::DeviceShaveContainer::*)(const std::string) const) &VPUNN::DeviceShaveContainer::existsShave, "C++: VPUNN::DeviceShaveContainer::existsShave(const std::string) const --> bool", pybind11::arg("sw"));
		cl.def("getShaveList", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getShaveList, "C++: VPUNN::DeviceShaveContainer::getShaveList() const --> class std::vector<std::string, class std::allocator<std::string > >");
		cl.def("getShaveExecutor", (const class VPUNN::ShaveOpExecutor & (VPUNN::DeviceShaveContainer::*)(const std::string &) const) &VPUNN::DeviceShaveContainer::getShaveExecutor, "C++: VPUNN::DeviceShaveContainer::getShaveExecutor(const std::string &) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("sw"));
	}
	{ // VPUNN::ShaveInstanceHolder_VPU27 file: line:20
		pybind11::class_<VPUNN::ShaveInstanceHolder_VPU27, std::shared_ptr<VPUNN::ShaveInstanceHolder_VPU27>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_VPU27", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_VPU27(); } ) );
		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_VPU27 const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_VPU27::*)() const) &VPUNN::ShaveInstanceHolder_VPU27::getContainer, "C++: VPUNN::ShaveInstanceHolder_VPU27::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("populate", (void (VPUNN::ShaveInstanceHolder_VPU27::*)()) &VPUNN::ShaveInstanceHolder_VPU27::populate, "C++: VPUNN::ShaveInstanceHolder_VPU27::populate() --> void");
	}
	{ // VPUNN::ShaveInstanceHolder_VPU27CLassic file: line:34
		pybind11::class_<VPUNN::ShaveInstanceHolder_VPU27CLassic, std::shared_ptr<VPUNN::ShaveInstanceHolder_VPU27CLassic>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_VPU27CLassic", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_VPU27CLassic(); } ) );
		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_VPU27CLassic const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_VPU27CLassic::*)() const) &VPUNN::ShaveInstanceHolder_VPU27CLassic::getContainer, "C++: VPUNN::ShaveInstanceHolder_VPU27CLassic::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("populate", (void (VPUNN::ShaveInstanceHolder_VPU27CLassic::*)()) &VPUNN::ShaveInstanceHolder_VPU27CLassic::populate, "C++: VPUNN::ShaveInstanceHolder_VPU27CLassic::populate() --> void");
	}
	{ // VPUNN::ShaveInstanceHolder_Mock file: line:23
		pybind11::class_<VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27,VPUNN::VPUDevice::VPU_4_0>, std::shared_ptr<VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27,VPUNN::VPUDevice::VPU_4_0>>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_Mock_VPUNN_ShaveInstanceHolder_VPU27_VPUNN_VPUDevice_VPU_4_0_t", "");
		cl.def( pybind11::init<float>(), pybind11::arg("speed_increase") );

		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27,VPUNN::VPUDevice::VPU_4_0> const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27,VPUNN::VPUDevice::VPU_4_0>::*)() const) &VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27, VPUNN::VPUDevice::VPU_4_0>::getContainer, "C++: VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27, VPUNN::VPUDevice::VPU_4_0>::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("getDevice", (enum VPUNN::VPUDevice (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getDevice, "C++: VPUNN::DeviceShaveContainer::getDevice() const --> enum VPUNN::VPUDevice");
		cl.def("existsShave", (bool (VPUNN::DeviceShaveContainer::*)(const std::string) const) &VPUNN::DeviceShaveContainer::existsShave, "C++: VPUNN::DeviceShaveContainer::existsShave(const std::string) const --> bool", pybind11::arg("sw"));
		cl.def("getShaveList", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getShaveList, "C++: VPUNN::DeviceShaveContainer::getShaveList() const --> class std::vector<std::string, class std::allocator<std::string > >");
		cl.def("getShaveExecutor", (const class VPUNN::ShaveOpExecutor & (VPUNN::DeviceShaveContainer::*)(const std::string &) const) &VPUNN::DeviceShaveContainer::getShaveExecutor, "C++: VPUNN::DeviceShaveContainer::getShaveExecutor(const std::string &) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("sw"));
	}
	{ // VPUNN::ShaveInstanceHolder_Mock file: line:23
		pybind11::class_<VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40,VPUNN::VPUDevice::NPU_5_0>, std::shared_ptr<VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40,VPUNN::VPUDevice::NPU_5_0>>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_Mock_VPUNN_ShaveInstanceHolder_NPU40_VPUNN_VPUDevice_NPU_5_0_t", "");
		cl.def( pybind11::init<float>(), pybind11::arg("speed_increase") );

		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40,VPUNN::VPUDevice::NPU_5_0> const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40,VPUNN::VPUDevice::NPU_5_0>::*)() const) &VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40, VPUNN::VPUDevice::NPU_5_0>::getContainer, "C++: VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40, VPUNN::VPUDevice::NPU_5_0>::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("getDevice", (enum VPUNN::VPUDevice (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getDevice, "C++: VPUNN::DeviceShaveContainer::getDevice() const --> enum VPUNN::VPUDevice");
		cl.def("existsShave", (bool (VPUNN::DeviceShaveContainer::*)(const std::string) const) &VPUNN::DeviceShaveContainer::existsShave, "C++: VPUNN::DeviceShaveContainer::existsShave(const std::string) const --> bool", pybind11::arg("sw"));
		cl.def("getShaveList", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getShaveList, "C++: VPUNN::DeviceShaveContainer::getShaveList() const --> class std::vector<std::string, class std::allocator<std::string > >");
		cl.def("getShaveExecutor", (const class VPUNN::ShaveOpExecutor & (VPUNN::DeviceShaveContainer::*)(const std::string &) const) &VPUNN::DeviceShaveContainer::getShaveExecutor, "C++: VPUNN::DeviceShaveContainer::getShaveExecutor(const std::string &) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("sw"));
	}
}


// File: VPUNN_57.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <iterator> // std::reverse_iterator
#include <memory> // std::allocator
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::_Bit_const_iterator
#include <vector> // std::_Bit_iterator
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::CONVOLUTION_Constraints_Layer file: line:20
struct PyCallBack_VPUNN_CONVOLUTION_Constraints_Layer : public VPUNN::CONVOLUTION_Constraints_Layer {
	using VPUNN::CONVOLUTION_Constraints_Layer::CONVOLUTION_Constraints_Layer;

	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints_Layer::check_sparsity_rules(a0, a1, a2);
	}
	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_sparsity(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CONVOLUTION_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::DW_CONVOLUTION_Constraints_Layer file: line:38
struct PyCallBack_VPUNN_DW_CONVOLUTION_Constraints_Layer : public VPUNN::DW_CONVOLUTION_Constraints_Layer {
	using VPUNN::DW_CONVOLUTION_Constraints_Layer::DW_CONVOLUTION_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return DW_CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return DW_CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return DW_CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::generate_sparsity(a0, a1, a2);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::DW_CONVOLUTION_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::CM_CONVOLUTION_Constraints_Layer file: line:40
struct PyCallBack_VPUNN_CM_CONVOLUTION_Constraints_Layer : public VPUNN::CM_CONVOLUTION_Constraints_Layer {
	using VPUNN::CM_CONVOLUTION_Constraints_Layer::CM_CONVOLUTION_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::input_0_volume(a0);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CM_CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::generate_sparsity(a0, a1, a2);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::CM_CONVOLUTION_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::ELTWISE_Constraints_Layer file: line:42
struct PyCallBack_VPUNN_ELTWISE_Constraints_Layer : public VPUNN::ELTWISE_Constraints_Layer {
	using VPUNN::ELTWISE_Constraints_Layer::ELTWISE_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ELTWISE_Constraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return ELTWISE_Constraints::filter_output_write_tile_Options(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
};

// VPUNN::MAXPOOL_Constraints_Layer file: line:44
struct PyCallBack_VPUNN_MAXPOOL_Constraints_Layer : public VPUNN::MAXPOOL_Constraints_Layer {
	using VPUNN::MAXPOOL_Constraints_Layer::MAXPOOL_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return MAXPOOL_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return MAXPOOL_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return MAXPOOL_Constraints::generate_sparsity(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return MAXPOOL_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MAXPOOL_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
};

// VPUNN::LAYERNORM_Constraints_Layer file: line:46
struct PyCallBack_VPUNN_LAYERNORM_Constraints_Layer : public VPUNN::LAYERNORM_Constraints_Layer {
	using VPUNN::LAYERNORM_Constraints_Layer::LAYERNORM_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return CONVOLUTION_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return CONVOLUTION_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	long long get_weight_table_size(const long long a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "get_weight_table_size");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::get_weight_table_size(a0);
	}
	long long input_1_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "input_1_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_1_volume(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LAYERNORM_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

// VPUNN::ELTWISE_MUL_Constraints_Layer file: line:48
struct PyCallBack_VPUNN_ELTWISE_MUL_Constraints_Layer : public VPUNN::ELTWISE_MUL_Constraints_Layer {
	using VPUNN::ELTWISE_MUL_Constraints_Layer::ELTWISE_MUL_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::generate_sparsity(a0, a1, a2);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return ELTWISE_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return ELTWISE_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ELTWISE_Constraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return ELTWISE_Constraints::filter_output_write_tile_Options(a0);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ELTWISE_MUL_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return IOperationDynamicConstraints::limit_sparsity(a0, a1);
	}
};

// VPUNN::AVGPOOL_Constraints_Layer file: line:50
struct PyCallBack_VPUNN_AVGPOOL_Constraints_Layer : public VPUNN::AVGPOOL_Constraints_Layer {
	using VPUNN::AVGPOOL_Constraints_Layer::AVGPOOL_Constraints_Layer;

	void generate_operation_dependent_tensors(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "generate_operation_dependent_tensors");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return AVGPOOL_Constraints::generate_operation_dependent_tensors(a0, a1, a2);
	}
	bool check_input_output_tensor_corelation(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "check_input_output_tensor_corelation");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return AVGPOOL_Constraints::check_input_output_tensor_corelation(a0, a1, a2);
	}
	void generate_sparsity(class VPUNN::Sampler & a0, const class VPUNN::IDeviceValidValues & a1, struct VPUNN::DPUOperation & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "generate_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return AVGPOOL_Constraints::generate_sparsity(a0, a1, a2);
	}
	void deduce_input_1_shape_and_layout(const struct VPUNN::TensorInfo & a0, const struct VPUNN::TensorInfo & a1, const class VPUNN::IDeviceValidValues & a2, const struct VPUNN::KernelInfo & a3, struct VPUNN::TensorInfo & a4) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "deduce_input_1_shape_and_layout");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2, a3, a4);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return AVGPOOL_Constraints::deduce_input_1_shape_and_layout(a0, a1, a2, a3, a4);
	}
	void limit_sparsity(const class VPUNN::IDeviceValidValues & a0, struct VPUNN::DPUOperation & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "limit_sparsity");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
				static pybind11::detail::override_caster_t<void> caster;
				return pybind11::detail::cast_ref<void>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<void>(std::move(o));
		}
		return GenericConvolution_Constraints::limit_sparsity(a0, a1);
	}
	bool check_sparsity_rules(const class VPUNN::IDeviceValidValues & a0, const struct VPUNN::DPUOperation & a1, std::string & a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "check_sparsity_rules");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return Base_Constraints::check_sparsity_rules(a0, a1, a2);
	}
	long long input_0_volume(const struct VPUNN::TensorInfo & a0) const throw() override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "input_0_volume");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<long long>::value) {
				static pybind11::detail::override_caster_t<long long> caster;
				return pybind11::detail::cast_ref<long long>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<long long>(std::move(o));
		}
		return Base_Constraints::input_0_volume(a0);
	}
	using _binder_ret_0 = class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> >;
	_binder_ret_0 filter_ISI_Strategy_Options(const class std::vector<enum VPUNN::ISIStrategy, class std::allocator<enum VPUNN::ISIStrategy> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "filter_ISI_Strategy_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_ISI_Strategy_Options(a0);
	}
	using _binder_ret_1 = class std::vector<int, class std::allocator<int> >;
	_binder_ret_1 filter_output_write_tile_Options(const class std::vector<int, class std::allocator<int> > & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "filter_output_write_tile_Options");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return IOperationDynamicConstraints::filter_output_write_tile_Options(a0);
	}
	bool normalize_kernel_dimension(const enum VPUNN::ISIStrategy & a0, struct VPUNN::KernelInfo & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::AVGPOOL_Constraints_Layer *>(this), "normalize_kernel_dimension");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
				static pybind11::detail::override_caster_t<bool> caster;
				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<bool>(std::move(o));
		}
		return IOperationDynamicConstraints::normalize_kernel_dimension(a0, a1);
	}
};

void bind_VPUNN_57(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ShaveInstanceHolder_Mock file: line:23
		pybind11::class_<VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50,VPUNN::VPUDevice::NPU_RESERVED>, std::shared_ptr<VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50,VPUNN::VPUDevice::NPU_RESERVED>>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_Mock_VPUNN_ShaveInstanceHolder_Mock_NPU50_VPUNN_VPUDevice_NPU_RESERVED_t", "");
		cl.def( pybind11::init<float>(), pybind11::arg("speed_increase") );

		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50,VPUNN::VPUDevice::NPU_RESERVED> const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50,VPUNN::VPUDevice::NPU_RESERVED>::*)() const) &VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50, VPUNN::VPUDevice::NPU_RESERVED>::getContainer, "C++: VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50, VPUNN::VPUDevice::NPU_RESERVED>::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("getDevice", (enum VPUNN::VPUDevice (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getDevice, "C++: VPUNN::DeviceShaveContainer::getDevice() const --> enum VPUNN::VPUDevice");
		cl.def("existsShave", (bool (VPUNN::DeviceShaveContainer::*)(const std::string) const) &VPUNN::DeviceShaveContainer::existsShave, "C++: VPUNN::DeviceShaveContainer::existsShave(const std::string) const --> bool", pybind11::arg("sw"));
		cl.def("getShaveList", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::DeviceShaveContainer::*)() const) &VPUNN::DeviceShaveContainer::getShaveList, "C++: VPUNN::DeviceShaveContainer::getShaveList() const --> class std::vector<std::string, class std::allocator<std::string > >");
		cl.def("getShaveExecutor", (const class VPUNN::ShaveOpExecutor & (VPUNN::DeviceShaveContainer::*)(const std::string &) const) &VPUNN::DeviceShaveContainer::getShaveExecutor, "C++: VPUNN::DeviceShaveContainer::getShaveExecutor(const std::string &) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("sw"));
	}
	{ // VPUNN::ShaveInstanceHolder_Mock_NPU40 file: line:24
		pybind11::class_<VPUNN::ShaveInstanceHolder_Mock_NPU40, std::shared_ptr<VPUNN::ShaveInstanceHolder_Mock_NPU40>, VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_VPU27,VPUNN::VPUDevice::VPU_4_0>> cl(M("VPUNN"), "ShaveInstanceHolder_Mock_NPU40", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_Mock_NPU40(); } ) );
	}
	{ // VPUNN::ShaveInstanceHolder_NPU40 file: line:31
		pybind11::class_<VPUNN::ShaveInstanceHolder_NPU40, std::shared_ptr<VPUNN::ShaveInstanceHolder_NPU40>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_NPU40", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_NPU40(); } ) );
		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_NPU40 const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_NPU40::*)() const) &VPUNN::ShaveInstanceHolder_NPU40::getContainer, "C++: VPUNN::ShaveInstanceHolder_NPU40::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("populate", (void (VPUNN::ShaveInstanceHolder_NPU40::*)()) &VPUNN::ShaveInstanceHolder_NPU40::populate, "C++: VPUNN::ShaveInstanceHolder_NPU40::populate() --> void");
	}
	{ // VPUNN::ShaveInstanceHolder_Mock_NPU50 file: line:29
		pybind11::class_<VPUNN::ShaveInstanceHolder_Mock_NPU50, std::shared_ptr<VPUNN::ShaveInstanceHolder_Mock_NPU50>, VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_NPU40,VPUNN::VPUDevice::NPU_5_0>> cl(M("VPUNN"), "ShaveInstanceHolder_Mock_NPU50", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_Mock_NPU50(); } ) );
	}
	{ // VPUNN::ShaveInstanceHolder_Mock_NPU_RESERVED file: line:38
		pybind11::class_<VPUNN::ShaveInstanceHolder_Mock_NPU_RESERVED, std::shared_ptr<VPUNN::ShaveInstanceHolder_Mock_NPU_RESERVED>, VPUNN::ShaveInstanceHolder_Mock<VPUNN::ShaveInstanceHolder_Mock_NPU50,VPUNN::VPUDevice::NPU_RESERVED>> cl(M("VPUNN"), "ShaveInstanceHolder_Mock_NPU_RESERVED", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_Mock_NPU_RESERVED(); } ) );
	}
	{ // VPUNN::ShaveInstanceHolder_NPU50 file: line:45
		pybind11::class_<VPUNN::ShaveInstanceHolder_NPU50, std::shared_ptr<VPUNN::ShaveInstanceHolder_NPU50>, VPUNN::DeviceShaveContainer> cl(M("VPUNN"), "ShaveInstanceHolder_NPU50", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveInstanceHolder_NPU50(); } ) );
		cl.def("getDevice", [](VPUNN::ShaveInstanceHolder_NPU50 const &o) -> VPUNN::VPUDevice { return o.getDevice(); }, "");
		cl.def("getContainer", (const class VPUNN::DeviceShaveContainer & (VPUNN::ShaveInstanceHolder_NPU50::*)() const) &VPUNN::ShaveInstanceHolder_NPU50::getContainer, "C++: VPUNN::ShaveInstanceHolder_NPU50::getContainer() const --> const class VPUNN::DeviceShaveContainer &", pybind11::return_value_policy::reference);
		cl.def("populate", (void (VPUNN::ShaveInstanceHolder_NPU50::*)()) &VPUNN::ShaveInstanceHolder_NPU50::populate, "C++: VPUNN::ShaveInstanceHolder_NPU50::populate() --> void");
	}
	{ // VPUNN::DMA_CyclesInfo file: line:23
		pybind11::class_<VPUNN::DMA_CyclesInfo, std::shared_ptr<VPUNN::DMA_CyclesInfo>> cl(M("VPUNN"), "DMA_CyclesInfo", "");
		cl.def( pybind11::init( [](VPUNN::DMA_CyclesInfo const &o){ return new VPUNN::DMA_CyclesInfo(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMA_CyclesInfo(); } ) );
		cl.def_readwrite("cycles", &VPUNN::DMA_CyclesInfo::cycles);
		cl.def("assign", (struct VPUNN::DMA_CyclesInfo & (VPUNN::DMA_CyclesInfo::*)(const struct VPUNN::DMA_CyclesInfo &)) &VPUNN::DMA_CyclesInfo::operator=, "C++: VPUNN::DMA_CyclesInfo::operator=(const struct VPUNN::DMA_CyclesInfo &) --> struct VPUNN::DMA_CyclesInfo &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::DMALayerInfo file: line:27
		pybind11::class_<VPUNN::DMALayerInfo, std::shared_ptr<VPUNN::DMALayerInfo>> cl(M("VPUNN"), "DMALayerInfo", "");
		cl.def( pybind11::init( [](VPUNN::DMALayerInfo const &o){ return new VPUNN::DMALayerInfo(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMALayerInfo(); } ) );
		cl.def_readwrite("w_tensor", &VPUNN::DMALayerInfo::w_tensor);
		cl.def_readwrite("input_tensor", &VPUNN::DMALayerInfo::input_tensor);
		cl.def_readwrite("output_tensor", &VPUNN::DMALayerInfo::output_tensor);
		cl.def("assign", (struct VPUNN::DMALayerInfo & (VPUNN::DMALayerInfo::*)(const struct VPUNN::DMALayerInfo &)) &VPUNN::DMALayerInfo::operator=, "C++: VPUNN::DMALayerInfo::operator=(const struct VPUNN::DMALayerInfo &) --> struct VPUNN::DMALayerInfo &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::DPUWorkloadsWithCyclesSplit file: line:43
		pybind11::class_<VPUNN::DPUWorkloadsWithCyclesSplit, std::shared_ptr<VPUNN::DPUWorkloadsWithCyclesSplit>> cl(M("VPUNN"), "DPUWorkloadsWithCyclesSplit", "container of DPUWorkload (order is relevant). Normally it stores the DPUworkloads associated to a tile plus their\n predicted  runtime");
		cl.def( pybind11::init( [](){ return new VPUNN::DPUWorkloadsWithCyclesSplit(); } ) );
		cl.def( pybind11::init( [](VPUNN::DPUWorkloadsWithCyclesSplit const &o){ return new VPUNN::DPUWorkloadsWithCyclesSplit(o); } ) );
		cl.def_readwrite("cycles", &VPUNN::DPUWorkloadsWithCyclesSplit::cycles);
		cl.def_readwrite("workloads", &VPUNN::DPUWorkloadsWithCyclesSplit::workloads);
	}
	{ // VPUNN::OneTileLayerInfo file: line:51
		pybind11::class_<VPUNN::OneTileLayerInfo, std::shared_ptr<VPUNN::OneTileLayerInfo>> cl(M("VPUNN"), "OneTileLayerInfo", "details about a tile split strategy");
		cl.def( pybind11::init( [](VPUNN::OneTileLayerInfo const &o){ return new VPUNN::OneTileLayerInfo(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::OneTileLayerInfo(); } ) );
		cl.def_readwrite("inter_tile_split_layer", &VPUNN::OneTileLayerInfo::inter_tile_split_layer);
		cl.def_readwrite("best_intra_tile_split", &VPUNN::OneTileLayerInfo::best_intra_tile_split);
		cl.def_readwrite("all_intra_tile_splits", &VPUNN::OneTileLayerInfo::all_intra_tile_splits);
		cl.def_readwrite("DMA_info", &VPUNN::OneTileLayerInfo::DMA_info);
	}
	{ // VPUNN::CONVOLUTION_Constraints_Layer file: line:20
		pybind11::class_<VPUNN::CONVOLUTION_Constraints_Layer, std::shared_ptr<VPUNN::CONVOLUTION_Constraints_Layer>, PyCallBack_VPUNN_CONVOLUTION_Constraints_Layer, VPUNN::CONVOLUTION_Constraints> cl(M("VPUNN"), "CONVOLUTION_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_CONVOLUTION_Constraints_Layer const &o){ return new PyCallBack_VPUNN_CONVOLUTION_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::CONVOLUTION_Constraints_Layer const &o){ return new VPUNN::CONVOLUTION_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::CONVOLUTION_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_CONVOLUTION_Constraints_Layer(); } ) );
	}
	{ // VPUNN::DW_CONVOLUTION_Constraints_Layer file: line:38
		pybind11::class_<VPUNN::DW_CONVOLUTION_Constraints_Layer, std::shared_ptr<VPUNN::DW_CONVOLUTION_Constraints_Layer>, PyCallBack_VPUNN_DW_CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints> cl(M("VPUNN"), "DW_CONVOLUTION_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_DW_CONVOLUTION_Constraints_Layer const &o){ return new PyCallBack_VPUNN_DW_CONVOLUTION_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::DW_CONVOLUTION_Constraints_Layer const &o){ return new VPUNN::DW_CONVOLUTION_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DW_CONVOLUTION_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_DW_CONVOLUTION_Constraints_Layer(); } ) );
	}
	{ // VPUNN::CM_CONVOLUTION_Constraints_Layer file: line:40
		pybind11::class_<VPUNN::CM_CONVOLUTION_Constraints_Layer, std::shared_ptr<VPUNN::CM_CONVOLUTION_Constraints_Layer>, PyCallBack_VPUNN_CM_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints> cl(M("VPUNN"), "CM_CONVOLUTION_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_CM_CONVOLUTION_Constraints_Layer const &o){ return new PyCallBack_VPUNN_CM_CONVOLUTION_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::CM_CONVOLUTION_Constraints_Layer const &o){ return new VPUNN::CM_CONVOLUTION_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::CM_CONVOLUTION_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_CM_CONVOLUTION_Constraints_Layer(); } ) );
	}
	{ // VPUNN::ELTWISE_Constraints_Layer file: line:42
		pybind11::class_<VPUNN::ELTWISE_Constraints_Layer, std::shared_ptr<VPUNN::ELTWISE_Constraints_Layer>, PyCallBack_VPUNN_ELTWISE_Constraints_Layer, VPUNN::ELTWISE_Constraints> cl(M("VPUNN"), "ELTWISE_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ELTWISE_Constraints_Layer const &o){ return new PyCallBack_VPUNN_ELTWISE_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ELTWISE_Constraints_Layer const &o){ return new VPUNN::ELTWISE_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::ELTWISE_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_ELTWISE_Constraints_Layer(); } ) );
	}
	{ // VPUNN::MAXPOOL_Constraints_Layer file: line:44
		pybind11::class_<VPUNN::MAXPOOL_Constraints_Layer, std::shared_ptr<VPUNN::MAXPOOL_Constraints_Layer>, PyCallBack_VPUNN_MAXPOOL_Constraints_Layer, VPUNN::MAXPOOL_Constraints> cl(M("VPUNN"), "MAXPOOL_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_MAXPOOL_Constraints_Layer const &o){ return new PyCallBack_VPUNN_MAXPOOL_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::MAXPOOL_Constraints_Layer const &o){ return new VPUNN::MAXPOOL_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::MAXPOOL_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_MAXPOOL_Constraints_Layer(); } ) );
	}
	{ // VPUNN::LAYERNORM_Constraints_Layer file: line:46
		pybind11::class_<VPUNN::LAYERNORM_Constraints_Layer, std::shared_ptr<VPUNN::LAYERNORM_Constraints_Layer>, PyCallBack_VPUNN_LAYERNORM_Constraints_Layer, VPUNN::LAYERNORM_Constraints> cl(M("VPUNN"), "LAYERNORM_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_LAYERNORM_Constraints_Layer const &o){ return new PyCallBack_VPUNN_LAYERNORM_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::LAYERNORM_Constraints_Layer const &o){ return new VPUNN::LAYERNORM_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::LAYERNORM_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_LAYERNORM_Constraints_Layer(); } ) );
	}
	{ // VPUNN::ELTWISE_MUL_Constraints_Layer file: line:48
		pybind11::class_<VPUNN::ELTWISE_MUL_Constraints_Layer, std::shared_ptr<VPUNN::ELTWISE_MUL_Constraints_Layer>, PyCallBack_VPUNN_ELTWISE_MUL_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints> cl(M("VPUNN"), "ELTWISE_MUL_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ELTWISE_MUL_Constraints_Layer const &o){ return new PyCallBack_VPUNN_ELTWISE_MUL_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ELTWISE_MUL_Constraints_Layer const &o){ return new VPUNN::ELTWISE_MUL_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::ELTWISE_MUL_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_ELTWISE_MUL_Constraints_Layer(); } ) );
	}
	{ // VPUNN::AVGPOOL_Constraints_Layer file: line:50
		pybind11::class_<VPUNN::AVGPOOL_Constraints_Layer, std::shared_ptr<VPUNN::AVGPOOL_Constraints_Layer>, PyCallBack_VPUNN_AVGPOOL_Constraints_Layer, VPUNN::AVGPOOL_Constraints> cl(M("VPUNN"), "AVGPOOL_Constraints_Layer", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_AVGPOOL_Constraints_Layer const &o){ return new PyCallBack_VPUNN_AVGPOOL_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](VPUNN::AVGPOOL_Constraints_Layer const &o){ return new VPUNN::AVGPOOL_Constraints_Layer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::AVGPOOL_Constraints_Layer(); }, [](){ return new PyCallBack_VPUNN_AVGPOOL_Constraints_Layer(); } ) );
	}
	{ // VPUNN::TilingStrategyInfo file: line:17
		pybind11::class_<VPUNN::TilingStrategyInfo, std::shared_ptr<VPUNN::TilingStrategyInfo>> cl(M("VPUNN"), "TilingStrategyInfo", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingStrategyInfo(); } ) );
		cl.def_static("isVerticalTiling", (bool (*)(enum VPUNN::VPUTilingStrategy)) &VPUNN::TilingStrategyInfo::isVerticalTiling, "C++: VPUNN::TilingStrategyInfo::isVerticalTiling(enum VPUNN::VPUTilingStrategy) --> bool", pybind11::arg("strategy"));
		cl.def_static("isHorizontalTiling", (bool (*)(enum VPUNN::VPUTilingStrategy)) &VPUNN::TilingStrategyInfo::isHorizontalTiling, "C++: VPUNN::TilingStrategyInfo::isHorizontalTiling(enum VPUNN::VPUTilingStrategy) --> bool", pybind11::arg("strategy"));
	}
	{ // VPUNN::VPU_LayerValidator file: line:49
		pybind11::class_<VPUNN::VPU_LayerValidator, std::shared_ptr<VPUNN::VPU_LayerValidator>, VPUNN::Behavior_Device_Mapping<VPUNN::Behaviours<VPUNN::CONVOLUTION_Constraints_Layer, VPUNN::DW_CONVOLUTION_Constraints_Layer, VPUNN::CM_CONVOLUTION_Constraints_Layer, VPUNN::ELTWISE_Constraints_Layer, VPUNN::MAXPOOL_Constraints_Layer, VPUNN::LAYERNORM_Constraints_Layer, VPUNN::ELTWISE_MUL_Constraints_Layer, VPUNN::AVGPOOL_Constraints_Layer>,VPUNN::VPU2_0_LayerValidValues, VPUNN::VPU2_7_LayerValidValues, VPUNN::VPU4_0_LayerValidValues, VPUNN::VPU5_0_LayerValidValues>> cl(M("VPUNN"), "VPU_LayerValidator", "services for Layer validation");
		cl.def( pybind11::init( [](VPUNN::VPU_LayerValidator const &o){ return new VPUNN::VPU_LayerValidator(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::VPU_LayerValidator(); } ) );
		cl.def("check_layer_consistency", (void (VPUNN::VPU_LayerValidator::*)(const struct VPUNN::DPUOperation &, const unsigned int, enum VPUNN::VPUTilingStrategy, const class VPUNN::IDeviceValidValues &, const class VPUNN::IOperationDynamicConstraints &, struct VPUNN::SanityReport &) const) &VPUNN::VPU_LayerValidator::check_layer_consistency, "nTiles: number of tiles we split a layer\n strategy: split layer strategy\n\nC++: VPUNN::VPU_LayerValidator::check_layer_consistency(const struct VPUNN::DPUOperation &, const unsigned int, enum VPUNN::VPUTilingStrategy, const class VPUNN::IDeviceValidValues &, const class VPUNN::IOperationDynamicConstraints &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("w"), pybind11::arg("nTiles"), pybind11::arg("strategy"), pybind11::arg("config"), pybind11::arg("operation_behaviour"), pybind11::arg("result"));
	}
}


// File: VPUNN_58.cpp
#include <array> // std::array
#include <bits/refwrap.h> // std::reference_wrapper
#include <fstream> // std::basic_fstream
#include <functional> // std::equal_to
#include <functional> // std::less
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <optional> // 
#include <optional> // std::nullopt_t
#include <optional> // std::optional
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <unordered_map> // std::unordered_map
#include <unordered_set> // std::unordered_set
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector
#include <vpu/shave/shave_cost_providers/shave_cost_provider_interface.h> // VPUNN::IShaveCostProvider

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ShaveSelector file: line:35
struct PyCallBack_VPUNN_ShaveSelector : public VPUNN::ShaveSelector {
	using VPUNN::ShaveSelector::ShaveSelector;

	const class VPUNN::ShaveOpExecutor & getShaveFuntion(const std::string & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveSelector *>(this), "getShaveFuntion");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::ShaveOpExecutor &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::ShaveOpExecutor &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::ShaveOpExecutor &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::ShaveOpExecutor &>(std::move(o));
		}
		return ShaveSelector::getShaveFuntion(a0);
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 getShaveList() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveSelector *>(this), "getShaveList");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ShaveSelector::getShaveList();
	}
};

// VPUNN::ShavePrioritySelector file: line:59
struct PyCallBack_VPUNN_ShavePrioritySelector : public VPUNN::ShavePrioritySelector {
	using VPUNN::ShavePrioritySelector::ShavePrioritySelector;

	const class VPUNN::ShaveOpExecutor & getShaveFuntion(const std::string & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShavePrioritySelector *>(this), "getShaveFuntion");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<const class VPUNN::ShaveOpExecutor &>::value) {
				static pybind11::detail::override_caster_t<const class VPUNN::ShaveOpExecutor &> caster;
				return pybind11::detail::cast_ref<const class VPUNN::ShaveOpExecutor &>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<const class VPUNN::ShaveOpExecutor &>(std::move(o));
		}
		return ShavePrioritySelector::getShaveFuntion(a0);
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 getShaveList() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShavePrioritySelector *>(this), "getShaveList");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return ShavePrioritySelector::getShaveList();
	}
};

// VPUNN::IShaveCostProvider file:vpu/shave/shave_cost_providers/shave_cost_provider_interface.h line:31
struct PyCallBack_VPUNN_IShaveCostProvider : public VPUNN::IShaveCostProvider {
	using VPUNN::IShaveCostProvider::IShaveCostProvider;

	unsigned int get_cost(const class VPUNN::SHAVEWorkload & a0, std::string * a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IShaveCostProvider *>(this), "get_cost");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IShaveCostProvider::get_cost\"");
	}
	int get_max_num_params() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IShaveCostProvider *>(this), "get_max_num_params");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IShaveCostProvider::get_max_num_params\"");
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 get_shave_supported_ops(enum VPUNN::VPUDevice & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IShaveCostProvider *>(this), "get_shave_supported_ops");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IShaveCostProvider::get_shave_supported_ops\"");
	}
	class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > get_shave_instance(const std::string & a0, enum VPUNN::VPUDevice & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IShaveCostProvider *>(this), "get_shave_instance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>::value) {
				static pybind11::detail::override_caster_t<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >> caster;
				return pybind11::detail::cast_ref<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IShaveCostProvider::get_shave_instance\"");
	}
};

void bind_VPUNN_58(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::LayersValidation file: line:35
		pybind11::class_<VPUNN::LayersValidation, std::shared_ptr<VPUNN::LayersValidation>> cl(M("VPUNN"), "LayersValidation", "Layer validation mechanisms for split and un-split layers");
		cl.def( pybind11::init( [](VPUNN::LayersValidation const &o){ return new VPUNN::LayersValidation(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::LayersValidation(); } ) );
		cl.def("getDeviceConfiguratorForTiles", (const class VPUNN::IDeviceValidValues & (VPUNN::LayersValidation::*)(enum VPUNN::VPUDevice) const) &VPUNN::LayersValidation::getDeviceConfiguratorForTiles, "C++: VPUNN::LayersValidation::getDeviceConfiguratorForTiles(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("check_completeLayer_consistency", [](VPUNN::LayersValidation const &o, const struct VPUNN::DPULayer & a0, struct VPUNN::SanityReport & a1, enum VPUNN::ISIStrategy const & a2, unsigned int const & a3) -> void { return o.check_completeLayer_consistency(a0, a1, a2, a3); }, "", pybind11::arg("layer"), pybind11::arg("result"), pybind11::arg("presumed_strategy"), pybind11::arg("nTiles"));
		cl.def("check_completeLayer_consistency", (void (VPUNN::LayersValidation::*)(const struct VPUNN::DPULayer &, struct VPUNN::SanityReport &, enum VPUNN::ISIStrategy, unsigned int, enum VPUNN::VPUTilingStrategy) const) &VPUNN::LayersValidation::check_completeLayer_consistency, "checks the layer validity against the rules of an unsplit Layer\n\nC++: VPUNN::LayersValidation::check_completeLayer_consistency(const struct VPUNN::DPULayer &, struct VPUNN::SanityReport &, enum VPUNN::ISIStrategy, unsigned int, enum VPUNN::VPUTilingStrategy) const --> void", pybind11::arg("layer"), pybind11::arg("result"), pybind11::arg("presumed_strategy"), pybind11::arg("nTiles"), pybind11::arg("strategy"));
		cl.def("check_splitLayer_consistency", (void (VPUNN::LayersValidation::*)(const struct VPUNN::DPULayer &, struct VPUNN::SanityReport &) const) &VPUNN::LayersValidation::check_splitLayer_consistency, "C++: VPUNN::LayersValidation::check_splitLayer_consistency(const struct VPUNN::DPULayer &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("layer"), pybind11::arg("result"));
		cl.def("sanitize_preconditions", (void (VPUNN::LayersValidation::*)(struct VPUNN::DPULayer &) const) &VPUNN::LayersValidation::sanitize_preconditions, "C++: VPUNN::LayersValidation::sanitize_preconditions(struct VPUNN::DPULayer &) const --> void", pybind11::arg("layer"));
	}
	{ // VPUNN::CostSerializationWrap file: line:33
		pybind11::class_<VPUNN::CostSerializationWrap, std::shared_ptr<VPUNN::CostSerializationWrap>> cl(M("VPUNN"), "CostSerializationWrap", "");
		cl.def("serializeCycles_closeLine", (void (VPUNN::CostSerializationWrap::*)(unsigned int)) &VPUNN::CostSerializationWrap::serializeCycles_closeLine, "vpunn_cycles\n\nC++: VPUNN::CostSerializationWrap::serializeCycles_closeLine(unsigned int) --> void", pybind11::arg("cost"));
	}
	{ // VPUNN::SHAVECostSerializationWrap file: line:16
		pybind11::class_<VPUNN::SHAVECostSerializationWrap, std::shared_ptr<VPUNN::SHAVECostSerializationWrap>, VPUNN::CostSerializationWrap> cl(M("VPUNN"), "SHAVECostSerializationWrap", "");
		cl.def("serializeShaveWorkloadWithCycles", (void (VPUNN::SHAVECostSerializationWrap::*)(const class VPUNN::SHAVEWorkload &, const std::string &, const unsigned int)) &VPUNN::SHAVECostSerializationWrap::serializeShaveWorkloadWithCycles, "C++: VPUNN::SHAVECostSerializationWrap::serializeShaveWorkloadWithCycles(const class VPUNN::SHAVEWorkload &, const std::string &, const unsigned int) --> void", pybind11::arg("swl"), pybind11::arg("shave_model_kind"), pybind11::arg("cycles"));
	}
	{ // VPUNN::ShaveSerializerUtils file: line:125
		pybind11::class_<VPUNN::ShaveSerializerUtils, std::shared_ptr<VPUNN::ShaveSerializerUtils>> cl(M("VPUNN"), "ShaveSerializerUtils", "Utility class for SHAVE serialization operations\n\n This class provides static utility functions for SHAVE serialization\n without requiring object instantiation.");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveSerializerUtils(); } ) );
		cl.def_static("get_names_for_shave_serializer", []() -> std::vector<std::string, class std::allocator<std::string > > { return VPUNN::ShaveSerializerUtils::get_names_for_shave_serializer(); }, "");
		cl.def_static("get_names_for_shave_serializer", (class std::vector<std::string, class std::allocator<std::string > > (*)(const int)) &VPUNN::ShaveSerializerUtils::get_names_for_shave_serializer, "Get the field names for SHAVE serialization\n\n Returns a vector of field names used for SHAVE workload serialization.\n This function can be called directly without creating an instance of the class.\n\n \n Maximum number of parameters to include in the field names (default: 10)\n \n\n std::vector<std::string> Vector containing all field names for SHAVE serialization\n\nC++: VPUNN::ShaveSerializerUtils::get_names_for_shave_serializer(const int) --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("max_num_params"));
	}
	{ // VPUNN::SHAVE_Workloads_Sanitizer file: line:20
		pybind11::class_<VPUNN::SHAVE_Workloads_Sanitizer, std::shared_ptr<VPUNN::SHAVE_Workloads_Sanitizer>> cl(M("VPUNN"), "SHAVE_Workloads_Sanitizer", "");
		cl.def( pybind11::init( [](VPUNN::SHAVE_Workloads_Sanitizer const &o){ return new VPUNN::SHAVE_Workloads_Sanitizer(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::SHAVE_Workloads_Sanitizer(); } ) );
		cl.def("check_and_sanitize", (void (VPUNN::SHAVE_Workloads_Sanitizer::*)(const class VPUNN::SHAVEWorkload &, struct VPUNN::SanityReport &) const) &VPUNN::SHAVE_Workloads_Sanitizer::check_and_sanitize, "C++: VPUNN::SHAVE_Workloads_Sanitizer::check_and_sanitize(const class VPUNN::SHAVEWorkload &, struct VPUNN::SanityReport &) const --> void", pybind11::arg("swl"), pybind11::arg("result"));
	}
	{ // VPUNN::ShaveSelector file: line:35
		pybind11::class_<VPUNN::ShaveSelector, std::shared_ptr<VPUNN::ShaveSelector>, PyCallBack_VPUNN_ShaveSelector> cl(M("VPUNN"), "ShaveSelector", "selects  in a trivial manner, from one container");
		cl.def( pybind11::init<const class VPUNN::DeviceShaveContainer &>(), pybind11::arg("shave_container") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_ShaveSelector const &o){ return new PyCallBack_VPUNN_ShaveSelector(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ShaveSelector const &o){ return new VPUNN::ShaveSelector(o); } ) );
		cl.def("getShaveFuntion", (const class VPUNN::ShaveOpExecutor & (VPUNN::ShaveSelector::*)(const std::string &) const) &VPUNN::ShaveSelector::getShaveFuntion, "C++: VPUNN::ShaveSelector::getShaveFuntion(const std::string &) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("name"));
		cl.def("getShaveList", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::ShaveSelector::*)() const) &VPUNN::ShaveSelector::getShaveList, "C++: VPUNN::ShaveSelector::getShaveList() const --> class std::vector<std::string, class std::allocator<std::string > >");
	}
	{ // VPUNN::ShavePrioritySelector file: line:59
		pybind11::class_<VPUNN::ShavePrioritySelector, std::shared_ptr<VPUNN::ShavePrioritySelector>, PyCallBack_VPUNN_ShavePrioritySelector, VPUNN::ShaveSelector> cl(M("VPUNN"), "ShavePrioritySelector", "selects from 2 containers , 1st with priority");
		cl.def( pybind11::init<const class VPUNN::DeviceShaveContainer &, const class VPUNN::DeviceShaveContainer &>(), pybind11::arg("shave_container_first"), pybind11::arg("shave_container_second") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_ShavePrioritySelector const &o){ return new PyCallBack_VPUNN_ShavePrioritySelector(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ShavePrioritySelector const &o){ return new VPUNN::ShavePrioritySelector(o); } ) );
		cl.def("getShaveFuntion", (const class VPUNN::ShaveOpExecutor & (VPUNN::ShavePrioritySelector::*)(const std::string &) const) &VPUNN::ShavePrioritySelector::getShaveFuntion, "C++: VPUNN::ShavePrioritySelector::getShaveFuntion(const std::string &) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("name"));
		cl.def("getShaveList", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::ShavePrioritySelector::*)() const) &VPUNN::ShavePrioritySelector::getShaveList, "C++: VPUNN::ShavePrioritySelector::getShaveList() const --> class std::vector<std::string, class std::allocator<std::string > >");
	}
	{ // VPUNN::ShaveConfiguration file: line:86
		pybind11::class_<VPUNN::ShaveConfiguration, std::shared_ptr<VPUNN::ShaveConfiguration>> cl(M("VPUNN"), "ShaveConfiguration", "the shave configuration. Holds instances of all configurations supported by this app version");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveConfiguration(); } ) );
		cl.def("getSelector", (const class VPUNN::ShaveSelector & (VPUNN::ShaveConfiguration::*)(enum VPUNN::VPUDevice) const) &VPUNN::ShaveConfiguration::getSelector, "C++: VPUNN::ShaveConfiguration::getSelector(enum VPUNN::VPUDevice) const --> const class VPUNN::ShaveSelector &", pybind11::return_value_policy::reference, pybind11::arg("desired_device"));
		cl.def("getOldSelector", (const class VPUNN::ShaveSelector & (VPUNN::ShaveConfiguration::*)(enum VPUNN::VPUDevice) const) &VPUNN::ShaveConfiguration::getOldSelector, "C++: VPUNN::ShaveConfiguration::getOldSelector(enum VPUNN::VPUDevice) const --> const class VPUNN::ShaveSelector &", pybind11::return_value_policy::reference, pybind11::arg("desired_device"));
		cl.def("get_max_num_params", (int (VPUNN::ShaveConfiguration::*)() const) &VPUNN::ShaveConfiguration::get_max_num_params, "Get the maximum number of parameters across all SHAVE functions\n\n Iterates through all SHAVE functions to find the maximum number of expected parameters. \n This is useful for determining the appropriate buffer sizes or field counts needed for serialization.\n\n \n Reference to ShaveSelector containing SHAVE function definitions\n \n\n int Maximum number of parameters found across all SHAVE functions\n\nC++: VPUNN::ShaveConfiguration::get_max_num_params() const --> int");
	}
	{ // VPUNN::DCIMWorkload file: line:30
		pybind11::class_<VPUNN::DCIMWorkload, std::shared_ptr<VPUNN::DCIMWorkload>> cl(M("VPUNN"), "DCIMWorkload", "The base structure that encodes a DPU DCIM workloads\n Normally the tensors in/out that describe the operation are expected to be the compute tensors");
		cl.def( pybind11::init( [](){ return new VPUNN::DCIMWorkload(); } ) );
		cl.def( pybind11::init( [](VPUNN::DCIMWorkload const &o){ return new VPUNN::DCIMWorkload(o); } ) );
		cl.def_readwrite("input0", &VPUNN::DCIMWorkload::input0);
		cl.def_readwrite("output0", &VPUNN::DCIMWorkload::output0);
		cl.def_readwrite("kernels", &VPUNN::DCIMWorkload::kernels);
		cl.def_readwrite("strides", &VPUNN::DCIMWorkload::strides);
		cl.def_readwrite("padding", &VPUNN::DCIMWorkload::padding);
		cl.def_readwrite("output_write_tiles", &VPUNN::DCIMWorkload::output_write_tiles);
		cl.def_readwrite("halo", &VPUNN::DCIMWorkload::halo);
		cl.def("__eq__", (bool (VPUNN::DCIMWorkload::*)(const struct VPUNN::DCIMWorkload &) const) &VPUNN::DCIMWorkload::operator==, "equality test operator\n\nC++: VPUNN::DCIMWorkload::operator==(const struct VPUNN::DCIMWorkload &) const --> bool", pybind11::arg("b"));

		cl.def("__str__", [](VPUNN::DCIMWorkload const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::VPU_MutexAcces file: line:29
		pybind11::class_<VPUNN::VPU_MutexAcces, std::shared_ptr<VPUNN::VPU_MutexAcces>> cl(M("VPUNN"), "VPU_MutexAcces", "VPU_MutexAcces is a base class that provides a recursive mutex for thread-safe access to shared resources.\n It is designed to be inherited by other classes that require synchronized access to shared data.\n\n Derive virtually from this class to ensure that all derived classes share the same mutex.\n Intended to be used for thread level synchronization in the VPU NN library, hence the recursive mutex approach.\n Should allow the thread to lock multiple times the mutex, like it is in a single thread context and no mutex is\n present.\n\n The mutex is mutable, allowing const member functions to lock the mutex if needed.\n This is useful for classes that need to provide thread-safe access to their members without modifying them.");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU_MutexAcces(); } ) );
	}
	{ // VPUNN::DCiMCostModelInterface file: line:23
		pybind11::class_<VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>, std::shared_ptr<VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>>> cl(M("VPUNN"), "DCiMCostModelInterface_VPUNN_DCIMWorkload_t", "");
		cl.def( pybind11::init( [](VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload> const &o){ return new VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>(); } ) );
		cl.def("dCiM", (unsigned int (VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::*)(const struct VPUNN::DCIMWorkload &, std::string &) const) &VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::dCiM, "C++: VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::dCiM(const struct VPUNN::DCIMWorkload &, std::string &) const --> unsigned int", pybind11::arg("wl"), pybind11::arg("info"));
		cl.def("dCiM_Msg", (class std::tuple<unsigned int, std::string > (VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::*)(struct VPUNN::DCIMWorkload) const) &VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::dCiM_Msg, "C++: VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::dCiM_Msg(struct VPUNN::DCIMWorkload) const --> class std::tuple<unsigned int, std::string >", pybind11::arg("wl"));
		cl.def("assign", (class VPUNN::DCiMCostModelInterface<struct VPUNN::DCIMWorkload> & (VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::*)(const class VPUNN::DCiMCostModelInterface<struct VPUNN::DCIMWorkload> &)) &VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::operator=, "C++: VPUNN::DCiMCostModelInterface<VPUNN::DCIMWorkload>::operator=(const class VPUNN::DCiMCostModelInterface<struct VPUNN::DCIMWorkload> &) --> class VPUNN::DCiMCostModelInterface<struct VPUNN::DCIMWorkload> &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::IShaveCostProvider file:vpu/shave/shave_cost_providers/shave_cost_provider_interface.h line:31
		pybind11::class_<VPUNN::IShaveCostProvider, std::shared_ptr<VPUNN::IShaveCostProvider>, PyCallBack_VPUNN_IShaveCostProvider> cl(M("VPUNN"), "IShaveCostProvider", "Interface for SHAVE cost providers\n\n This interface defines the contract for classes that provide cost estimation\n for SHAVE workloads. Implementations of this interface should provide\n specific algorithms or models for calculating the execution cost of\n SHAVE operations.");
		cl.def(pybind11::init<PyCallBack_VPUNN_IShaveCostProvider const &>());
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IShaveCostProvider(); } ) );
		cl.def("get_cost", [](VPUNN::IShaveCostProvider const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.get_cost(a0); }, "", pybind11::arg("workload"));
		cl.def("get_cost", (unsigned int (VPUNN::IShaveCostProvider::*)(const class VPUNN::SHAVEWorkload &, std::string *) const) &VPUNN::IShaveCostProvider::get_cost, "Calculate the execution cost for a SHAVE workload\n\n This pure virtual function must be implemented by derived classes to\n provide cost estimation for the given SHAVE workload. The cost is\n typically measured in cycles or other performance metrics.\n\n \n The SHAVE workload for which to calculate the cost\n \n\n The source of cost under a string to be put in serializer\n \n\n CyclesInterfaceType The estimated execution cost/cycles for the workload\n\nC++: VPUNN::IShaveCostProvider::get_cost(const class VPUNN::SHAVEWorkload &, std::string *) const --> unsigned int", pybind11::arg("workload"), pybind11::arg("cost_source"));
		cl.def("get_max_num_params", (int (VPUNN::IShaveCostProvider::*)() const) &VPUNN::IShaveCostProvider::get_max_num_params, "Get the maximum number of parameters across all SHAVE functions\n \n\n the max number found\n\nC++: VPUNN::IShaveCostProvider::get_max_num_params() const --> int");
		cl.def("get_shave_supported_ops", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::IShaveCostProvider::*)(enum VPUNN::VPUDevice &) const) &VPUNN::IShaveCostProvider::get_shave_supported_ops, "the list of names of supported operators on a specified device. Each device has own operators\n\n \n specified device by caller\n \n\n container with the name of operators\n\nC++: VPUNN::IShaveCostProvider::get_shave_supported_ops(enum VPUNN::VPUDevice &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("get_shave_instance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::IShaveCostProvider::*)(const std::string &, enum VPUNN::VPUDevice &) const) &VPUNN::IShaveCostProvider::get_shave_instance, "provides a reference to the operator executor specified by name\n The executor can be used to execute (run) the runtime prediction on different tensors/parameters\n Or can be asked to print information about its implementation parameters\n\n \n of the operator\n \n\n name\n \n\n a ref (no ownership transfered. exists as long as this VPUCostModel instance exists)\n\nC++: VPUNN::IShaveCostProvider::get_shave_instance(const std::string &, enum VPUNN::VPUDevice &) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IShaveCostProvider & (VPUNN::IShaveCostProvider::*)(const class VPUNN::IShaveCostProvider &)) &VPUNN::IShaveCostProvider::operator=, "C++: VPUNN::IShaveCostProvider::operator=(const class VPUNN::IShaveCostProvider &) --> class VPUNN::IShaveCostProvider &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_59.cpp
#include <bits/refwrap.h> // std::reference_wrapper
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <memory> // std::shared_ptr
#include <optional> // 
#include <optional> // std::nullopt_t
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector
#include <vpu/shave/shave_cost_providers/priority_shave_cost_provider.h> // VPUNN::PriorityShaveCostProvider
#include <vpu/shave/shave_cost_providers/shave_cost_provider_interface.h> // VPUNN::IShaveCostProvider
#include <vpu/shave/shave_cost_providers/shave_cost_providers.h> // VPUNN::MathematicalShaveCostProviderBase
#include <vpu/shave/shave_cost_providers/shave_cost_providers.h> // VPUNN::OldShaveCostProvider
#include <vpu/shave/shave_cost_providers/shave_cost_providers.h> // VPUNN::ShaveCostProvider

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::MathematicalShaveCostProviderBase file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:28
struct PyCallBack_VPUNN_MathematicalShaveCostProviderBase_VPUNN_ShaveCostProvider_t : public VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider> {
	using VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::MathematicalShaveCostProviderBase;

	unsigned int get_cost(const class VPUNN::SHAVEWorkload & a0, std::string * a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider> *>(this), "get_cost");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_cost(a0, a1);
	}
	int get_max_num_params() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider> *>(this), "get_max_num_params");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_max_num_params();
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 get_shave_supported_ops(enum VPUNN::VPUDevice & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider> *>(this), "get_shave_supported_ops");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_supported_ops(a0);
	}
	class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > get_shave_instance(const std::string & a0, enum VPUNN::VPUDevice & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider> *>(this), "get_shave_instance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>::value) {
				static pybind11::detail::override_caster_t<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >> caster;
				return pybind11::detail::cast_ref<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_instance(a0, a1);
	}
};

// VPUNN::MathematicalShaveCostProviderBase file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:28
struct PyCallBack_VPUNN_MathematicalShaveCostProviderBase_VPUNN_OldShaveCostProvider_t : public VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider> {
	using VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::MathematicalShaveCostProviderBase;

	unsigned int get_cost(const class VPUNN::SHAVEWorkload & a0, std::string * a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider> *>(this), "get_cost");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_cost(a0, a1);
	}
	int get_max_num_params() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider> *>(this), "get_max_num_params");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_max_num_params();
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 get_shave_supported_ops(enum VPUNN::VPUDevice & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider> *>(this), "get_shave_supported_ops");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_supported_ops(a0);
	}
	class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > get_shave_instance(const std::string & a0, enum VPUNN::VPUDevice & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider> *>(this), "get_shave_instance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>::value) {
				static pybind11::detail::override_caster_t<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >> caster;
				return pybind11::detail::cast_ref<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_instance(a0, a1);
	}
};

// VPUNN::ShaveCostProvider file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:116
struct PyCallBack_VPUNN_ShaveCostProvider : public VPUNN::ShaveCostProvider {
	using VPUNN::ShaveCostProvider::ShaveCostProvider;

	unsigned int get_cost(const class VPUNN::SHAVEWorkload & a0, std::string * a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveCostProvider *>(this), "get_cost");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_cost(a0, a1);
	}
	int get_max_num_params() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveCostProvider *>(this), "get_max_num_params");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_max_num_params();
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 get_shave_supported_ops(enum VPUNN::VPUDevice & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveCostProvider *>(this), "get_shave_supported_ops");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_supported_ops(a0);
	}
	class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > get_shave_instance(const std::string & a0, enum VPUNN::VPUDevice & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ShaveCostProvider *>(this), "get_shave_instance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>::value) {
				static pybind11::detail::override_caster_t<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >> caster;
				return pybind11::detail::cast_ref<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_instance(a0, a1);
	}
};

// VPUNN::OldShaveCostProvider file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:133
struct PyCallBack_VPUNN_OldShaveCostProvider : public VPUNN::OldShaveCostProvider {
	using VPUNN::OldShaveCostProvider::OldShaveCostProvider;

	unsigned int get_cost(const class VPUNN::SHAVEWorkload & a0, std::string * a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::OldShaveCostProvider *>(this), "get_cost");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_cost(a0, a1);
	}
	int get_max_num_params() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::OldShaveCostProvider *>(this), "get_max_num_params");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_max_num_params();
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 get_shave_supported_ops(enum VPUNN::VPUDevice & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::OldShaveCostProvider *>(this), "get_shave_supported_ops");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_supported_ops(a0);
	}
	class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > get_shave_instance(const std::string & a0, enum VPUNN::VPUDevice & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::OldShaveCostProvider *>(this), "get_shave_instance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>::value) {
				static pybind11::detail::override_caster_t<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >> caster;
				return pybind11::detail::cast_ref<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o));
		}
		return MathematicalShaveCostProviderBase::get_shave_instance(a0, a1);
	}
};

// VPUNN::PriorityShaveCostProvider file:vpu/shave/shave_cost_providers/priority_shave_cost_provider.h line:34
struct PyCallBack_VPUNN_PriorityShaveCostProvider : public VPUNN::PriorityShaveCostProvider {
	using VPUNN::PriorityShaveCostProvider::PriorityShaveCostProvider;

	unsigned int get_cost(const class VPUNN::SHAVEWorkload & a0, std::string * a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PriorityShaveCostProvider *>(this), "get_cost");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return PriorityShaveCostProvider::get_cost(a0, a1);
	}
	int get_max_num_params() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PriorityShaveCostProvider *>(this), "get_max_num_params");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PriorityShaveCostProvider::get_max_num_params();
	}
	using _binder_ret_0 = class std::vector<std::string, class std::allocator<std::string > >;
	_binder_ret_0 get_shave_supported_ops(enum VPUNN::VPUDevice & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PriorityShaveCostProvider *>(this), "get_shave_supported_ops");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PriorityShaveCostProvider::get_shave_supported_ops(a0);
	}
	class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > get_shave_instance(const std::string & a0, enum VPUNN::VPUDevice & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PriorityShaveCostProvider *>(this), "get_shave_instance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>::value) {
				static pybind11::detail::override_caster_t<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >> caster;
				return pybind11::detail::cast_ref<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >>(std::move(o));
		}
		return PriorityShaveCostProvider::get_shave_instance(a0, a1);
	}
};

void bind_VPUNN_59(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::MathematicalShaveCostProviderBase file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:28
		pybind11::class_<VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>, std::shared_ptr<VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>>, PyCallBack_VPUNN_MathematicalShaveCostProviderBase_VPUNN_ShaveCostProvider_t, VPUNN::IShaveCostProvider> cl(M("VPUNN"), "MathematicalShaveCostProviderBase_VPUNN_ShaveCostProvider_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>(); }, [](){ return new PyCallBack_VPUNN_MathematicalShaveCostProviderBase_VPUNN_ShaveCostProvider_t(); } ) );
		cl.def("get_cost", [](VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider> const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.get_cost(a0); }, "", pybind11::arg("workload"));
		cl.def("get_cost", (unsigned int (VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::*)(const class VPUNN::SHAVEWorkload &, std::string *) const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_cost, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_cost(const class VPUNN::SHAVEWorkload &, std::string *) const --> unsigned int", pybind11::arg("workload"), pybind11::arg("cost_source"));
		cl.def("get_max_num_params", (int (VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::*)() const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_max_num_params, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_max_num_params() const --> int");
		cl.def("get_shave_supported_ops", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::*)(enum VPUNN::VPUDevice &) const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_shave_supported_ops, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_shave_supported_ops(enum VPUNN::VPUDevice &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("get_shave_instance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::*)(const std::string &, enum VPUNN::VPUDevice &) const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_shave_instance, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>::get_shave_instance(const std::string &, enum VPUNN::VPUDevice &) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("get_cost", [](VPUNN::IShaveCostProvider const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.get_cost(a0); }, "", pybind11::arg("workload"));
		cl.def("get_cost", (unsigned int (VPUNN::IShaveCostProvider::*)(const class VPUNN::SHAVEWorkload &, std::string *) const) &VPUNN::IShaveCostProvider::get_cost, "Calculate the execution cost for a SHAVE workload\n\n This pure virtual function must be implemented by derived classes to\n provide cost estimation for the given SHAVE workload. The cost is\n typically measured in cycles or other performance metrics.\n\n \n The SHAVE workload for which to calculate the cost\n \n\n The source of cost under a string to be put in serializer\n \n\n CyclesInterfaceType The estimated execution cost/cycles for the workload\n\nC++: VPUNN::IShaveCostProvider::get_cost(const class VPUNN::SHAVEWorkload &, std::string *) const --> unsigned int", pybind11::arg("workload"), pybind11::arg("cost_source"));
		cl.def("get_max_num_params", (int (VPUNN::IShaveCostProvider::*)() const) &VPUNN::IShaveCostProvider::get_max_num_params, "Get the maximum number of parameters across all SHAVE functions\n \n\n the max number found\n\nC++: VPUNN::IShaveCostProvider::get_max_num_params() const --> int");
		cl.def("get_shave_supported_ops", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::IShaveCostProvider::*)(enum VPUNN::VPUDevice &) const) &VPUNN::IShaveCostProvider::get_shave_supported_ops, "the list of names of supported operators on a specified device. Each device has own operators\n\n \n specified device by caller\n \n\n container with the name of operators\n\nC++: VPUNN::IShaveCostProvider::get_shave_supported_ops(enum VPUNN::VPUDevice &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("get_shave_instance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::IShaveCostProvider::*)(const std::string &, enum VPUNN::VPUDevice &) const) &VPUNN::IShaveCostProvider::get_shave_instance, "provides a reference to the operator executor specified by name\n The executor can be used to execute (run) the runtime prediction on different tensors/parameters\n Or can be asked to print information about its implementation parameters\n\n \n of the operator\n \n\n name\n \n\n a ref (no ownership transfered. exists as long as this VPUCostModel instance exists)\n\nC++: VPUNN::IShaveCostProvider::get_shave_instance(const std::string &, enum VPUNN::VPUDevice &) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IShaveCostProvider & (VPUNN::IShaveCostProvider::*)(const class VPUNN::IShaveCostProvider &)) &VPUNN::IShaveCostProvider::operator=, "C++: VPUNN::IShaveCostProvider::operator=(const class VPUNN::IShaveCostProvider &) --> class VPUNN::IShaveCostProvider &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::MathematicalShaveCostProviderBase file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:28
		pybind11::class_<VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>, std::shared_ptr<VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>>, PyCallBack_VPUNN_MathematicalShaveCostProviderBase_VPUNN_OldShaveCostProvider_t, VPUNN::IShaveCostProvider> cl(M("VPUNN"), "MathematicalShaveCostProviderBase_VPUNN_OldShaveCostProvider_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>(); }, [](){ return new PyCallBack_VPUNN_MathematicalShaveCostProviderBase_VPUNN_OldShaveCostProvider_t(); } ) );
		cl.def("get_cost", [](VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider> const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.get_cost(a0); }, "", pybind11::arg("workload"));
		cl.def("get_cost", (unsigned int (VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::*)(const class VPUNN::SHAVEWorkload &, std::string *) const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_cost, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_cost(const class VPUNN::SHAVEWorkload &, std::string *) const --> unsigned int", pybind11::arg("workload"), pybind11::arg("cost_source"));
		cl.def("get_max_num_params", (int (VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::*)() const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_max_num_params, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_max_num_params() const --> int");
		cl.def("get_shave_supported_ops", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::*)(enum VPUNN::VPUDevice &) const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_shave_supported_ops, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_shave_supported_ops(enum VPUNN::VPUDevice &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("get_shave_instance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::*)(const std::string &, enum VPUNN::VPUDevice &) const) &VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_shave_instance, "C++: VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>::get_shave_instance(const std::string &, enum VPUNN::VPUDevice &) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("get_cost", [](VPUNN::IShaveCostProvider const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.get_cost(a0); }, "", pybind11::arg("workload"));
		cl.def("get_cost", (unsigned int (VPUNN::IShaveCostProvider::*)(const class VPUNN::SHAVEWorkload &, std::string *) const) &VPUNN::IShaveCostProvider::get_cost, "Calculate the execution cost for a SHAVE workload\n\n This pure virtual function must be implemented by derived classes to\n provide cost estimation for the given SHAVE workload. The cost is\n typically measured in cycles or other performance metrics.\n\n \n The SHAVE workload for which to calculate the cost\n \n\n The source of cost under a string to be put in serializer\n \n\n CyclesInterfaceType The estimated execution cost/cycles for the workload\n\nC++: VPUNN::IShaveCostProvider::get_cost(const class VPUNN::SHAVEWorkload &, std::string *) const --> unsigned int", pybind11::arg("workload"), pybind11::arg("cost_source"));
		cl.def("get_max_num_params", (int (VPUNN::IShaveCostProvider::*)() const) &VPUNN::IShaveCostProvider::get_max_num_params, "Get the maximum number of parameters across all SHAVE functions\n \n\n the max number found\n\nC++: VPUNN::IShaveCostProvider::get_max_num_params() const --> int");
		cl.def("get_shave_supported_ops", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::IShaveCostProvider::*)(enum VPUNN::VPUDevice &) const) &VPUNN::IShaveCostProvider::get_shave_supported_ops, "the list of names of supported operators on a specified device. Each device has own operators\n\n \n specified device by caller\n \n\n container with the name of operators\n\nC++: VPUNN::IShaveCostProvider::get_shave_supported_ops(enum VPUNN::VPUDevice &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("get_shave_instance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::IShaveCostProvider::*)(const std::string &, enum VPUNN::VPUDevice &) const) &VPUNN::IShaveCostProvider::get_shave_instance, "provides a reference to the operator executor specified by name\n The executor can be used to execute (run) the runtime prediction on different tensors/parameters\n Or can be asked to print information about its implementation parameters\n\n \n of the operator\n \n\n name\n \n\n a ref (no ownership transfered. exists as long as this VPUCostModel instance exists)\n\nC++: VPUNN::IShaveCostProvider::get_shave_instance(const std::string &, enum VPUNN::VPUDevice &) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("assign", (class VPUNN::IShaveCostProvider & (VPUNN::IShaveCostProvider::*)(const class VPUNN::IShaveCostProvider &)) &VPUNN::IShaveCostProvider::operator=, "C++: VPUNN::IShaveCostProvider::operator=(const class VPUNN::IShaveCostProvider &) --> class VPUNN::IShaveCostProvider &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::ShaveCostProvider file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:116
		pybind11::class_<VPUNN::ShaveCostProvider, std::shared_ptr<VPUNN::ShaveCostProvider>, PyCallBack_VPUNN_ShaveCostProvider, VPUNN::MathematicalShaveCostProviderBase<VPUNN::ShaveCostProvider>> cl(M("VPUNN"), "ShaveCostProvider", "SHAVE cost provider using Shave2 API (newer version)\n\n This class provides cost estimation for SHAVE workloads using the Shave2 API,\n which includes the latest operator implementations and optimizations.\n It inherits common functionality from MathematicalShaveCostProviderBase and\n implements selector retrieval specific to Shave2.");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveCostProvider(); }, [](){ return new PyCallBack_VPUNN_ShaveCostProvider(); } ) );
	}
	{ // VPUNN::OldShaveCostProvider file:vpu/shave/shave_cost_providers/shave_cost_providers.h line:133
		pybind11::class_<VPUNN::OldShaveCostProvider, std::shared_ptr<VPUNN::OldShaveCostProvider>, PyCallBack_VPUNN_OldShaveCostProvider, VPUNN::MathematicalShaveCostProviderBase<VPUNN::OldShaveCostProvider>> cl(M("VPUNN"), "OldShaveCostProvider", "SHAVE cost provider using Shave1 API (legacy version)\n\n This class provides cost estimation for SHAVE workloads using the legacy Shave1 API,\n maintained for backward compatibility with older operator implementations.");
		cl.def( pybind11::init( [](){ return new VPUNN::OldShaveCostProvider(); }, [](){ return new PyCallBack_VPUNN_OldShaveCostProvider(); } ) );
	}
	{ // VPUNN::PriorityShaveCostProvider file:vpu/shave/shave_cost_providers/priority_shave_cost_provider.h line:34
		pybind11::class_<VPUNN::PriorityShaveCostProvider, std::shared_ptr<VPUNN::PriorityShaveCostProvider>, PyCallBack_VPUNN_PriorityShaveCostProvider, VPUNN::IShaveCostProvider> cl(M("VPUNN"), "PriorityShaveCostProvider", "Priority-based SHAVE cost provider that tries multiple providers in order\n\n This class implements a priority-based approach to SHAVE cost calculation by\n maintaining a list of cost providers and trying them in order until one succeeds,\n otherwise proper error code is returned.");
		cl.def( pybind11::init<const class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > > &>(), pybind11::arg("providers") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PriorityShaveCostProvider const &o){ return new PyCallBack_VPUNN_PriorityShaveCostProvider(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PriorityShaveCostProvider const &o){ return new VPUNN::PriorityShaveCostProvider(o); } ) );
		cl.def("get_cost", [](VPUNN::PriorityShaveCostProvider const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.get_cost(a0); }, "", pybind11::arg("workload"));
		cl.def("get_cost", (unsigned int (VPUNN::PriorityShaveCostProvider::*)(const class VPUNN::SHAVEWorkload &, std::string *) const) &VPUNN::PriorityShaveCostProvider::get_cost, "Calculate the execution cost for a SHAVE workload using priority-based providers\n\n This function tries each cost provider in the priority list until one succeeds\n (returns a value other than error codes). If all providers fail, it returns\n the last error encountered.\n\n \n The SHAVE workload for which to calculate the cost\n \n\n Optional pointer to store the source of the cost. This is an output parameter only\n \n\n CyclesInterfaceType The estimated execution cost/cycles for the workload,\n         or an appropriate error code if all providers fail\n\nC++: VPUNN::PriorityShaveCostProvider::get_cost(const class VPUNN::SHAVEWorkload &, std::string *) const --> unsigned int", pybind11::arg("workload"), pybind11::arg("cost_source"));
		cl.def("get_max_num_params", (int (VPUNN::PriorityShaveCostProvider::*)() const) &VPUNN::PriorityShaveCostProvider::get_max_num_params, "Get the maximum number of parameters across all SHAVE functions and all CostProviders \n \n\n the max number found\n\nC++: VPUNN::PriorityShaveCostProvider::get_max_num_params() const --> int");
		cl.def("get_shave_supported_ops", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::PriorityShaveCostProvider::*)(enum VPUNN::VPUDevice &) const) &VPUNN::PriorityShaveCostProvider::get_shave_supported_ops, "the list of names of supported operators on a specified device. Each device has own operators\n\n \n specified device by caller\n \n\n container with the name of operators\n\nC++: VPUNN::PriorityShaveCostProvider::get_shave_supported_ops(enum VPUNN::VPUDevice &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("get_shave_instance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::PriorityShaveCostProvider::*)(const std::string &, enum VPUNN::VPUDevice &) const) &VPUNN::PriorityShaveCostProvider::get_shave_instance, "provides a reference to the operator executor specified by name\n The executor can be used to execute (run) the runtime prediction on different tensors/parameters\n Or can be asked to print information about its implementation parameters\n\n \n of the operator\n \n\n name\n \n\n a ref (no ownership transfered. exists as long as this VPUCostModel instance exists)\n\nC++: VPUNN::PriorityShaveCostProvider::get_shave_instance(const std::string &, enum VPUNN::VPUDevice &) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("assign", (class VPUNN::PriorityShaveCostProvider & (VPUNN::PriorityShaveCostProvider::*)(const class VPUNN::PriorityShaveCostProvider &)) &VPUNN::PriorityShaveCostProvider::operator=, "C++: VPUNN::PriorityShaveCostProvider::operator=(const class VPUNN::PriorityShaveCostProvider &) --> class VPUNN::PriorityShaveCostProvider &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_60.cpp
#include <array> // std::array
#include <bits/refwrap.h> // std::reference_wrapper
#include <fstream> // std::basic_fstream
#include <functional> // std::equal_to
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <memory> // std::shared_ptr
#include <optional> // std::nullopt_t
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <unordered_map> // std::unordered_map
#include <unordered_set> // std::unordered_set
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector
#include <vpu/shave/shave_cost_providers/shave_cost_provider_interface.h> // VPUNN::IShaveCostProvider
#include <vpu/shave/shave_cost_providers/shave_provider_bundles.h> // VPUNN::ShaveCostProviderBundles

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_60(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ShaveCostProviderBundles file:vpu/shave/shave_cost_providers/shave_provider_bundles.h line:25
		pybind11::class_<VPUNN::ShaveCostProviderBundles, std::shared_ptr<VPUNN::ShaveCostProviderBundles>> cl(M("VPUNN"), "ShaveCostProviderBundles", "Utility class for creating precomposed SHAVE cost provider bundles\n\n This class provides static factory methods for creating different combinations\n of SHAVE cost providers without requiring class instantiation.");
		cl.def( pybind11::init( [](){ return new VPUNN::ShaveCostProviderBundles(); } ) );
		cl.def_static("createDefaultShaveCostProviders", (class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > > (*)()) &VPUNN::ShaveCostProviderBundles::createDefaultShaveCostProviders, "Create a prebuilt list of SHAVE cost providers with default priority order\n\n Creates a priority list with:\n - Priority 0: ShaveCostProvider (with cache and Shave2 API)\n - Priority 1: OldShaveCostProvider (fallback to Shave1 API)\n\n \n ShaveCostProviderList The prebuilt provider list\n\nC++: VPUNN::ShaveCostProviderBundles::createDefaultShaveCostProviders() --> class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > >");
		cl.def_static("createNewShaveOnlyProviders", (class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > > (*)()) &VPUNN::ShaveCostProviderBundles::createNewShaveOnlyProviders, "Create a bundle with only the new SHAVE cost provider\n\n \n ShaveCostProviderList Provider list with only ShaveCostProvider\n\nC++: VPUNN::ShaveCostProviderBundles::createNewShaveOnlyProviders() --> class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > >");
		cl.def_static("createOldShaveOnlyProviders", (class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > > (*)()) &VPUNN::ShaveCostProviderBundles::createOldShaveOnlyProviders, "Create a bundle with only the old SHAVE cost provider\n\n \n ShaveCostProviderList Provider list with only OldShaveCostProvider\n\nC++: VPUNN::ShaveCostProviderBundles::createOldShaveOnlyProviders() --> class std::vector<class std::shared_ptr<class VPUNN::IShaveCostProvider>, class std::allocator<class std::shared_ptr<class VPUNN::IShaveCostProvider> > >");
	}
	{ // VPUNN::SHAVECostModel file: line:28
		pybind11::class_<VPUNN::SHAVECostModel, std::shared_ptr<VPUNN::SHAVECostModel>> cl(M("VPUNN"), "SHAVECostModel", "High-level cost model for estimating execution cycles of SHAVE workloads on VPU devices\n Provides flexibility in the way of what cost provider to use, either mathematical, priority based or NN based in future\n rule of three violation is false because they present but no effect (=default doesn't mean implemented)");
		cl.def( pybind11::init( [](){ return new VPUNN::SHAVECostModel(); } ), "doc" );
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::SHAVECostModel(a0); } ), "doc" , pybind11::arg("cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, const unsigned int & a1){ return new VPUNN::SHAVECostModel(a0, a1); } ), "doc" , pybind11::arg("cache_filename"), pybind11::arg("cache_size"));
		cl.def( pybind11::init<const std::string &, const unsigned int, const bool>(), pybind11::arg("cache_filename"), pybind11::arg("cache_size"), pybind11::arg("use_shave_2_api") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1){ return new VPUNN::SHAVECostModel(a0, a1); } ), "doc" , pybind11::arg("cache_data"), pybind11::arg("cache_data_length"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, const unsigned int & a2){ return new VPUNN::SHAVECostModel(a0, a1, a2); } ), "doc" , pybind11::arg("cache_data"), pybind11::arg("cache_data_length"), pybind11::arg("cache_size"));
		cl.def( pybind11::init<const char *, unsigned long, const unsigned int, bool>(), pybind11::arg("cache_data"), pybind11::arg("cache_data_length"), pybind11::arg("cache_size"), pybind11::arg("use_shave_2_api") );

		cl.def("computeCycles", (unsigned int (VPUNN::SHAVECostModel::*)(const class VPUNN::SHAVEWorkload &, std::string &, bool) const) &VPUNN::SHAVECostModel::computeCycles, "C++: VPUNN::SHAVECostModel::computeCycles(const class VPUNN::SHAVEWorkload &, std::string &, bool) const --> unsigned int", pybind11::arg("swl"), pybind11::arg("infoOut"), pybind11::arg("skipCacheSearch"));
		cl.def("computeCycles", (unsigned int (VPUNN::SHAVECostModel::*)(const class VPUNN::SHAVEWorkload &, std::string &) const) &VPUNN::SHAVECostModel::computeCycles, "C++: VPUNN::SHAVECostModel::computeCycles(const class VPUNN::SHAVEWorkload &, std::string &) const --> unsigned int", pybind11::arg("swl"), pybind11::arg("infoOut"));
		cl.def("computeCycles", (unsigned int (VPUNN::SHAVECostModel::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::SHAVECostModel::computeCycles, "C++: VPUNN::SHAVECostModel::computeCycles(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("swl"));
		cl.def("getPreloadedCacheCounter", (const class VPUNN::AccessCounter & (VPUNN::SHAVECostModel::*)() const) &VPUNN::SHAVECostModel::getPreloadedCacheCounter, "C++: VPUNN::SHAVECostModel::getPreloadedCacheCounter() const --> const class VPUNN::AccessCounter &", pybind11::return_value_policy::reference);
		cl.def("getShaveSupportedOperations", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::SHAVECostModel::*)(enum VPUNN::VPUDevice) const) &VPUNN::SHAVECostModel::getShaveSupportedOperations, "C++: VPUNN::SHAVECostModel::getShaveSupportedOperations(enum VPUNN::VPUDevice) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("getShaveInstance", (class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> > (VPUNN::SHAVECostModel::*)(std::string, enum VPUNN::VPUDevice) const) &VPUNN::SHAVECostModel::getShaveInstance, "C++: VPUNN::SHAVECostModel::getShaveInstance(std::string, enum VPUNN::VPUDevice) const --> class std::optional<class std::reference_wrapper<const class VPUNN::ShaveOpExecutor> >", pybind11::arg("name"), pybind11::arg("device"));
		cl.def("isShave2APIused", (bool (VPUNN::SHAVECostModel::*)() const) &VPUNN::SHAVECostModel::isShave2APIused, "Checks if the SHAVE Gen 2 API is being used.\n \n\n True if the SHAVE Gen 2 API is used, otherwise false.\n\nC++: VPUNN::SHAVECostModel::isShave2APIused() const --> bool");
	}
	{ // VPUNN::L1CostSerializationWrap file: line:19
		pybind11::class_<VPUNN::L1CostSerializationWrap, std::shared_ptr<VPUNN::L1CostSerializationWrap>, VPUNN::CostSerializationWrap> cl(M("VPUNN"), "L1CostSerializationWrap", "");
		cl.def("serializeInfoAndComputeWorkloadUid", [](VPUNN::L1CostSerializationWrap &o, const struct VPUNN::DPUWorkload & a0) -> void { return o.serializeInfoAndComputeWorkloadUid(a0); }, "", pybind11::arg("wl"));
		cl.def("serializeInfoAndComputeWorkloadUid", (void (VPUNN::L1CostSerializationWrap::*)(const struct VPUNN::DPUWorkload &, bool)) &VPUNN::L1CostSerializationWrap::serializeInfoAndComputeWorkloadUid, "C++: VPUNN::L1CostSerializationWrap::serializeInfoAndComputeWorkloadUid(const struct VPUNN::DPUWorkload &, bool) --> void", pybind11::arg("wl"), pybind11::arg("close_line"));
		cl.def("serializeCyclesAndCostInfo_closeLine", (void (VPUNN::L1CostSerializationWrap::*)(const unsigned int, const std::string, const std::string &)) &VPUNN::L1CostSerializationWrap::serializeCyclesAndCostInfo_closeLine, "C++: VPUNN::L1CostSerializationWrap::serializeCyclesAndCostInfo_closeLine(const unsigned int, const std::string, const std::string &) --> void", pybind11::arg("cycles"), pybind11::arg("cost_source"), pybind11::arg("info"));
		cl.def("serializeCyclesAndComputeWorkloadUid_closeLine", (void (VPUNN::L1CostSerializationWrap::*)(class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> >, const class std::vector<unsigned int, class std::allocator<unsigned int> >, const std::string &)) &VPUNN::L1CostSerializationWrap::serializeCyclesAndComputeWorkloadUid_closeLine, "C++: VPUNN::L1CostSerializationWrap::serializeCyclesAndComputeWorkloadUid_closeLine(class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> >, const class std::vector<unsigned int, class std::allocator<unsigned int> >, const std::string &) --> void", pybind11::arg("serializer_orig_wls"), pybind11::arg("cycles_vector"), pybind11::arg("dpu_nickname"));
	}
	{ // VPUNN::DMATheoreticalCostProvider_LNL_Legacy file: line:29
		pybind11::class_<VPUNN::DMATheoreticalCostProvider_LNL_Legacy, std::shared_ptr<VPUNN::DMATheoreticalCostProvider_LNL_Legacy>> cl(M("VPUNN"), "DMATheoreticalCostProvider_LNL_Legacy", "Provides theoretical cost for DMA workloads (developed the past for LNL devices or older) , in the Legacy mode\n of computing DMA\n\n This class estimates the number of execution cycles required for DMA operations\n using legacy calculation methods, considering device type, memory locations, data layout permutations,\n compression, and hardware bandwidth limitations. It is primarily used in class DMATheoreticalCostProvider for VPU40\n devices or prior to VPU40 or when legacy mode is on");
		cl.def( pybind11::init( [](){ return new VPUNN::DMATheoreticalCostProvider_LNL_Legacy(); } ) );
		cl.def( pybind11::init( [](VPUNN::DMATheoreticalCostProvider_LNL_Legacy const &o){ return new VPUNN::DMATheoreticalCostProvider_LNL_Legacy(o); } ) );
		cl.def("get_bandwidth_cycles_per_bytesLegacy", [](VPUNN::DMATheoreticalCostProvider_LNL_Legacy const &o, const class VPUNN::IDeviceHWCharacteristics & a0, const class VPUNN::VPUTensor & a1, enum VPUNN::MemoryLocation const & a2) -> float { return o.get_bandwidth_cycles_per_bytesLegacy(a0, a1, a2); }, "", pybind11::arg("hw"), pybind11::arg("tensor"), pybind11::arg("location"));
		cl.def("get_bandwidth_cycles_per_bytesLegacy", [](VPUNN::DMATheoreticalCostProvider_LNL_Legacy const &o, const class VPUNN::IDeviceHWCharacteristics & a0, const class VPUNN::VPUTensor & a1, enum VPUNN::MemoryLocation const & a2, bool const & a3) -> float { return o.get_bandwidth_cycles_per_bytesLegacy(a0, a1, a2, a3); }, "", pybind11::arg("hw"), pybind11::arg("tensor"), pybind11::arg("location"), pybind11::arg("compression"));
		cl.def("get_bandwidth_cycles_per_bytesLegacy", [](VPUNN::DMATheoreticalCostProvider_LNL_Legacy const &o, const class VPUNN::IDeviceHWCharacteristics & a0, const class VPUNN::VPUTensor & a1, enum VPUNN::MemoryLocation const & a2, bool const & a3, bool const & a4) -> float { return o.get_bandwidth_cycles_per_bytesLegacy(a0, a1, a2, a3, a4); }, "", pybind11::arg("hw"), pybind11::arg("tensor"), pybind11::arg("location"), pybind11::arg("compression"), pybind11::arg("permute"));
		cl.def("get_bandwidth_cycles_per_bytesLegacy", (float (VPUNN::DMATheoreticalCostProvider_LNL_Legacy::*)(const class VPUNN::IDeviceHWCharacteristics &, const class VPUNN::VPUTensor &, enum VPUNN::MemoryLocation, bool, bool, bool) const) &VPUNN::DMATheoreticalCostProvider_LNL_Legacy::get_bandwidth_cycles_per_bytesLegacy, "C++: VPUNN::DMATheoreticalCostProvider_LNL_Legacy::get_bandwidth_cycles_per_bytesLegacy(const class VPUNN::IDeviceHWCharacteristics &, const class VPUNN::VPUTensor &, enum VPUNN::MemoryLocation, bool, bool, bool) const --> float", pybind11::arg("hw"), pybind11::arg("tensor"), pybind11::arg("location"), pybind11::arg("compression"), pybind11::arg("permute"), pybind11::arg("half_duplex"));
		cl.def("DMATheoreticalCyclesLegacyLNL", (unsigned long (VPUNN::DMATheoreticalCostProvider_LNL_Legacy::*)(const struct VPUNN::DMAWorkload &) const) &VPUNN::DMATheoreticalCostProvider_LNL_Legacy::DMATheoreticalCyclesLegacyLNL, "Compute the DMA theoretical cycles => DMATheoreticalCyclesLegacyLNL\n\n \n a DMAWorkload\n \n\n unsigned long int theoretical execution DPU cycles\n \n\n Will be removed in future releases\n\nC++: VPUNN::DMATheoreticalCostProvider_LNL_Legacy::DMATheoreticalCyclesLegacyLNL(const struct VPUNN::DMAWorkload &) const --> unsigned long", pybind11::arg("wl"));
	}
	{ // VPUNN::DMATheoreticalCostProvider_PTL file: line:130
		pybind11::class_<VPUNN::DMATheoreticalCostProvider_PTL, std::shared_ptr<VPUNN::DMATheoreticalCostProvider_PTL>> cl(M("VPUNN"), "DMATheoreticalCostProvider_PTL", "Provides updated theoretical performance modeling for DMA workloads on PTL or newer devices.\n\n This class estimates the number of cycles required for DMA operations using the latest calculation\n methods, supporting advanced features such as decompression, permutation, and bandwidth aggregation.\n\n It is intended for use with PTL and newer devices in class DMATheoreticalCostProvider.\n\n TODO: If PTL have multiple theoretical implementations, clearly they should be in different classes with the same\n interface. For now we do not know yet the final design, maybe this is just an intermediate step.\n\n ");
		cl.def( pybind11::init<const class VPUNN::IHWCharacteristicsSet &>(), pybind11::arg("hw_info_set") );

		cl.def( pybind11::init( [](VPUNN::DMATheoreticalCostProvider_PTL const &o){ return new VPUNN::DMATheoreticalCostProvider_PTL(o); } ) );
		cl.def("DMATheoreticalCyclesPTL_ON", (unsigned long (VPUNN::DMATheoreticalCostProvider_PTL::*)(const struct VPUNN::DMAWorkload &) const) &VPUNN::DMATheoreticalCostProvider_PTL::DMATheoreticalCyclesPTL_ON, "Estimates the theoretical DMA execution cycles for PTL or newer devices => DMATheoreticalCyclesPTL_ON\n\n This method calculates the number of execution cycles required for a DMA\n operation using the updated PTL theoretical model\n\n \n The DMAWorkload describing the DMA operation\n \n\n The estimated number of DPU cycles required to complete the DMA operation.\n\nC++: VPUNN::DMATheoreticalCostProvider_PTL::DMATheoreticalCyclesPTL_ON(const struct VPUNN::DMAWorkload &) const --> unsigned long", pybind11::arg("wl"));
	}
	{ // VPUNN::DMATheoreticalCostProvider file: line:271
		pybind11::class_<VPUNN::DMATheoreticalCostProvider, std::shared_ptr<VPUNN::DMATheoreticalCostProvider>> cl(M("VPUNN"), "DMATheoreticalCostProvider", "Provides theoretical cycles for DMA workloads.\n\n This class estimates the number of execution cycles required for DMA operations on VPU hardware.\n It selects the appropriate theoretical model based on device type and configuration, supporting both\n legacy and updated calculation methods.\n\n An instance of this class is intended to be use as a provider for theoretical cost for DMA workloads\n An example of usage can be seen in class VPUCostModel where we either need just theoretical cost or\n we use this as a fallback when NN cost not available");
		cl.def( pybind11::init( [](){ return new VPUNN::DMATheoreticalCostProvider(); } ) );
		cl.def( pybind11::init( [](VPUNN::DMATheoreticalCostProvider const &o){ return new VPUNN::DMATheoreticalCostProvider(o); } ) );
		cl.def("DMATheoreticalCycles", (unsigned long (VPUNN::DMATheoreticalCostProvider::*)(const struct VPUNN::DMAWorkload &) const) &VPUNN::DMATheoreticalCostProvider::DMATheoreticalCycles, "C++: VPUNN::DMATheoreticalCostProvider::DMATheoreticalCycles(const struct VPUNN::DMAWorkload &) const --> unsigned long", pybind11::arg("wl"));
		cl.def("assign", (class VPUNN::DMATheoreticalCostProvider & (VPUNN::DMATheoreticalCostProvider::*)(const class VPUNN::DMATheoreticalCostProvider &)) &VPUNN::DMATheoreticalCostProvider::operator=, "C++: VPUNN::DMATheoreticalCostProvider::operator=(const class VPUNN::DMATheoreticalCostProvider &) --> class VPUNN::DMATheoreticalCostProvider &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::DPUTheoreticalCostProvider file: line:28
		pybind11::class_<VPUNN::DPUTheoreticalCostProvider, std::shared_ptr<VPUNN::DPUTheoreticalCostProvider>> cl(M("VPUNN"), "DPUTheoreticalCostProvider", "Provides theoretical performance modeling for DPU workloads.\n\n This class estimates the number of execution cycles required for various DPU operations,\n considering hardware characteristics, workload parameters, and memory bandwidth.\n\n An instance of this class is intended to be use as a provider for theoretical cost for DPU workloads\n An example of usage can be seen in class VPUCostModel where we either need just theoretical cost or\n we use this as a fallback when NN cost not available");
		cl.def( pybind11::init<const class VPUNN::HWPerformanceModel &>(), pybind11::arg("performance_") );

		cl.def( pybind11::init( [](VPUNN::DPUTheoreticalCostProvider const &o){ return new VPUNN::DPUTheoreticalCostProvider(o); } ) );
		cl.def("DPUTheoreticalCycles", (unsigned long (VPUNN::DPUTheoreticalCostProvider::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::DPUTheoreticalCostProvider::DPUTheoreticalCycles, "Compute the DPU theoretical cycles, maximum HW knowledge\n \n\n Calculates cycles that a single issue scalar CPU would require to execute\n          a DPUWorkload then divides by number of MACs which can be performed in\n          parallel by DPU. Also considers data type, CMX memory bandwidth and some\n          other (non-ideal) factors.\n NO sparsity is considered.\n Note: THISIS OBSOLETE/NOT UPDATED\n \n\n a DPUWorkload\n \n\n unsigned long int theoretical execution cycles\n\nC++: VPUNN::DPUTheoreticalCostProvider::DPUTheoreticalCycles(const struct VPUNN::DPUWorkload &) const --> unsigned long", pybind11::arg("wl"));
	}
}


// File: VPUNN_61.cpp
#include <array> // std::array
#include <bits/refwrap.h> // std::reference_wrapper
#include <fstream> // std::basic_fstream
#include <functional> // std::equal_to
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <unordered_map> // std::unordered_map
#include <unordered_set> // std::unordered_set
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_61(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::IEnergy file: line:29
		pybind11::class_<VPUNN::IEnergy, std::shared_ptr<VPUNN::IEnergy>> cl(M("VPUNN"), "IEnergy", "provides energy computation");
		cl.def( pybind11::init<const class VPUNN::VPUCostModel &, const class VPUNN::SHAVECostModel &, const class VPUNN::HWPerformanceModel &>(), pybind11::arg("all_service_provider_"), pybind11::arg("shave_service_provider_"), pybind11::arg("performance_") );

		cl.def( pybind11::init( [](VPUNN::IEnergy const &o){ return new VPUNN::IEnergy(o); } ) );
		cl.def("DPUEnergy", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::DPUEnergy, "Compute the energy of a DPUWorkload.\n \n\n This is a relative energy metric with a time base in DPU clock cyles. Energy of\n 1000 would mean energy of worst case power for 1000 DPU clock cycles at reference dynamic power (power virus\n for INT08/FP16/FP8 operations). measured in PowerVirusJoules = PowerVirus*cycle\n POwerVIrus reference type is device dependent.Normally choosing the type with max power\n \n\n a DPUWorkload\n \n\n float the DPUWorkload energy, measured  PowerVirus*cycle\n\nC++: VPUNN::IEnergy::DPUEnergy(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("SHAVEEnergy", (float (VPUNN::IEnergy::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::IEnergy::SHAVEEnergy, "Compute the energy of a SHAVE SHAVEWorkload.\n \n\n Energy here is a relative metric, but the activity factor of the operation multiplied by\n          its cost (number of clock cycles). We assume a constant activity factor of 0.5 for all and a max\n          power of 5% of the DPU max power.\n\n \n a SHAVEWorkload\n \n\n float the operation energy, in units relative to DPU PowerVirus. WIl return zero in case of error\n\nC++: VPUNN::IEnergy::SHAVEEnergy(const class VPUNN::SHAVEWorkload &) const --> float", pybind11::arg("swl"));
		cl.def("DPUActivityFactor", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::DPUActivityFactor, "proxy for DPU_RelativeActivityFactor_hw\n\nC++: VPUNN::IEnergy::DPUActivityFactor(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("calculateEnergyFromAFandTime", (float (VPUNN::IEnergy::*)(const float, const unsigned int &) const) &VPUNN::IEnergy::calculateEnergyFromAFandTime, "integrates activity factor over the cycles duration=> from power to energy\n\nC++: VPUNN::IEnergy::calculateEnergyFromAFandTime(const float, const unsigned int &) const --> float", pybind11::arg("activity_factor_powerVirus"), pybind11::arg("cycles"));
		cl.def("hw_utilization", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::hw_utilization, "Compute DPUWorkload hw utilization based on ideal cycles considering also HW/sparsity.\n This is in the context of the operation's datatype. (do not compare float with int values)\n Represents the percentage [0,1+] of ideal resources(MAC based) used by this workload.\n 1 = 100% of MACs are used\n The value is calculated using the Estimated Runtime (cycles) by VPUNN.\n If VPUNN is missing the TheoreticalCycles are used\n\n \n a DPUWorkload\n \n\n  DPUWorkload hardware utilization (zero signals problems)\n\nC++: VPUNN::IEnergy::hw_utilization(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("power_mac_hw_utilization", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::power_mac_hw_utilization, "Compute DPUWorkload hw utilization based on ideal cycles considering also HW/sparsity.\n This is in the context of the operation's datatype. (do not compare float with int values)\n Represents the percentage [0,1+] of ideal resources(MAC based) used by this workload.\n 1 = 100% of MACs are used\n The value is calculated using the Estimated Runtime (cycles) by VPUNN.\n If VPUNN is missing the TheoreticalCycles are used\n\n \n a DPUWorkload\n \n\n  DPUWorkload hardware utilization (zero signals problems)\n\nC++: VPUNN::IEnergy::power_mac_hw_utilization(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("efficiency_mac_hw_utilization", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::efficiency_mac_hw_utilization, "utilization without sparsity, can be larger than one, uses CostModel \n\nC++: VPUNN::IEnergy::efficiency_mac_hw_utilization(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("relative_mac_hw_utilization", (float (VPUNN::IEnergy::*)(const unsigned int, const unsigned long) const) &VPUNN::IEnergy::relative_mac_hw_utilization, "Compute DPUWorkload hw utilization based on received ideal cycles.\n This is in the context of the operation's datatype. (do not compare float with int values)\n Represents the percentage [0,1+] of ideal resources(MAC based) used by this workload.\n 1 = 100% of MACs are used\n The value is calculated using the Estimated Runtime (cycles) by VPUNN.\n If VPUNN is missing the TheoreticalCycles are used\n Values larger than 1 can  be obtained if the ideal_cycles are larger than eNN estimated ones\n result = ideal_cycles/estimatedNNCycles\n\n \n a DPUWorkload\n \n\n the reference ideal cycles against to compute the utilization\n \n\n  DPUWorkload hardware utilization (zero signals problems)\n\nC++: VPUNN::IEnergy::relative_mac_hw_utilization(const unsigned int, const unsigned long) const --> float", pybind11::arg("real_cycles"), pybind11::arg("ideal_cycles"));
		cl.def("DPU_PowerActivityFactor", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::DPU_PowerActivityFactor, "Compute the activity factor of a DPUWorkload.\n \n\n Activity factor is an estimation of the dynamic power of the DPUWorkload\n relative to the worst case (reference dynamic power) DPUWorkload.\n Interval [0, 1 or more], where 1 means the power virus activity factor\n reference dynamic power is considered for INT8 operations\n It can be more than 1 in case the PowerViruschosen for reference is not the fact the highest (like if reference\n is power virus INT8,  the float operations can have the AF >1).\n Internally uses CostModel\n\n \n a DPUWorkload\n \n\n float the DPUWorkload activity factor relative to reference PowerVirus  (now is INT8)\n\nC++: VPUNN::IEnergy::DPU_PowerActivityFactor(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("DPU_EfficiencyActivityFactor", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::DPU_EfficiencyActivityFactor, "Internally uses CostModel\n\nC++: VPUNN::IEnergy::DPU_EfficiencyActivityFactor(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("DPU_AgnosticActivityFactor", [](VPUNN::IEnergy const &o, const struct VPUNN::DPUWorkload & a0, const float & a1) -> float { return o.DPU_AgnosticActivityFactor(a0, a1); }, "", pybind11::arg("wl"), pybind11::arg("reference_hw_util"));
		cl.def("DPU_AgnosticActivityFactor", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &, const float, const float) const) &VPUNN::IEnergy::DPU_AgnosticActivityFactor, "C++: VPUNN::IEnergy::DPU_AgnosticActivityFactor(const struct VPUNN::DPUWorkload &, const float, const float) const --> float", pybind11::arg("wl"), pybind11::arg("reference_hw_util"), pybind11::arg("sparse_correction_factor_experimental"));
		cl.def("DPU_AgnosticActivityFactor_formula", [](VPUNN::IEnergy const &o, const float & a0, const float & a1) -> float { return o.DPU_AgnosticActivityFactor_formula(a0, a1); }, "", pybind11::arg("power_factor_value"), pybind11::arg("reference_hw_util"));
		cl.def("DPU_AgnosticActivityFactor_formula", (float (VPUNN::IEnergy::*)(const float, const float, const float) const) &VPUNN::IEnergy::DPU_AgnosticActivityFactor_formula, "C++: VPUNN::IEnergy::DPU_AgnosticActivityFactor_formula(const float, const float, const float) const --> float", pybind11::arg("power_factor_value"), pybind11::arg("reference_hw_util"), pybind11::arg("sparse_correction_factor_experimental"));
		cl.def("calculateEnergyFromIdealCycles", (float (VPUNN::IEnergy::*)(const struct VPUNN::DPUWorkload &, const unsigned long) const) &VPUNN::IEnergy::calculateEnergyFromIdealCycles, "C++: VPUNN::IEnergy::calculateEnergyFromIdealCycles(const struct VPUNN::DPUWorkload &, const unsigned long) const --> float", pybind11::arg("wl"), pybind11::arg("reference_ideal_cycles"));
		cl.def("fillDPUInfo", (void (VPUNN::IEnergy::*)(struct VPUNN::DPUInfoPack &, const struct VPUNN::DPUWorkload &) const) &VPUNN::IEnergy::fillDPUInfo, "fills in the fields of DPUInfoPack\n some fields have to be already populated\n\nC++: VPUNN::IEnergy::fillDPUInfo(struct VPUNN::DPUInfoPack &, const struct VPUNN::DPUWorkload &) const --> void", pybind11::arg("allData"), pybind11::arg("w"));
		cl.def("getPerformanceModel", (const class VPUNN::HWPerformanceModel & (VPUNN::IEnergy::*)() const) &VPUNN::IEnergy::getPerformanceModel, "C++: VPUNN::IEnergy::getPerformanceModel() const --> const class VPUNN::HWPerformanceModel &", pybind11::return_value_policy::reference);
	}
	{ // VPUNN::VPUCostModel file: line:80
		pybind11::class_<VPUNN::VPUCostModel, std::shared_ptr<VPUNN::VPUCostModel>> cl(M("VPUNN"), "VPUCostModel", "The VPUCostModel class\n\n Has behind a loaded CostModel neural network that infers cycle times for DPUWOrkloads\n ALso behind it need to have a dCIm model for the ops that support dCIM\n\n ");
		cl.def( pybind11::init( [](const std::string & a0, const std::string & a1, const std::string & a2){ return new VPUNN::VPUCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("filename"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, const std::string & a1, const std::string & a2, bool const & a3){ return new VPUNN::VPUCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("filename"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"));
		cl.def( pybind11::init<const std::string &, const std::string &, const std::string &, bool, bool>(), pybind11::arg("filename"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"), pybind11::arg("tryToLoadPairedCache") );

		cl.def( pybind11::init( [](){ return new VPUNN::VPUCostModel(); } ), "doc" );
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::VPUCostModel(a0); } ), "doc" , pybind11::arg("filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1){ return new VPUNN::VPUCostModel(a0, a1); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2){ return new VPUNN::VPUCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3){ return new VPUNN::VPUCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4, const std::string & a5){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4, const std::string & a5, bool const & a6){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"));
		cl.def( pybind11::init<const std::string &, bool, const unsigned int, const unsigned int, const std::string &, const std::string &, bool, bool>(), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"), pybind11::arg("tryToLoadPairedCache") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2){ return new VPUNN::VPUCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3){ return new VPUNN::VPUCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7, const char * a8){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7, const char * a8, unsigned long const & a9){ return new VPUNN::VPUCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"));
		cl.def( pybind11::init<const char *, unsigned long, bool, bool, const unsigned int, const unsigned int, const char *, unsigned long, const char *, unsigned long, bool>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"), pybind11::arg("use_shave_2_api") );

		cl.def("getEnergyInterface", (const class VPUNN::IEnergy & (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::getEnergyInterface, "returns a reference of energy object\n owned by the current costmodel\n the lifetime of this pointer is bound to the lifetime of costmodel object\n if costmodel is destroyed or goes out of scope, the reference will also become invalid\n\nC++: VPUNN::VPUCostModel::getEnergyInterface() const --> const class VPUNN::IEnergy &", pybind11::return_value_policy::reference);
		cl.def("getPerformanceModel", (const class VPUNN::HWPerformanceModel & (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::getPerformanceModel, "returns a reference of performance object\n\nC++: VPUNN::VPUCostModel::getPerformanceModel() const --> const class VPUNN::HWPerformanceModel &", pybind11::return_value_policy::reference);
		cl.def("getSanitizerDeviceConfiguration", (const class VPUNN::IDeviceValidValues & (VPUNN::VPUCostModel::*)(enum VPUNN::VPUDevice) const) &VPUNN::VPUCostModel::getSanitizerDeviceConfiguration, "C++: VPUNN::VPUCostModel::getSanitizerDeviceConfiguration(enum VPUNN::VPUDevice) const --> const class VPUNN::IDeviceValidValues &", pybind11::return_value_policy::reference, pybind11::arg("device"));
		cl.def("avgpool_replace_by", (void (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload &) const) &VPUNN::VPUCostModel::avgpool_replace_by, "simulates AVGPOOL with another equivalent operation (DW CONV), depends also on Device\n\n \n [in, out] that will be changed in case the input is AVGPOOL\n\nC++: VPUNN::VPUCostModel::avgpool_replace_by(struct VPUNN::DPUWorkload &) const --> void", pybind11::arg("workload"));
		cl.def("compressConv_replace_by_CM_CONV_VPU27", (void (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload &) const) &VPUNN::VPUCostModel::compressConv_replace_by_CM_CONV_VPU27, "Presumes any VPU27++ CONV with IC <16 to be compressed CONV. This is known by NN as CM_CONV\n\n \n [in, out] that will be changed in case the input is presumed compressed CONV\n\nC++: VPUNN::VPUCostModel::compressConv_replace_by_CM_CONV_VPU27(struct VPUNN::DPUWorkload &) const --> void", pybind11::arg("workload"));
		cl.def("swizzling_turn_OFF", (void (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload &) const) &VPUNN::VPUCostModel::swizzling_turn_OFF, "Turns OFF the swizzling\n\n \n [in, out] that will be changed in case the conditions are met\n\nC++: VPUNN::VPUCostModel::swizzling_turn_OFF(struct VPUNN::DPUWorkload &) const --> void", pybind11::arg("workload"));
		cl.def("sanitize_workload", (bool (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload &, struct VPUNN::SanityReport &) const) &VPUNN::VPUCostModel::sanitize_workload, "checks some validity criteria and performs sanitization that does not alter relevance\n\n \n DPU_OperationSanitizer::check_and_sanitize for details\n from legacy behavior is ensures that input channels are equal to output channels for channel preserving\n operations\n \n\n [in, out] to be checked and changed\n \n\n [out] holds error code\n \n\n true if checks were OK, false if this wl is not to be used\n\nC++: VPUNN::VPUCostModel::sanitize_workload(struct VPUNN::DPUWorkload &, struct VPUNN::SanityReport &) const --> bool", pybind11::arg("workload"), pybind11::arg("result"));
		cl.def("nn_initialized", (bool (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::nn_initialized, "Check if the internal VPUNN is initialized\n\n \n true the VPUNN neural network is initialized\n \n\n false the VPUNN neural network is not initialized\n\nC++: VPUNN::VPUCostModel::nn_initialized() const --> bool");
		cl.def("DPU", (unsigned int (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload) const) &VPUNN::VPUCostModel::DPU, "Return the number of cycles needed to compute a workload\n\n Important: If no NN is available it will return Theoretical cycles for the workload. Check if NN is loaded with\n nn_initialized()\n\n A sanity check will be performed on the workload and in case it is not suitable the method will return an error\n code without running the inference on the NN. \n\n DPU_OperationSanitizer::check_and_sanitize() explanations.\n Some checks examples:\n - if the device is supported\n - if workload fits in CMX memory\n - if the operation is supported\n\n List of Error codes is available in CyclesInterfaceType doc.\n\n A sanity check will be performed also on the NN output, in case the NN  raw value is not reliable it will not be\n returned but an error code will be given, e.g. ERROR_INVALID_OUTPUT_RANGE\n\n To see the limits of valid NN values interval , use \n get_NN_Valid_interval().  Zero is a value that will NOT\n be filtered out.\n\n Behind the DPU computation is a trained Neural Network that might give unexpected results in case is asked about\n a workload that is odd/(not well formed) or was not trained in that area or workloads.\n The workload passed as parameter for inference should be a valid one, a one that makes sense, we are checking\n some sanity, but ,for now, not a strict/extensive sanity check is performed. A workload with unrealistic\n combinations of  parameters (eg DW_CONV with 7 input/output channels ) will not be detected.\n\n In case the wl configuration is unrealistic the network will give undefined(aberrant) results (it was not trained\n on invalid data). The NN raw output is filtered for  generic valid interval (no negatives, no huge , e.g. 4bilion\n cycles) but the user can also be aware of this behavior and use its own narrower ranges\n\n e.g.  Depending on the wl a cycle values of 10 might be unrealistic, also a value of 100milion cycles (@1Ghz is\n ~100ms),  The user should be aware that not all aberrant/unrealistic NN outputs are handled inside.\n\n \n a DPUWorkload to be evaluated.\n \n\n unsigned int DPUWorkload execution cycles or an error code.\n\n \n out_of_range : cache problems, cannot pre-process data , generate the NN descriptor due to data unknown\n \n\n runtime_error: cannot generate the NN descriptor, e.g expected sizes do not match\n\n     \n\nC++: VPUNN::VPUCostModel::DPU(struct VPUNN::DPUWorkload) const --> unsigned int", pybind11::arg("wl"));
		cl.def("DPUMsg", (class std::tuple<unsigned int, std::string > (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload) const) &VPUNN::VPUCostModel::DPUMsg, "same like  \n DPU(DPUWorkload wl) , the extra param is to have as output the textual errors/findings\n discovered when handling the workload\n \n\n the workload to infer on\n \n\n will collect error info regarding wl checking.\n\nC++: VPUNN::VPUCostModel::DPUMsg(struct VPUNN::DPUWorkload) const --> class std::tuple<unsigned int, std::string >", pybind11::arg("wl"));
		cl.def("DPU", (unsigned int (VPUNN::VPUCostModel::*)(struct VPUNN::DPUWorkload, std::string &) const) &VPUNN::VPUCostModel::DPU, "same like  \n DPU(DPUWorkload wl) , the extra param is to have as output the textual errors/findings\n discovered when handling the workload\n \n\n the workload to infer on\n \n\n [out] will collect error info regarding wl checking.\n\nC++: VPUNN::VPUCostModel::DPU(struct VPUNN::DPUWorkload, std::string &) const --> unsigned int", pybind11::arg("wl"), pybind11::arg("info"));
		cl.def("DPU", (class std::vector<unsigned int, class std::allocator<unsigned int> > (VPUNN::VPUCostModel::*)(class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> >) const) &VPUNN::VPUCostModel::DPU, "Return the number of cycles needed to compute multiple workloads\n\n \n a std::vector of DPUWorkload\n \n\n std::vector<CyclesInterfaceType> the DPUWorklaods execution cycles, \n DPU for single wl for more\n explanations\n\nC++: VPUNN::VPUCostModel::DPU(class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> >) const --> class std::vector<unsigned int, class std::allocator<unsigned int> >", pybind11::arg("workloads"));
		cl.def("DMA", [](VPUNN::VPUCostModel const &o, enum VPUNN::VPUDevice const & a0, const class VPUNN::VPUTensor & a1, const class VPUNN::VPUTensor & a2) -> unsigned int { return o.DMA(a0, a1, a2); }, "", pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output"));
		cl.def("DMA", [](VPUNN::VPUCostModel const &o, enum VPUNN::VPUDevice const & a0, const class VPUNN::VPUTensor & a1, const class VPUNN::VPUTensor & a2, enum VPUNN::MemoryLocation const & a3) -> unsigned int { return o.DMA(a0, a1, a2, a3); }, "", pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output"), pybind11::arg("input_location"));
		cl.def("DMA", [](VPUNN::VPUCostModel const &o, enum VPUNN::VPUDevice const & a0, const class VPUNN::VPUTensor & a1, const class VPUNN::VPUTensor & a2, enum VPUNN::MemoryLocation const & a3, enum VPUNN::MemoryLocation const & a4) -> unsigned int { return o.DMA(a0, a1, a2, a3, a4); }, "", pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output"), pybind11::arg("input_location"), pybind11::arg("output_location"));
		cl.def("DMA", (unsigned int (VPUNN::VPUCostModel::*)(enum VPUNN::VPUDevice, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &, enum VPUNN::MemoryLocation, enum VPUNN::MemoryLocation, unsigned int) const) &VPUNN::VPUCostModel::DMA, "Return the number of cycles needed to compute a DMA transfer\n\n \n DMA VPUDevice\n \n\n DMA input Tensor\n \n\n DMA output Tensor\n \n\n where is the source memory\n \n\n where is the destination memory\n \n\n how many CMX tiles the DMA broadcast\n \n\n unsigned int the number of cycles of the DMA transfer\n \n\n Will be removed in future releases\n\nC++: VPUNN::VPUCostModel::DMA(enum VPUNN::VPUDevice, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &, enum VPUNN::MemoryLocation, enum VPUNN::MemoryLocation, unsigned int) const --> unsigned int", pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output"), pybind11::arg("input_location"), pybind11::arg("output_location"), pybind11::arg("output_write_tiles"));
		cl.def("DMA", (unsigned int (VPUNN::VPUCostModel::*)(const struct VPUNN::DMAWorkload &) const) &VPUNN::VPUCostModel::DMA, "Return the number of cycles needed to compute a DMA transfer\n\n \n a DMAWorkload\n \n\n unsigned int the number of cycles of the DMA transfer\n \n\n Will be removed in future releases\n\nC++: VPUNN::VPUCostModel::DMA(const struct VPUNN::DMAWorkload &) const --> unsigned int", pybind11::arg("wl"));
		cl.def("SHAVE", (unsigned int (VPUNN::VPUCostModel::*)(const class VPUNN::SHAVEWorkload &, std::string &) const) &VPUNN::VPUCostModel::SHAVE, "Return the number of cycles needed to compute a Shave kernel\n\n \n a Shave workload contains: name of kernel, device, in out tensor. PLus optional parameters of the\n operations\n \n\n  a string that will contain informative error information (in case of error)\n \n\n the number of cycles of the Shave kernel, in DPU cycles of the desired device nominal frequency. OR ERROR\n\nC++: VPUNN::VPUCostModel::SHAVE(const class VPUNN::SHAVEWorkload &, std::string &) const --> unsigned int", pybind11::arg("shave_wl"), pybind11::arg("infoOut"));
		cl.def("SHAVE", (unsigned int (VPUNN::VPUCostModel::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::VPUCostModel::SHAVE, "C++: VPUNN::VPUCostModel::SHAVE(const class VPUNN::SHAVEWorkload &) const --> unsigned int", pybind11::arg("shave_wl"));
		cl.def("SHAVE", (unsigned int (VPUNN::VPUCostModel::*)(const class VPUNN::SHAVEWorkload &, std::string &, bool) const) &VPUNN::VPUCostModel::SHAVE, "Return the number of cycles needed to compute a Shave kernel without posibility of skipping Cache\n\n \n a Shave workload contains: name of kernel, device, in out tensor. PLus optional parameters of the\n operations\n \n\n  a string that will contain informative error information (in case of error)\n \n\n the number of cycles of the Shave kernel, in DPU cycles of the desired device nominal frequency. OR ERROR\n\nC++: VPUNN::VPUCostModel::SHAVE(const class VPUNN::SHAVEWorkload &, std::string &, bool) const --> unsigned int", pybind11::arg("shave_wl"), pybind11::arg("infoOut"), pybind11::arg("skipCacheValues"));
		cl.def("getShaveSupportedOperations", (class std::vector<std::string, class std::allocator<std::string > > (VPUNN::VPUCostModel::*)(enum VPUNN::VPUDevice) const) &VPUNN::VPUCostModel::getShaveSupportedOperations, "gets the list of names of supported operators on a specified device. Each device has own operators\n\n \n  for what device?\n \n\n container with the name of operators\n\nC++: VPUNN::VPUCostModel::getShaveSupportedOperations(enum VPUNN::VPUDevice) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("device"));
		cl.def("getShaveInstance", (const class VPUNN::ShaveOpExecutor & (VPUNN::VPUCostModel::*)(std::string, enum VPUNN::VPUDevice) const) &VPUNN::VPUCostModel::getShaveInstance, "provides a reference to the operator executor specified by name\n The executor can be used to execute (run) the runtime prediction on different tensors/parameters\n Or can be asked to print information about its implementation parameters\n\n \n of the operator\n \n\n name\n \n\n a ref (no ownership transfered. exists as long as this VPUCostModel instance exists)\n\nC++: VPUNN::VPUCostModel::getShaveInstance(std::string, enum VPUNN::VPUDevice) const --> const class VPUNN::ShaveOpExecutor &", pybind11::return_value_policy::reference, pybind11::arg("name"), pybind11::arg("device"));
		cl.def("isShave2ApiUsed", (bool (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::isShave2ApiUsed, "Checks if the SHAVE Gen 2 API is being used.\n \n\n True if the SHAVE Gen 2 API is used, otherwise false.\n\nC++: VPUNN::VPUCostModel::isShave2ApiUsed() const --> bool");
		cl.def("DPUEnergy", (float (VPUNN::VPUCostModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::VPUCostModel::DPUEnergy, "Compute the energy of a DPUWorkload.\n \n\n This is a relative energy metric with a time base in DPU clock cyles. Energy of\n 1000 would mean energy of worst case power for 1000 DPU clock cycles at reference dynamic power (power virus\n for INT08 operations). measured in PowerVirusJoules = PowerVirus*cycle\n \n\n a DPUWorkload\n \n\n float the DPUWorkload energy, measured  PowerVirus*cycle\n\nC++: VPUNN::VPUCostModel::DPUEnergy(const struct VPUNN::DPUWorkload &) const --> float", pybind11::arg("wl"));
		cl.def("SHAVEEnergy", (float (VPUNN::VPUCostModel::*)(const class VPUNN::SHAVEWorkload &) const) &VPUNN::VPUCostModel::SHAVEEnergy, "Compute the energy of a SHAVE SHAVEWorkload.\n \n\n Energy here is a relative metric, but the activity factor of the operation multiplied by\n          its cost (number of clock cycles). We assume a constant activity factor of 0.5 for all and a max\n          power of 5% of the DPU max power.\n\n \n a SHAVEWorkload\n \n\n float the operation energy, in units relative to DPU PowerVirus. WIl return zero in case of error\n\nC++: VPUNN::VPUCostModel::SHAVEEnergy(const class VPUNN::SHAVEWorkload &) const --> float", pybind11::arg("swl"));
		cl.def("DPUInfo", (struct VPUNN::DPUInfoPack (VPUNN::VPUCostModel::*)(const struct VPUNN::DPUWorkload &) const) &VPUNN::VPUCostModel::DPUInfo, "same like  \n DPU(DPUWorkload wl) but return a Pack of information regarding the workload\n The purpose of this Method is to replace several separate calls to individual informations about the same\n workload.\n For example , estimated  cycle-times, errors, energy, activity factor, all can be obtained in one call.\n This method has the potential to be more efficient that the collection of individual ones.\n \n\n the workload to infer on\n \n\n a Structure with all info that L1 APi can provide about this Workload\n\nC++: VPUNN::VPUCostModel::DPUInfo(const struct VPUNN::DPUWorkload &) const --> struct VPUNN::DPUInfoPack", pybind11::arg("workload"));
		cl.def("getDCiM_interface", (const class VPUNN::DCiMCostModelInterface<struct VPUNN::DCIMWorkload> & (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::getDCiM_interface, "//// Section for dCIM interfaces\n\nC++: VPUNN::VPUCostModel::getDCiM_interface() const --> const class VPUNN::DCiMCostModelInterface<struct VPUNN::DCIMWorkload> &", pybind11::return_value_policy::reference);
		cl.def("getPreloadedCacheCounter", (const class VPUNN::AccessCounter & (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::getPreloadedCacheCounter, "C++: VPUNN::VPUCostModel::getPreloadedCacheCounter() const --> const class VPUNN::AccessCounter &", pybind11::return_value_policy::reference);
		cl.def("getPreloadedShaveCacheCounter", (const class VPUNN::AccessCounter & (VPUNN::VPUCostModel::*)() const) &VPUNN::VPUCostModel::getPreloadedShaveCacheCounter, "C++: VPUNN::VPUCostModel::getPreloadedShaveCacheCounter() const --> const class VPUNN::AccessCounter &", pybind11::return_value_policy::reference);
	}
}


// File: VPUNN_62.cpp
#include <array> // std::array
#include <bits/refwrap.h> // std::reference_wrapper
#include <fstream> // std::basic_fstream
#include <functional> // std::equal_to
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <memory> // std::default_delete
#include <memory> // std::unique_ptr
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <unordered_map> // std::unordered_map
#include <unordered_set> // std::unordered_set
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IDPUTiler file: line:25
struct PyCallBack_VPUNN_IDPUTiler : public VPUNN::IDPUTiler {
	using VPUNN::IDPUTiler::IDPUTiler;

	using _binder_ret_0 = struct std::pair<unsigned int, class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > >;
	_binder_ret_0 intraTileSplit(const struct VPUNN::DPULayer & a0, const struct VPUNN::SplitOptions & a1, class std::vector<struct VPUNN::DPUWorkloadsWithCyclesSplit, class std::allocator<struct VPUNN::DPUWorkloadsWithCyclesSplit> > * a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDPUTiler *>(this), "intraTileSplit");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDPUTiler::intraTileSplit\"");
	}
	struct VPUNN::PnPEstimates getLayerPerformance(struct VPUNN::DPUWorkloadsWithCyclesSplit & a0, const unsigned int a1, const bool a2) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IDPUTiler *>(this), "getLayerPerformance");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1, a2);
			if (pybind11::detail::cast_is_temporary_value_reference<struct VPUNN::PnPEstimates>::value) {
				static pybind11::detail::override_caster_t<struct VPUNN::PnPEstimates> caster;
				return pybind11::detail::cast_ref<struct VPUNN::PnPEstimates>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<struct VPUNN::PnPEstimates>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IDPUTiler::getLayerPerformance\"");
	}
};

// VPUNN::IPreprocessingDMA file: line:33
struct PyCallBack_VPUNN_IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU27_t : public VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27> {
	using VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::IPreprocessingDMA;

	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU27 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPreprocessingDMA::generate_descriptor\"");
	}
	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPreprocessingDMA::interface_version\"");
	}
};

// VPUNN::IPreprocessingDMA file: line:33
struct PyCallBack_VPUNN_IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU40_50_t : public VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> {
	using VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::IPreprocessingDMA;

	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPreprocessingDMA::generate_descriptor\"");
	}
	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPreprocessingDMA::interface_version\"");
	}
};

// VPUNN::PreprocessingInserterDMA file: line:35
struct PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface01_DMA_float_VPUNN_DMANNWorkload_NPU27_t : public VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27> {
	using VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>::PreprocessingInserterDMA;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserterDMA::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU27 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserterDMA::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_62(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::VPUOptimizationTarget file: line:23
	pybind11::enum_<VPUNN::VPUOptimizationTarget>(M("VPUNN"), "VPUOptimizationTarget", "Available VPU workload generation optimization targets\n\n ")
		.value("LATENCY", VPUNN::VPUOptimizationTarget::LATENCY)
		.value("POWER", VPUNN::VPUOptimizationTarget::POWER)
		.value("EFFICIENCY", VPUNN::VPUOptimizationTarget::EFFICIENCY);

;

	// VPUNN::VPUSplitStrategy file: line:28
	pybind11::enum_<VPUNN::VPUSplitStrategy>(M("VPUNN"), "VPUSplitStrategy", "Available VPU splitting strategies\n\n ")
		.value("HW_TILING", VPUNN::VPUSplitStrategy::HW_TILING)
		.value("Z_TILING", VPUNN::VPUSplitStrategy::Z_TILING)
		.value("H_TILING", VPUNN::VPUSplitStrategy::H_TILING)
		.value("W_TILING", VPUNN::VPUSplitStrategy::W_TILING);

;

	{ // VPUNN::SplitOptions file: line:34
		pybind11::class_<VPUNN::SplitOptions, std::shared_ptr<VPUNN::SplitOptions>> cl(M("VPUNN"), "SplitOptions", "VPU splitting optimization configuration options\n Used to guide the splitting of a Layer to 1 or more DPUs");
		cl.def( pybind11::init( [](){ return new VPUNN::SplitOptions(); } ) );
		cl.def( pybind11::init( [](VPUNN::SplitOptions const &o){ return new VPUNN::SplitOptions(o); } ) );
		cl.def_readwrite("maxWorkloads", &VPUNN::SplitOptions::maxWorkloads);
		cl.def_readwrite("maxLatencyUs", &VPUNN::SplitOptions::maxLatencyUs);
		cl.def_readwrite("nDPU", &VPUNN::SplitOptions::nDPU);
		cl.def_readwrite("runtimeOverhead", &VPUNN::SplitOptions::runtimeOverhead);
		cl.def_readwrite("target", &VPUNN::SplitOptions::target);
		cl.def_readwrite("availableStrategies", &VPUNN::SplitOptions::availableStrategies);
	}
	{ // VPUNN::PnPEstimates file: line:52
		pybind11::class_<VPUNN::PnPEstimates, std::shared_ptr<VPUNN::PnPEstimates>> cl(M("VPUNN"), "PnPEstimates", "VPU Power and Performance estimates (cycles and power)");
		cl.def( pybind11::init( [](){ return new VPUNN::PnPEstimates(); } ) );
		cl.def_readwrite("cycles", &VPUNN::PnPEstimates::cycles);
		cl.def_readwrite("power", &VPUNN::PnPEstimates::power);
	}
	{ // VPUNN::IDPUTiler file: line:25
		pybind11::class_<VPUNN::IDPUTiler, std::shared_ptr<VPUNN::IDPUTiler>, PyCallBack_VPUNN_IDPUTiler> cl(M("VPUNN"), "IDPUTiler", "DPU Tiler interface");
		cl.def( pybind11::init( [](){ return new PyCallBack_VPUNN_IDPUTiler(); } ) );
		cl.def("intraTileSplit", [](VPUNN::IDPUTiler const &o, const struct VPUNN::DPULayer & a0, const struct VPUNN::SplitOptions & a1) -> std::pair<unsigned int, class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > > { return o.intraTileSplit(a0, a1); }, "", pybind11::arg("layer"), pybind11::arg("options"));
		cl.def("intraTileSplit", (struct std::pair<unsigned int, class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > > (VPUNN::IDPUTiler::*)(const struct VPUNN::DPULayer &, const struct VPUNN::SplitOptions &, class std::vector<struct VPUNN::DPUWorkloadsWithCyclesSplit, class std::allocator<struct VPUNN::DPUWorkloadsWithCyclesSplit> > *) const) &VPUNN::IDPUTiler::intraTileSplit, "Generate the optimal intra-tile split for a specific DPULayer\n \n\n This function takes the model, the layer to optimize and the nDPU as a parameter and returns the optimal\n workloads split. The information about the device, sparsity are encoded in the DPULayer type. The mode is part of\n the DPUWorkload structure\n\n \n DPULayer to optimize\n \n\n workload splits algorithm configuration options\n \n\n Output parameter, will be filled with full list of splits investigated\n \n\n DPUWorkloadsCost the optimal workloads split\n\nC++: VPUNN::IDPUTiler::intraTileSplit(const struct VPUNN::DPULayer &, const struct VPUNN::SplitOptions &, class std::vector<struct VPUNN::DPUWorkloadsWithCyclesSplit, class std::allocator<struct VPUNN::DPUWorkloadsWithCyclesSplit> > *) const --> struct std::pair<unsigned int, class std::vector<struct VPUNN::DPUWorkload, class std::allocator<struct VPUNN::DPUWorkload> > >", pybind11::arg("layer"), pybind11::arg("options"), pybind11::arg("complete_output_splits"));
		cl.def("getLayerPerformance", [](VPUNN::IDPUTiler const &o, struct VPUNN::DPUWorkloadsWithCyclesSplit & a0) -> VPUNN::PnPEstimates { return o.getLayerPerformance(a0); }, "", pybind11::arg("workloads_split"));
		cl.def("getLayerPerformance", [](VPUNN::IDPUTiler const &o, struct VPUNN::DPUWorkloadsWithCyclesSplit & a0, const unsigned int & a1) -> VPUNN::PnPEstimates { return o.getLayerPerformance(a0, a1); }, "", pybind11::arg("workloads_split"), pybind11::arg("runtimeOverhead"));
		cl.def("getLayerPerformance", (struct VPUNN::PnPEstimates (VPUNN::IDPUTiler::*)(struct VPUNN::DPUWorkloadsWithCyclesSplit &, const unsigned int, const bool) const) &VPUNN::IDPUTiler::getLayerPerformance, "Get the cycles and power estimate for a list of workloads.\n \n\n This function does not optimize any workloads\n but simply calculate the cost of that configuration. It is possible to pass an optional runtime overhead in\n cycles\n\n \n a vector of DPUWorkload\n \n\n execution runtime overhead in cycles (per workload)\n \n\n if true power will be zero, otherwise is calculated\n \n\n PnPEstimates power and performance estimate for the workloads\n\n \n exceptions from inner dependencies. like DPU invocation\n\nC++: VPUNN::IDPUTiler::getLayerPerformance(struct VPUNN::DPUWorkloadsWithCyclesSplit &, const unsigned int, const bool) const --> struct VPUNN::PnPEstimates", pybind11::arg("workloads_split"), pybind11::arg("runtimeOverhead"), pybind11::arg("skip_power"));
		cl.def("assign", (class VPUNN::IDPUTiler & (VPUNN::IDPUTiler::*)(const class VPUNN::IDPUTiler &)) &VPUNN::IDPUTiler::operator=, "C++: VPUNN::IDPUTiler::operator=(const class VPUNN::IDPUTiler &) --> class VPUNN::IDPUTiler &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	// VPUNN::getDPUTiler(class VPUNN::VPUCostModel &) file: line:71
	M("VPUNN").def("getDPUTiler", (class std::unique_ptr<class VPUNN::IDPUTiler, struct std::default_delete<class VPUNN::IDPUTiler> > (*)(class VPUNN::VPUCostModel &)) &VPUNN::getDPUTiler, "Factory function that generates a IDPUTiler instance\n\n \n a reference to a VPUCostModel object\n \n\n std::unique_ptr<IDPUTiler>\n\nC++: VPUNN::getDPUTiler(class VPUNN::VPUCostModel &) --> class std::unique_ptr<class VPUNN::IDPUTiler, struct std::default_delete<class VPUNN::IDPUTiler> >", pybind11::arg("_model"));

	{ // VPUNN::IPreprocessingDMA file: line:33
		pybind11::class_<VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>>, PyCallBack_VPUNN_IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU27_t> cl(M("VPUNN"), "IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def(pybind11::init<PyCallBack_VPUNN_IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU27_t const &>());
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformSingle(const struct VPUNN::DMANNWorkload_NPU27 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::IPreprocessingDMA file: line:33
		pybind11::class_<VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>>, PyCallBack_VPUNN_IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU40_50_t> cl(M("VPUNN"), "IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def(pybind11::init<PyCallBack_VPUNN_IPreprocessingDMA_float_VPUNN_DMANNWorkload_NPU40_50_t const &>());
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle(const struct VPUNN::DMANNWorkload_NPU40_50 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::InserterDMA file: line:28
		pybind11::class_<VPUNN::InserterDMA<float>, std::shared_ptr<VPUNN::InserterDMA<float>>> cl(M("VPUNN"), "InserterDMA_float_t", "");
		cl.def( pybind11::init( [](VPUNN::InserterDMA<float> const &o){ return new VPUNN::InserterDMA<float>(o); } ) );
		cl.def("one_hot", (unsigned long (VPUNN::InserterDMA<float>::*)(enum VPUNN::intf_dma_01x::MemoryDirection, unsigned long, unsigned long)) &VPUNN::InserterDMA<float>::one_hot<false,VPUNN::intf_dma_01x::MemoryDirection>, "C++: VPUNN::InserterDMA<float>::one_hot(enum VPUNN::intf_dma_01x::MemoryDirection, unsigned long, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"), pybind11::arg("category_size"));
		cl.def("one_hot", (unsigned long (VPUNN::InserterDMA<float>::*)(enum VPUNN::intf_dma_01x::Num_DMA_Engine, unsigned long, unsigned long)) &VPUNN::InserterDMA<float>::one_hot<false,VPUNN::intf_dma_01x::Num_DMA_Engine>, "C++: VPUNN::InserterDMA<float>::one_hot(enum VPUNN::intf_dma_01x::Num_DMA_Engine, unsigned long, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"), pybind11::arg("category_size"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(int, unsigned long)) &VPUNN::InserterDMA<float>::insert<false,int>, "C++: VPUNN::InserterDMA<float>::insert(int, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(enum VPUNN::intf_dma_01x::MemoryDirection, unsigned long)) &VPUNN::InserterDMA<float>::insert<false,VPUNN::intf_dma_01x::MemoryDirection>, "C++: VPUNN::InserterDMA<float>::insert(enum VPUNN::intf_dma_01x::MemoryDirection, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(float, unsigned long)) &VPUNN::InserterDMA<float>::insert<false,float>, "C++: VPUNN::InserterDMA<float>::insert(float, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(enum VPUNN::intf_dma_01x::Num_DMA_Engine, unsigned long)) &VPUNN::InserterDMA<float>::insert<false,VPUNN::intf_dma_01x::Num_DMA_Engine>, "C++: VPUNN::InserterDMA<float>::insert(enum VPUNN::intf_dma_01x::Num_DMA_Engine, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(unsigned int, unsigned long)) &VPUNN::InserterDMA<float>::insert<false>, "C++: VPUNN::InserterDMA<float>::insert(unsigned int, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(int, unsigned long)) &VPUNN::InserterDMA<float>::insert<false>, "C++: VPUNN::InserterDMA<float>::insert(int, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(bool, unsigned long)) &VPUNN::InserterDMA<float>::insert<false>, "C++: VPUNN::InserterDMA<float>::insert(bool, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
		cl.def("insert", (unsigned long (VPUNN::InserterDMA<float>::*)(const float &, unsigned long)) &VPUNN::InserterDMA<float>::insert<false>, "C++: VPUNN::InserterDMA<float>::insert(const float &, unsigned long) --> unsigned long", pybind11::arg("data"), pybind11::arg("offset"));
	}
	{ // VPUNN::PreprocessingInserterDMA file: line:35
		pybind11::class_<VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>>, PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface01_DMA_float_VPUNN_DMANNWorkload_NPU27_t, VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>> cl(M("VPUNN"), "PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface01_DMA_float_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface01_DMA_float_VPUNN_DMANNWorkload_NPU27_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface01_DMA_float_VPUNN_DMANNWorkload_NPU27_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27> const &o, const struct VPUNN::DMANNWorkload_NPU27 & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::interface_version, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, unsigned long &) const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::generate_descriptor, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::generate_descriptor(const struct VPUNN::DMANNWorkload_NPU27 &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformSingle(const struct VPUNN::DMANNWorkload_NPU27 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_63.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::PreprocessingInserterDMA file: line:35
struct PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface02_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t : public VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> {
	using VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::PreprocessingInserterDMA;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserterDMA::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserterDMA::generate_descriptor(a0, a1);
	}
};

// VPUNN::PreprocessingInserterDMA file: line:35
struct PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface03_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t : public VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> {
	using VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::PreprocessingInserterDMA;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserterDMA::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserterDMA::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_63(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::PreprocessingInserterDMA file: line:35
		pybind11::class_<VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>>, PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface02_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t, VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface02_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface02_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface02_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> const &o, const struct VPUNN::DMANNWorkload_NPU40_50 & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle(const struct VPUNN::DMANNWorkload_NPU40_50 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::PreprocessingInserterDMA file: line:35
		pybind11::class_<VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>>, PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface03_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t, VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface03_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init<unsigned long>(), pybind11::arg("size_of_descriptor") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface03_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t const &o){ return new PyCallBack_VPUNN_PreprocessingInserterDMA_float_VPUNN_Preprocessing_Interface03_DMA_float_VPUNN_DMANNWorkload_NPU40_50_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def("transformSingle", [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> const &o, const struct VPUNN::DMANNWorkload_NPU40_50 & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle(const struct VPUNN::DMANNWorkload_NPU40_50 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
}


// File: VPUNN_64.cpp
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::_Rb_tree_const_iterator
#include <map> // std::_Rb_tree_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_64(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// VPUNN::intf_dma_01x::mapFromText() file: line:49
	M("VPUNN::intf_dma_01x").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_dma_01x::mapFromText<VPUNN::intf_dma_01x::MemoryDirection>, "C++: VPUNN::intf_dma_01x::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_dma_01x::mapFromText() file: line:49
	M("VPUNN::intf_dma_01x").def("mapFromText", (const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > & (*)()) &VPUNN::intf_dma_01x::mapFromText<VPUNN::intf_dma_01x::Num_DMA_Engine>, "C++: VPUNN::intf_dma_01x::mapFromText() --> const class std::map<const std::string, const int, struct std::less<const std::string >, class std::allocator<struct std::pair<const std::string, const int> > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_dma_01x::MemoryLocation file: line:58
	pybind11::enum_<VPUNN::intf_dma_01x::MemoryLocation>(M("VPUNN::intf_dma_01x"), "MemoryLocation", "Memory locations\n\n ")
		.value("DRAM", VPUNN::intf_dma_01x::MemoryLocation::DRAM)
		.value("CMX", VPUNN::intf_dma_01x::MemoryLocation::CMX)
		.value("CSRAM", VPUNN::intf_dma_01x::MemoryLocation::CSRAM)
		.value("UPA", VPUNN::intf_dma_01x::MemoryLocation::UPA)
		.value("__size", VPUNN::intf_dma_01x::MemoryLocation::__size);

;

	// VPUNN::intf_dma_01x::mapToText() file: line:66
	M("VPUNN::intf_dma_01x").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_dma_01x::mapToText<VPUNN::intf_dma_01x::MemoryLocation>, "C++: VPUNN::intf_dma_01x::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_dma_01x::MemoryDirection file: line:75
	pybind11::enum_<VPUNN::intf_dma_01x::MemoryDirection>(M("VPUNN::intf_dma_01x"), "MemoryDirection", "Memory directions DDR <> CMX.\n Applies to DMA transfers\n\n ")
		.value("DDR2CMX", VPUNN::intf_dma_01x::MemoryDirection::DDR2CMX)
		.value("CMX2CMX", VPUNN::intf_dma_01x::MemoryDirection::CMX2CMX)
		.value("CMX2DDR", VPUNN::intf_dma_01x::MemoryDirection::CMX2DDR)
		.value("DDR2DDR", VPUNN::intf_dma_01x::MemoryDirection::DDR2DDR)
		.value("__size", VPUNN::intf_dma_01x::MemoryDirection::__size);

;

	// VPUNN::intf_dma_01x::mapToText() file: line:83
	M("VPUNN::intf_dma_01x").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_dma_01x::mapToText<VPUNN::intf_dma_01x::MemoryDirection>, "C++: VPUNN::intf_dma_01x::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_dma_01x::Num_DMA_Engine file: line:90
	pybind11::enum_<VPUNN::intf_dma_01x::Num_DMA_Engine>(M("VPUNN::intf_dma_01x"), "Num_DMA_Engine", "Number of DMA engine used")
		.value("Num_Engine_1", VPUNN::intf_dma_01x::Num_DMA_Engine::Num_Engine_1)
		.value("Num_Engine_2", VPUNN::intf_dma_01x::Num_DMA_Engine::Num_Engine_2)
		.value("__size", VPUNN::intf_dma_01x::Num_DMA_Engine::__size);

;

	// VPUNN::intf_dma_01x::mapToText() file: line:97
	M("VPUNN::intf_dma_01x").def("mapToText", (const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > & (*)()) &VPUNN::intf_dma_01x::mapToText<VPUNN::intf_dma_01x::Num_DMA_Engine>, "C++: VPUNN::intf_dma_01x::mapToText() --> const class std::map<const int, const std::string, struct std::less<const int>, class std::allocator<struct std::pair<const int, const std::string > > > &", pybind11::return_value_policy::reference);

	// VPUNN::intf_dma_01x::convert(enum VPUNN::MemoryDirection) file: line:109
	M("VPUNN::intf_dma_01x").def("convert", (enum VPUNN::intf_dma_01x::MemoryDirection (*)(enum VPUNN::MemoryDirection)) &VPUNN::intf_dma_01x::convert<VPUNN::intf_dma_01x::MemoryDirection,VPUNN::MemoryDirection>, "C++: VPUNN::intf_dma_01x::convert(enum VPUNN::MemoryDirection) --> enum VPUNN::intf_dma_01x::MemoryDirection", pybind11::arg("present_day_value_type"));

	// VPUNN::intf_dma_01x::convert(enum VPUNN::Num_DMA_Engine) file: line:109
	M("VPUNN::intf_dma_01x").def("convert", (enum VPUNN::intf_dma_01x::Num_DMA_Engine (*)(enum VPUNN::Num_DMA_Engine)) &VPUNN::intf_dma_01x::convert<VPUNN::intf_dma_01x::Num_DMA_Engine,VPUNN::Num_DMA_Engine>, "C++: VPUNN::intf_dma_01x::convert(enum VPUNN::Num_DMA_Engine) --> enum VPUNN::intf_dma_01x::Num_DMA_Engine", pybind11::arg("present_day_value_type"));

}


// File: VPUNN_65.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::Preprocessing_Interface01_DMA file: line:158
struct PyCallBack_VPUNN_Preprocessing_Interface01_DMA_float_t : public VPUNN::Preprocessing_Interface01_DMA<float> {
	using VPUNN::Preprocessing_Interface01_DMA<float>::Preprocessing_Interface01_DMA;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface01_DMA<float> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserterDMA::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU27 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface01_DMA<float> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserterDMA::generate_descriptor(a0, a1);
	}
};

// VPUNN::Preprocessing_Interface02_DMA file: line:217
struct PyCallBack_VPUNN_Preprocessing_Interface02_DMA_float_t : public VPUNN::Preprocessing_Interface02_DMA<float> {
	using VPUNN::Preprocessing_Interface02_DMA<float>::Preprocessing_Interface02_DMA;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface02_DMA<float> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserterDMA::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface02_DMA<float> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserterDMA::generate_descriptor(a0, a1);
	}
};

// VPUNN::Preprocessing_Interface03_DMA file: line:284
struct PyCallBack_VPUNN_Preprocessing_Interface03_DMA_float_t : public VPUNN::Preprocessing_Interface03_DMA<float> {
	using VPUNN::Preprocessing_Interface03_DMA<float>::Preprocessing_Interface03_DMA;

	int interface_version() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface03_DMA<float> *>(this), "interface_version");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<int>::value) {
				static pybind11::detail::override_caster_t<int> caster;
				return pybind11::detail::cast_ref<int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<int>(std::move(o));
		}
		return PreprocessingInserterDMA::interface_version();
	}
	using _binder_ret_0 = const class std::vector<float, class std::allocator<float> >;
	_binder_ret_0 generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, unsigned long & a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::Preprocessing_Interface03_DMA<float> *>(this), "generate_descriptor");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return PreprocessingInserterDMA::generate_descriptor(a0, a1);
	}
};

void bind_VPUNN_65(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::Inserter_Interface_DMA file: line:147
		pybind11::class_<VPUNN::Inserter_Interface_DMA<float>, std::shared_ptr<VPUNN::Inserter_Interface_DMA<float>>> cl(M("VPUNN"), "Inserter_Interface_DMA_float_t", "");
		cl.def( pybind11::init<class std::vector<float, class std::allocator<float> > &>(), pybind11::arg("output") );

		cl.def( pybind11::init( [](VPUNN::Inserter_Interface_DMA<float> const &o){ return new VPUNN::Inserter_Interface_DMA<float>(o); } ) );
	}
	{ // VPUNN::Preprocessing_Interface01_DMA file: line:158
		pybind11::class_<VPUNN::Preprocessing_Interface01_DMA<float>, std::shared_ptr<VPUNN::Preprocessing_Interface01_DMA<float>>, PyCallBack_VPUNN_Preprocessing_Interface01_DMA_float_t, VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>> cl(M("VPUNN"), "Preprocessing_Interface01_DMA_float_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface01_DMA<float>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface01_DMA_float_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface01_DMA_float_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface01_DMA_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface01_DMA<float> const &o){ return new VPUNN::Preprocessing_Interface01_DMA<float>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface01_DMA<float>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface01_DMA<float>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27> const &o, const struct VPUNN::DMANNWorkload_NPU27 & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::interface_version, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface01_DMA<float>,VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, unsigned long &) const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::generate_descriptor, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface01_DMA<float>, VPUNN::DMANNWorkload_NPU27>::generate_descriptor(const struct VPUNN::DMANNWorkload_NPU27 &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformSingle(const struct VPUNN::DMANNWorkload_NPU27 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU27>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU27>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU27, class std::allocator<struct VPUNN::DMANNWorkload_NPU27> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::Preprocessing_Interface02_DMA file: line:217
		pybind11::class_<VPUNN::Preprocessing_Interface02_DMA<float>, std::shared_ptr<VPUNN::Preprocessing_Interface02_DMA<float>>, PyCallBack_VPUNN_Preprocessing_Interface02_DMA_float_t, VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "Preprocessing_Interface02_DMA_float_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface02_DMA<float>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface02_DMA_float_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface02_DMA_float_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface02_DMA_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface02_DMA<float> const &o){ return new VPUNN::Preprocessing_Interface02_DMA<float>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface02_DMA<float>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface02_DMA<float>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> const &o, const struct VPUNN::DMANNWorkload_NPU40_50 & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface02_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface02_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle(const struct VPUNN::DMANNWorkload_NPU40_50 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::Preprocessing_Interface03_DMA file: line:284
		pybind11::class_<VPUNN::Preprocessing_Interface03_DMA<float>, std::shared_ptr<VPUNN::Preprocessing_Interface03_DMA<float>>, PyCallBack_VPUNN_Preprocessing_Interface03_DMA_float_t, VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "Preprocessing_Interface03_DMA_float_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::Preprocessing_Interface03_DMA<float>(); }, [](){ return new PyCallBack_VPUNN_Preprocessing_Interface03_DMA_float_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_Preprocessing_Interface03_DMA_float_t const &o){ return new PyCallBack_VPUNN_Preprocessing_Interface03_DMA_float_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::Preprocessing_Interface03_DMA<float> const &o){ return new VPUNN::Preprocessing_Interface03_DMA<float>(o); } ) );
		cl.def_static("getInterfaceVersion", (int (*)()) &VPUNN::Preprocessing_Interface03_DMA<float>::getInterfaceVersion, "C++: VPUNN::Preprocessing_Interface03_DMA<float>::getInterfaceVersion() --> int");
		cl.def("transformSingle", [](VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50> const &o, const struct VPUNN::DMANNWorkload_NPU40_50 & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformSingle(a0); }, "", pybind11::arg("workload"));
		cl.def("interface_version", (int (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("generate_descriptor", (const class std::vector<float, class std::allocator<float> > (VPUNN::PreprocessingInserterDMA<float,VPUNN::Preprocessing_Interface03_DMA<float>,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const) &VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor, "C++: VPUNN::PreprocessingInserterDMA<float, VPUNN::Preprocessing_Interface03_DMA<float>, VPUNN::DMANNWorkload_NPU40_50>::generate_descriptor(const struct VPUNN::DMANNWorkload_NPU40_50 &, unsigned long &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"), pybind11::arg("debug_offset"));
		cl.def("interface_version", (int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::interface_version() const --> int");
		cl.def("output_size", (unsigned int (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::output_size() const --> unsigned int");
		cl.def("transformSingle", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformSingle(const struct VPUNN::DMANNWorkload_NPU40_50 &) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workload"));
		cl.def("transformBatch", [](VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50> const &o, const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > & a0) -> const std::vector<float, class std::allocator<float> > { return o.transformBatch(a0); }, "", pybind11::arg("workloads"));
		cl.def("transformBatch", (const class std::vector<float, class std::allocator<float> > (VPUNN::IPreprocessingDMA<float,VPUNN::DMANNWorkload_NPU40_50>::*)(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const) &VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch, "C++: VPUNN::IPreprocessingDMA<float, VPUNN::DMANNWorkload_NPU40_50>::transformBatch(const class std::vector<struct VPUNN::DMANNWorkload_NPU40_50, class std::allocator<struct VPUNN::DMANNWorkload_NPU40_50> > &, unsigned int) const --> const class std::vector<float, class std::allocator<float> >", pybind11::arg("workloads"), pybind11::arg("pad"));
	}
	{ // VPUNN::DMAVersionsMapTypes file: line:26
		pybind11::class_<VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>>> cl(M("VPUNN"), "DMAVersionsMapTypes_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>(); } ) );
		cl.def("assign", (class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU27> & (VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>::*)(const class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU27> &)) &VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>::operator=, "C++: VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU27>::operator=(const class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU27> &) --> class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU27> &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::DMAVersionsMapTypes file: line:26
		pybind11::class_<VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>>> cl(M("VPUNN"), "DMAVersionsMapTypes_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>(); } ) );
		cl.def("assign", (class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU40_50> & (VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>::*)(const class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU40_50> &)) &VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>::operator=, "C++: VPUNN::DMAVersionsMapTypes<VPUNN::DMANNWorkload_NPU40_50>::operator=(const class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU40_50> &) --> class VPUNN::DMAVersionsMapTypes<struct VPUNN::DMANNWorkload_NPU40_50> &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
}


// File: VPUNN_66.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::IPostProcessDMA file: line:18
struct PyCallBack_VPUNN_IPostProcessDMA_VPUNN_DMANNWorkload_NPU27_t : public VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27> {
	using VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::IPostProcessDMA;

	unsigned int process(const struct VPUNN::DMANNWorkload_NPU27 & a0, float a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27> *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPostProcessDMA::process\"");
	}
};

// VPUNN::IPostProcessDMA file: line:18
struct PyCallBack_VPUNN_IPostProcessDMA_VPUNN_DMANNWorkload_NPU40_50_t : public VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50> {
	using VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::IPostProcessDMA;

	unsigned int process(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, float a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50> *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		pybind11::pybind11_fail("Tried to call pure virtual function \"IPostProcessDMA::process\"");
	}
};

void bind_VPUNN_66(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::DMAVersionsMap file: line:36
		pybind11::class_<VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU27>>> cl(M("VPUNN"), "DMAVersionsMap_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU27>(); } ) );
		cl.def_readonly("pp_map", &VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU27>::pp_map);
	}
	{ // VPUNN::DMAVersionsMap file: line:47
		pybind11::class_<VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU40_50>>> cl(M("VPUNN"), "DMAVersionsMap_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU40_50>(); } ) );
		cl.def_readonly("pp_map", &VPUNN::DMAVersionsMap<VPUNN::DMANNWorkload_NPU40_50>::pp_map);
	}
	{ // VPUNN::DMARuntimeProcessingFactory file: line:65
		pybind11::class_<VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>>> cl(M("VPUNN"), "DMARuntimeProcessingFactory_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>(); } ) );
		cl.def("exists_preprocessing", (bool (VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>::*)(int) const) &VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>::exists_preprocessing, "C++: VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>::exists_preprocessing(int) const --> bool", pybind11::arg("input_version"));
		cl.def("make_preprocessing", (class VPUNN::IPreprocessingDMA<float, struct VPUNN::DMANNWorkload_NPU27> & (VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>::*)(int) const) &VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>::make_preprocessing, "C++: VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU27>::make_preprocessing(int) const --> class VPUNN::IPreprocessingDMA<float, struct VPUNN::DMANNWorkload_NPU27> &", pybind11::return_value_policy::reference, pybind11::arg("version"));
	}
	{ // VPUNN::DMARuntimeProcessingFactory file: line:65
		pybind11::class_<VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>>> cl(M("VPUNN"), "DMARuntimeProcessingFactory_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>(); } ) );
		cl.def("exists_preprocessing", (bool (VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::*)(int) const) &VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::exists_preprocessing, "C++: VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::exists_preprocessing(int) const --> bool", pybind11::arg("input_version"));
		cl.def("make_preprocessing", (class VPUNN::IPreprocessingDMA<float, struct VPUNN::DMANNWorkload_NPU40_50> & (VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::*)(int) const) &VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::make_preprocessing, "C++: VPUNN::DMARuntimeProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::make_preprocessing(int) const --> class VPUNN::IPreprocessingDMA<float, struct VPUNN::DMANNWorkload_NPU40_50> &", pybind11::return_value_policy::reference, pybind11::arg("version"));
	}
	// VPUNN::memoryLocation(enum VPUNN::VPUDevice) file: line:39
	M("VPUNN").def("memoryLocation", (class std::vector<enum VPUNN::MemoryLocation, class std::allocator<enum VPUNN::MemoryLocation> > (*)(enum VPUNN::VPUDevice)) &VPUNN::memoryLocation, "Return the available memory locations per VPU IP generation\n\n \n a VPUDevice representing the VPU IP generation\n \n\n std::vector<MemoryLocation>\n\nC++: VPUNN::memoryLocation(enum VPUNN::VPUDevice) --> class std::vector<enum VPUNN::MemoryLocation, class std::allocator<enum VPUNN::MemoryLocation> >", pybind11::arg("device"));

	// VPUNN::isMemoryLocationAvailable(enum VPUNN::VPUDevice, enum VPUNN::MemoryLocation) file: line:58
	M("VPUNN").def("isMemoryLocationAvailable", (bool (*)(enum VPUNN::VPUDevice, enum VPUNN::MemoryLocation)) &VPUNN::isMemoryLocationAvailable, "Check if a memory location is available for a specific VPU IP generation\n\n \n a VPUDevice representing the VPU IP generation\n \n\n a memory location\n \n\n true\n \n\n false\n\nC++: VPUNN::isMemoryLocationAvailable(enum VPUNN::VPUDevice, enum VPUNN::MemoryLocation) --> bool", pybind11::arg("device"), pybind11::arg("location"));

	{ // VPUNN::DMAWorkloadTransformer file: line:87
		pybind11::class_<VPUNN::DMAWorkloadTransformer, std::shared_ptr<VPUNN::DMAWorkloadTransformer>> cl(M("VPUNN"), "DMAWorkloadTransformer", "Transforms from one workload to another");
		cl.def( pybind11::init( [](){ return new VPUNN::DMAWorkloadTransformer(); } ) );
		cl.def_static("create_workload", (struct VPUNN::DMAWorkload (*)(const struct VPUNN::DMAWorkload &)) &VPUNN::DMAWorkloadTransformer::create_workload<VPUNN::DMAWorkload>, "Explicit specialization for DMAWorkload\n\nC++: VPUNN::DMAWorkloadTransformer::create_workload(const struct VPUNN::DMAWorkload &) --> struct VPUNN::DMAWorkload", pybind11::arg("dma_nn"));
		cl.def_static("create_workload", (struct VPUNN::DMAWorkload (*)(const struct VPUNN::DMANNWorkload_NPU40_50 &)) &VPUNN::DMAWorkloadTransformer::create_workload<VPUNN::DMANNWorkload_NPU40_50>, "C++: VPUNN::DMAWorkloadTransformer::create_workload(const struct VPUNN::DMANNWorkload_NPU40_50 &) --> struct VPUNN::DMAWorkload", pybind11::arg("dma_nn"));
		cl.def_static("create_workload", (struct VPUNN::DMAWorkload (*)(const struct VPUNN::DMANNWorkload_NPU27 &)) &VPUNN::DMAWorkloadTransformer::create_workload<VPUNN::DMANNWorkload_NPU27>, "C++: VPUNN::DMAWorkloadTransformer::create_workload(const struct VPUNN::DMANNWorkload_NPU27 &) --> struct VPUNN::DMAWorkload", pybind11::arg("dma_nn"));
		cl.def_static("create_workload", (struct VPUNN::DMANNWorkload_NPU27 (*)(const struct VPUNN::DMAWorkload &)) &VPUNN::DMAWorkloadTransformer::create_workload, "creates a DMANNWorkload from a DMAWorkload if possible.\n The DMA workload has to be a simple transfer without datatype change, layout change or size change.\n The resulted DMANNWorkload will have all data in one plane!\n NN Model was trained only for :  TASK.TYPE=1 , 2D transfer where LEN = *WIDTH = Byte transferred\n\n \n created DMANNWorkload with all data in only one plane\n \n\n  std::runtime_error in case the preconditions are not met for a simple DMA\n\nC++: VPUNN::DMAWorkloadTransformer::create_workload(const struct VPUNN::DMAWorkload &) --> struct VPUNN::DMANNWorkload_NPU27", pybind11::arg("dma"));
		cl.def_static("create_NPU27_workload", (struct VPUNN::DMANNWorkload_NPU27 (*)(const struct VPUNN::DMAWorkload &)) &VPUNN::DMAWorkloadTransformer::create_NPU27_workload, "C++: VPUNN::DMAWorkloadTransformer::create_NPU27_workload(const struct VPUNN::DMAWorkload &) --> struct VPUNN::DMANNWorkload_NPU27", pybind11::arg("dma"));
		cl.def_static("create_NPU40_50_workload", (struct VPUNN::DMANNWorkload_NPU40_50 (*)(const struct VPUNN::DMAWorkload &)) &VPUNN::DMAWorkloadTransformer::create_NPU40_50_workload, "you can use this function both to create DMANNWorkload_NPU40 and DMANNWorkload_NPU50\n\nC++: VPUNN::DMAWorkloadTransformer::create_NPU40_50_workload(const struct VPUNN::DMAWorkload &) --> struct VPUNN::DMANNWorkload_NPU40_50", pybind11::arg("dma"));
		cl.def_static("create_NPU40_workload", (struct VPUNN::DMANNWorkload_NPU40_50 (*)(const struct VPUNN::DMAWorkload &)) &VPUNN::DMAWorkloadTransformer::create_NPU40_workload, "C++: VPUNN::DMAWorkloadTransformer::create_NPU40_workload(const struct VPUNN::DMAWorkload &) --> struct VPUNN::DMANNWorkload_NPU40_50", pybind11::arg("dma"));
		cl.def_static("create_NPU50_workload", (struct VPUNN::DMANNWorkload_NPU40_50 (*)(const struct VPUNN::DMAWorkload &)) &VPUNN::DMAWorkloadTransformer::create_NPU50_workload, "C++: VPUNN::DMAWorkloadTransformer::create_NPU50_workload(const struct VPUNN::DMAWorkload &) --> struct VPUNN::DMANNWorkload_NPU40_50", pybind11::arg("dma"));
		cl.def_static("create_direction", (enum VPUNN::MemoryDirection (*)(const enum VPUNN::MemoryLocation &, const enum VPUNN::MemoryLocation &)) &VPUNN::DMAWorkloadTransformer::create_direction, "C++: VPUNN::DMAWorkloadTransformer::create_direction(const enum VPUNN::MemoryLocation &, const enum VPUNN::MemoryLocation &) --> enum VPUNN::MemoryDirection", pybind11::arg("from"), pybind11::arg("to"));
		cl.def_static("create_locations", (struct std::pair<enum VPUNN::MemoryLocation, enum VPUNN::MemoryLocation> (*)(const enum VPUNN::MemoryDirection &)) &VPUNN::DMAWorkloadTransformer::create_locations, "C++: VPUNN::DMAWorkloadTransformer::create_locations(const enum VPUNN::MemoryDirection &) --> struct std::pair<enum VPUNN::MemoryLocation, enum VPUNN::MemoryLocation>", pybind11::arg("direction"));
	}
	{ // VPUNN::DMANNWorkloadCreator file: line:275
		pybind11::class_<VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU27>>> cl(M("VPUNN"), "DMANNWorkloadCreator_VPUNN_DMANNWorkload_NPU27_t", "Specialization for DMANNWorkload_NPU27");
		cl.def( pybind11::init( [](){ return new VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU27>(); } ) );
		cl.def_static("create_workload", (struct VPUNN::DMANNWorkload_NPU27 (*)(const struct VPUNN::DMATransfer1D &)) &VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU27>::create_workload, "C++: VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU27>::create_workload(const struct VPUNN::DMATransfer1D &) --> struct VPUNN::DMANNWorkload_NPU27", pybind11::arg("dma"));
	}
	{ // VPUNN::DMANNWorkloadCreator file: line:307
		pybind11::class_<VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU40_50>>> cl(M("VPUNN"), "DMANNWorkloadCreator_VPUNN_DMANNWorkload_NPU40_50_t", "Specialization for DMANNWorkload_NPU40_50");
		cl.def( pybind11::init( [](){ return new VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU40_50>(); } ) );
		cl.def_static("create_workload", (struct VPUNN::DMANNWorkload_NPU40_50 (*)(const struct VPUNN::DMATransfer1D &)) &VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU40_50>::create_workload, "C++: VPUNN::DMANNWorkloadCreator<VPUNN::DMANNWorkload_NPU40_50>::create_workload(const struct VPUNN::DMATransfer1D &) --> struct VPUNN::DMANNWorkload_NPU40_50", pybind11::arg("dma"));
	}
	// VPUNN::convert_dma1d_2_dmawl(const struct VPUNN::DMATransfer1D &) file: line:379
	M("VPUNN").def("convert_dma1d_2_dmawl", (struct VPUNN::DMAWorkload (*)(const struct VPUNN::DMATransfer1D &)) &VPUNN::convert_dma1d_2_dmawl, "Convert a DMATransfer1D to a DMAWorkload to be used by DMA theoretical model.\n \n\n will be removed with DMAWorkload\n\nC++: VPUNN::convert_dma1d_2_dmawl(const struct VPUNN::DMATransfer1D &) --> struct VPUNN::DMAWorkload", pybind11::arg("dma"));

	// VPUNN::DMAOutputVersions file: line:23
	pybind11::enum_<VPUNN::DMAOutputVersions>(M("VPUNN"), "DMAOutputVersions", "enum for DMA NN output versions")
		.value("OUT_BANDWIDTH_UTILIZATION", VPUNN::DMAOutputVersions::OUT_BANDWIDTH_UTILIZATION)
		.value("OUT_CYCLES_DIRECT", VPUNN::DMAOutputVersions::OUT_CYCLES_DIRECT);

;

	{ // VPUNN::DMAPostProcessSupport file: line:34
		pybind11::class_<VPUNN::DMAPostProcessSupport, std::shared_ptr<VPUNN::DMAPostProcessSupport>> cl(M("VPUNN"), "DMAPostProcessSupport", "Configuration options concerning the interpretation and post processing of inferred values\n This class have the goal to check if we know something about the output version of the model and if we don't know we\n will not support the output for the DMA. We are going to use the output version parsed by the ModelVersion and\n use it to determine based on known output version if we support it or not. In case that we don't know the version we\n are going to not support the output.");
		cl.def( pybind11::init<int>(), pybind11::arg("output_version") );

		cl.def( pybind11::init( [](VPUNN::DMAPostProcessSupport const &o){ return new VPUNN::DMAPostProcessSupport(o); } ) );
		cl.def("is_output_supported", (bool (VPUNN::DMAPostProcessSupport::*)() const) &VPUNN::DMAPostProcessSupport::is_output_supported, "a method to see if we support the output\n\nC++: VPUNN::DMAPostProcessSupport::is_output_supported() const --> bool");
	}
	{ // VPUNN::IPostProcessDMA file: line:18
		pybind11::class_<VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>>, PyCallBack_VPUNN_IPostProcessDMA_VPUNN_DMANNWorkload_NPU27_t> cl(M("VPUNN"), "IPostProcessDMA_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init<float, float>(), pybind11::arg("low_threshold_"), pybind11::arg("high_threshold_") );

		cl.def(pybind11::init<PyCallBack_VPUNN_IPostProcessDMA_VPUNN_DMANNWorkload_NPU27_t const &>());
		cl.def("process", (unsigned int (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::process, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::process(const struct VPUNN::DMANNWorkload_NPU27 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg(""));
		cl.def("is_NN_value_invalid", (bool (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)(float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::is_NN_value_invalid, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::is_NN_value_invalid(float) const --> bool", pybind11::arg("nn_output_cycles"));
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
	}
	{ // VPUNN::IPostProcessDMA file: line:18
		pybind11::class_<VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>>, PyCallBack_VPUNN_IPostProcessDMA_VPUNN_DMANNWorkload_NPU40_50_t> cl(M("VPUNN"), "IPostProcessDMA_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init<float, float>(), pybind11::arg("low_threshold_"), pybind11::arg("high_threshold_") );

		cl.def(pybind11::init<PyCallBack_VPUNN_IPostProcessDMA_VPUNN_DMANNWorkload_NPU40_50_t const &>());
		cl.def("process", (unsigned int (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::process, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::process(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg(""));
		cl.def("is_NN_value_invalid", (bool (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)(float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::is_NN_value_invalid, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::is_NN_value_invalid(float) const --> bool", pybind11::arg("nn_output_cycles"));
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
	}
}


// File: VPUNN_67.cpp
#include <array> // std::array
#include <bits/refwrap.h> // std::reference_wrapper
#include <fstream> // std::basic_fstream
#include <functional> // std::equal_to
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <unordered_map> // std::unordered_map
#include <unordered_set> // std::unordered_set
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::ConvertFromSizeDivCycleToDPUCyc file: line:50
struct PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t : public VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27> {
	using VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::ConvertFromSizeDivCycleToDPUCyc;

	unsigned int process(const struct VPUNN::DMANNWorkload_NPU27 & a0, float a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27> *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ConvertFromSizeDivCycleToDPUCyc::process(a0, a1);
	}
};

// VPUNN::ConvertFromSizeDivCycleToDPUCyc file: line:50
struct PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t : public VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50> {
	using VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::ConvertFromSizeDivCycleToDPUCyc;

	unsigned int process(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, float a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50> *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ConvertFromSizeDivCycleToDPUCyc::process(a0, a1);
	}
};

// VPUNN::ConvertFromDirectCycleToDPUCyc file: line:94
struct PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t : public VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27> {
	using VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::ConvertFromDirectCycleToDPUCyc;

	unsigned int process(const struct VPUNN::DMANNWorkload_NPU27 & a0, float a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27> *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ConvertFromDirectCycleToDPUCyc::process(a0, a1);
	}
};

// VPUNN::ConvertFromDirectCycleToDPUCyc file: line:94
struct PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t : public VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50> {
	using VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::ConvertFromDirectCycleToDPUCyc;

	unsigned int process(const struct VPUNN::DMANNWorkload_NPU40_50 & a0, float a1) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50> *>(this), "process");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return ConvertFromDirectCycleToDPUCyc::process(a0, a1);
	}
};

void bind_VPUNN_67(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::ConvertFromSizeDivCycleToDPUCyc file: line:50
		pybind11::class_<VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>>, PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t, VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>> cl(M("VPUNN"), "ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>(); }, [](){ return new PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t const &o){ return new PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def("process", (unsigned int (VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, float) const) &VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::process, "C++: VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::process(const struct VPUNN::DMANNWorkload_NPU27 &, float) const --> unsigned int", pybind11::arg("wl"), pybind11::arg("nn_size_div_cycle"));
		cl.def("process", (unsigned int (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::process, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::process(const struct VPUNN::DMANNWorkload_NPU27 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg(""));
		cl.def("is_NN_value_invalid", (bool (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)(float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::is_NN_value_invalid, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::is_NN_value_invalid(float) const --> bool", pybind11::arg("nn_output_cycles"));
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
	}
	{ // VPUNN::ConvertFromSizeDivCycleToDPUCyc file: line:50
		pybind11::class_<VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>>, PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t, VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>(); }, [](){ return new PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t const &o){ return new PyCallBack_VPUNN_ConvertFromSizeDivCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def("process", (unsigned int (VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const) &VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::process, "C++: VPUNN::ConvertFromSizeDivCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::process(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const --> unsigned int", pybind11::arg("wl"), pybind11::arg("nn_size_div_cycle"));
		cl.def("process", (unsigned int (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::process, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::process(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg(""));
		cl.def("is_NN_value_invalid", (bool (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)(float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::is_NN_value_invalid, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::is_NN_value_invalid(float) const --> bool", pybind11::arg("nn_output_cycles"));
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
	}
	{ // VPUNN::ConvertFromDirectCycleToDPUCyc file: line:94
		pybind11::class_<VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>>, PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t, VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>> cl(M("VPUNN"), "ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>(); }, [](){ return new PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t const &o){ return new PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU27_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def("process", (unsigned int (VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, float) const) &VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::process, "C++: VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU27>::process(const struct VPUNN::DMANNWorkload_NPU27 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg("nn_direct_cycles"));
		cl.def("process", (unsigned int (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::process, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::process(const struct VPUNN::DMANNWorkload_NPU27 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg(""));
		cl.def("is_NN_value_invalid", (bool (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)(float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::is_NN_value_invalid, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::is_NN_value_invalid(float) const --> bool", pybind11::arg("nn_output_cycles"));
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
	}
	{ // VPUNN::ConvertFromDirectCycleToDPUCyc file: line:94
		pybind11::class_<VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>>, PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t, VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>> cl(M("VPUNN"), "ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>(); }, [](){ return new PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t(); } ) );
		cl.def( pybind11::init( [](PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t const &o){ return new PyCallBack_VPUNN_ConvertFromDirectCycleToDPUCyc_VPUNN_DMANNWorkload_NPU40_50_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def("process", (unsigned int (VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const) &VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::process, "C++: VPUNN::ConvertFromDirectCycleToDPUCyc<VPUNN::DMANNWorkload_NPU40_50>::process(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg("nn_direct_cycles"));
		cl.def("process", (unsigned int (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::process, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::process(const struct VPUNN::DMANNWorkload_NPU40_50 &, float) const --> unsigned int", pybind11::arg(""), pybind11::arg(""));
		cl.def("is_NN_value_invalid", (bool (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)(float) const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::is_NN_value_invalid, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::is_NN_value_invalid(float) const --> bool", pybind11::arg("nn_output_cycles"));
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval, "C++: VPUNN::IPostProcessDMA<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
	}
	{ // VPUNN::DMAPostProcessingFactory file: line:29
		pybind11::class_<VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>>> cl(M("VPUNN"), "DMAPostProcessingFactory_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27> const &o){ return new VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>(); } ) );
		cl.def("exists", (bool (VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>::*)(int) const) &VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>::exists, "C++: VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>::exists(int) const --> bool", pybind11::arg("version"));
		cl.def("make", (const class VPUNN::IPostProcessDMA<struct VPUNN::DMANNWorkload_NPU27> & (VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>::*)(int) const) &VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>::make, "C++: VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU27>::make(int) const --> const class VPUNN::IPostProcessDMA<struct VPUNN::DMANNWorkload_NPU27> &", pybind11::return_value_policy::reference, pybind11::arg("version"));
	}
	{ // VPUNN::DMAPostProcessingFactory file: line:29
		pybind11::class_<VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>>> cl(M("VPUNN"), "DMAPostProcessingFactory_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50> const &o){ return new VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>(o); } ) );
		cl.def( pybind11::init( [](){ return new VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>(); } ) );
		cl.def("exists", (bool (VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::*)(int) const) &VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::exists, "C++: VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::exists(int) const --> bool", pybind11::arg("version"));
		cl.def("make", (const class VPUNN::IPostProcessDMA<struct VPUNN::DMANNWorkload_NPU40_50> & (VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::*)(int) const) &VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::make, "C++: VPUNN::DMAPostProcessingFactory<VPUNN::DMANNWorkload_NPU40_50>::make(int) const --> const class VPUNN::IPostProcessDMA<struct VPUNN::DMANNWorkload_NPU40_50> &", pybind11::return_value_policy::reference, pybind11::arg("version"));
	}
	{ // VPUNN::DMACostSerializationWrap file: line:16
		pybind11::class_<VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>>, VPUNN::CostSerializationWrap> cl(M("VPUNN"), "DMACostSerializationWrap_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def("serializeDMAWorkload_closeLine", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeDMAWorkload_closeLine, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeDMAWorkload_closeLine(const struct VPUNN::DMANNWorkload_NPU40_50 &) --> void", pybind11::arg("workload"));
		cl.def("serializeDMAWorkload", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeDMAWorkload, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeDMAWorkload(const struct VPUNN::DMANNWorkload_NPU40_50 &) --> void", pybind11::arg("workload"));
		cl.def("serializeCycles", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::*)(const unsigned int)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeCycles, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeCycles(const unsigned int) --> void", pybind11::arg("cycles"));
		cl.def("serializeCyclesAndCostInfo_closeLine", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::*)(const unsigned int, const std::string, const std::string &)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeCyclesAndCostInfo_closeLine, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU40_50>::serializeCyclesAndCostInfo_closeLine(const unsigned int, const std::string, const std::string &) --> void", pybind11::arg("cycles"), pybind11::arg("cost_source"), pybind11::arg("info"));
		cl.def("serializeCycles_closeLine", (void (VPUNN::CostSerializationWrap::*)(unsigned int)) &VPUNN::CostSerializationWrap::serializeCycles_closeLine, "vpunn_cycles\n\nC++: VPUNN::CostSerializationWrap::serializeCycles_closeLine(unsigned int) --> void", pybind11::arg("cost"));
	}
	{ // VPUNN::DMACostSerializationWrap file: line:16
		pybind11::class_<VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>>, VPUNN::CostSerializationWrap> cl(M("VPUNN"), "DMACostSerializationWrap_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def("serializeDMAWorkload_closeLine", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeDMAWorkload_closeLine, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeDMAWorkload_closeLine(const struct VPUNN::DMANNWorkload_NPU27 &) --> void", pybind11::arg("workload"));
		cl.def("serializeDMAWorkload", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeDMAWorkload, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeDMAWorkload(const struct VPUNN::DMANNWorkload_NPU27 &) --> void", pybind11::arg("workload"));
		cl.def("serializeCycles", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::*)(const unsigned int)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeCycles, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeCycles(const unsigned int) --> void", pybind11::arg("cycles"));
		cl.def("serializeCyclesAndCostInfo_closeLine", (void (VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::*)(const unsigned int, const std::string, const std::string &)) &VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeCyclesAndCostInfo_closeLine, "C++: VPUNN::DMACostSerializationWrap<VPUNN::DMANNWorkload_NPU27>::serializeCyclesAndCostInfo_closeLine(const unsigned int, const std::string, const std::string &) --> void", pybind11::arg("cycles"), pybind11::arg("cost_source"), pybind11::arg("info"));
		cl.def("serializeCycles_closeLine", (void (VPUNN::CostSerializationWrap::*)(unsigned int)) &VPUNN::CostSerializationWrap::serializeCycles_closeLine, "vpunn_cycles\n\nC++: VPUNN::CostSerializationWrap::serializeCycles_closeLine(unsigned int) --> void", pybind11::arg("cost"));
	}
}


// File: VPUNN_68.cpp
#include <array> // std::array
#include <ios> // (anonymous)
#include <ios> // std::_Ios_Openmode
#include <ios> // std::_Ios_Seekdir
#include <ios> // std::fpos
#include <iterator> // __gnu_cxx::__normal_iterator
#include <locale> // std::locale
#include <memory> // std::allocator
#include <ostream> // std::basic_ostream
#include <sstream> // __str__
#include <streambuf> // std::basic_streambuf
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::LayerProperties_All_Devices file: line:125
struct PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU2_7_LayerPropertiesData_t : public VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>> {
	using VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>::LayerProperties_All_Devices;

	enum VPUNN::ExecutionMode getValidDefaultExecutionMode(const class VPUNN::VPUTensor & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>> *>(this), "getValidDefaultExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::ExecutionMode>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::ExecutionMode> caster;
				return pybind11::detail::cast_ref<enum VPUNN::ExecutionMode>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::ExecutionMode>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidDefaultExecutionMode(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >;
	_binder_ret_0 getValidTilingExecutionMode(const struct VPUNN::DPULayer & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>> *>(this), "getValidTilingExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingExecutionMode(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >;
	_binder_ret_1 getValidTilingStrategies() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>> *>(this), "getValidTilingStrategies");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingStrategies();
	}
};

void bind_VPUNN_68(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::DMATheoreticalCostModel file: line:64
		pybind11::class_<VPUNN::DMATheoreticalCostModel, std::shared_ptr<VPUNN::DMATheoreticalCostModel>> cl(M("VPUNN"), "DMATheoreticalCostModel", "Has to be factored to own file or to be redesigned, why we need this, what's the purpose\n WE want from the VPUX to use same interface or same descriptor as we use in DMANN part\n ALso the theoretical DMA should have a common interface(datatype dma workload) with the DMANN");
		cl.def( pybind11::init( [](){ return new VPUNN::DMATheoreticalCostModel(); } ) );
		cl.def( pybind11::init( [](VPUNN::DMATheoreticalCostModel const &o){ return new VPUNN::DMATheoreticalCostModel(o); } ) );
	}
	{ // VPUNN::VPULayerStrategy file: line:22
		pybind11::class_<VPUNN::VPULayerStrategy, std::shared_ptr<VPUNN::VPULayerStrategy>> cl(M("VPUNN"), "VPULayerStrategy", "A VPU layer strategy");
		cl.def( pybind11::init( [](){ return new VPUNN::VPULayerStrategy(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPULayerStrategy const &o){ return new VPUNN::VPULayerStrategy(o); } ) );
		cl.def_readwrite("nDPUs", &VPUNN::VPULayerStrategy::nDPUs);
		cl.def_readwrite("nSHVs", &VPUNN::VPULayerStrategy::nSHVs);
		cl.def_readwrite("nTiles", &VPUNN::VPULayerStrategy::nTiles);
		cl.def_readwrite("tiling_strategy", &VPUNN::VPULayerStrategy::tiling_strategy);
		cl.def_readwrite("input_fetching", &VPUNN::VPULayerStrategy::input_fetching);
		cl.def_readwrite("output_spilling", &VPUNN::VPULayerStrategy::output_spilling);
		cl.def_readwrite("prefetching", &VPUNN::VPULayerStrategy::prefetching);
		cl.def("assign", (struct VPUNN::VPULayerStrategy & (VPUNN::VPULayerStrategy::*)(const struct VPUNN::VPULayerStrategy &)) &VPUNN::VPULayerStrategy::operator=, "C++: VPUNN::VPULayerStrategy::operator=(const struct VPUNN::VPULayerStrategy &) --> struct VPUNN::VPULayerStrategy &", pybind11::return_value_policy::reference, pybind11::arg(""));

		cl.def("__str__", [](VPUNN::VPULayerStrategy const &o) -> std::string { std::ostringstream s; VPUNN::operator<<(s, o); return s.str(); } );
	}
	{ // VPUNN::TilingExecutionMode file: line:28
		pybind11::class_<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>>> cl(M("VPUNN"), "TilingExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
	}
	{ // VPUNN::TilingExecutionMode file: line:28
		pybind11::class_<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>>> cl(M("VPUNN"), "TilingExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
	}
	{ // VPUNN::TilingExecutionMode file: line:28
		pybind11::class_<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>>> cl(M("VPUNN"), "TilingExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
	}
	{ // VPUNN::TilingExecutionMode file: line:28
		pybind11::class_<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>>> cl(M("VPUNN"), "TilingExecutionMode_VPUNN_Default_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
	}
	{ // VPUNN::DefaultExecutionMode file: line:66
		pybind11::class_<VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, std::shared_ptr<VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>>> cl(M("VPUNN"), "DefaultExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
	}
	{ // VPUNN::DefaultExecutionMode file: line:66
		pybind11::class_<VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, std::shared_ptr<VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>>> cl(M("VPUNN"), "DefaultExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
	}
	{ // VPUNN::DefaultExecutionMode file: line:66
		pybind11::class_<VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, std::shared_ptr<VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>>> cl(M("VPUNN"), "DefaultExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
	}
	{ // VPUNN::DefaultExecutionMode file: line:66
		pybind11::class_<VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, std::shared_ptr<VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>>> cl(M("VPUNN"), "DefaultExecutionMode_VPUNN_Default_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
	}
	{ // VPUNN::TilingStrategies file: line:95
		pybind11::class_<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>> cl(M("VPUNN"), "TilingStrategies_VPUNN_VPU2_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::TilingStrategies file: line:95
		pybind11::class_<VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>> cl(M("VPUNN"), "TilingStrategies_VPUNN_VPU2_7_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::TilingStrategies file: line:95
		pybind11::class_<VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>> cl(M("VPUNN"), "TilingStrategies_VPUNN_VPU4_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::TilingStrategies file: line:95
		pybind11::class_<VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>> cl(M("VPUNN"), "TilingStrategies_VPUNN_VPU5_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::TilingStrategies file: line:95
		pybind11::class_<VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>, std::shared_ptr<VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>> cl(M("VPUNN"), "TilingStrategies_VPUNN_Default_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>(); } ) );
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::LayerProperties_All_Devices file: line:125
		pybind11::class_<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>, std::shared_ptr<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>>, PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU2_7_LayerPropertiesData_t, VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>> cl(M("VPUNN"), "LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU2_7_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>(); }, [](){ return new PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU2_7_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU2_7_LayerPropertiesData_t(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData> >::getValidDefaultExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData> >::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg("tensor"));
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData> >::getValidTilingExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData> >::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>>::*)() const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData> >::getValidTilingStrategies, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData> >::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::VPU2_7_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU2_7_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
}


// File: VPUNN_69.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::LayerProperties_All_Devices file: line:125
struct PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU4_0_LayerPropertiesData_t : public VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>> {
	using VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>::LayerProperties_All_Devices;

	enum VPUNN::ExecutionMode getValidDefaultExecutionMode(const class VPUNN::VPUTensor & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>> *>(this), "getValidDefaultExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::ExecutionMode>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::ExecutionMode> caster;
				return pybind11::detail::cast_ref<enum VPUNN::ExecutionMode>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::ExecutionMode>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidDefaultExecutionMode(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >;
	_binder_ret_0 getValidTilingExecutionMode(const struct VPUNN::DPULayer & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>> *>(this), "getValidTilingExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingExecutionMode(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >;
	_binder_ret_1 getValidTilingStrategies() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>> *>(this), "getValidTilingStrategies");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingStrategies();
	}
};

// VPUNN::LayerProperties_All_Devices file: line:125
struct PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU5_0_LayerPropertiesData_t : public VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>> {
	using VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>::LayerProperties_All_Devices;

	enum VPUNN::ExecutionMode getValidDefaultExecutionMode(const class VPUNN::VPUTensor & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>> *>(this), "getValidDefaultExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::ExecutionMode>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::ExecutionMode> caster;
				return pybind11::detail::cast_ref<enum VPUNN::ExecutionMode>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::ExecutionMode>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidDefaultExecutionMode(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >;
	_binder_ret_0 getValidTilingExecutionMode(const struct VPUNN::DPULayer & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>> *>(this), "getValidTilingExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingExecutionMode(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >;
	_binder_ret_1 getValidTilingStrategies() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>> *>(this), "getValidTilingStrategies");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingStrategies();
	}
};

// VPUNN::LayerProperties_All_Devices file: line:125
struct PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_Default_LayerPropertiesData_t : public VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>> {
	using VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>::LayerProperties_All_Devices;

	enum VPUNN::ExecutionMode getValidDefaultExecutionMode(const class VPUNN::VPUTensor & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>> *>(this), "getValidDefaultExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::ExecutionMode>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::ExecutionMode> caster;
				return pybind11::detail::cast_ref<enum VPUNN::ExecutionMode>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::ExecutionMode>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidDefaultExecutionMode(a0);
	}
	using _binder_ret_0 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >;
	_binder_ret_0 getValidTilingExecutionMode(const struct VPUNN::DPULayer & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>> *>(this), "getValidTilingExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingExecutionMode(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >;
	_binder_ret_1 getValidTilingStrategies() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>> *>(this), "getValidTilingStrategies");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return LayerProperties_All_Devices::getValidTilingStrategies();
	}
};

void bind_VPUNN_69(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::LayerProperties_All_Devices file: line:125
		pybind11::class_<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>, std::shared_ptr<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>>, PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU4_0_LayerPropertiesData_t, VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>> cl(M("VPUNN"), "LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU4_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>(); }, [](){ return new PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU4_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU4_0_LayerPropertiesData_t(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData> >::getValidDefaultExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData> >::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg("tensor"));
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData> >::getValidTilingExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData> >::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>>::*)() const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData> >::getValidTilingStrategies, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData> >::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::VPU4_0_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU4_0_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::LayerProperties_All_Devices file: line:125
		pybind11::class_<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>, std::shared_ptr<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>>, PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU5_0_LayerPropertiesData_t, VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>> cl(M("VPUNN"), "LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU5_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>(); }, [](){ return new PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_VPU5_0_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_VPU5_0_LayerPropertiesData_t(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData> >::getValidDefaultExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData> >::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg("tensor"));
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData> >::getValidTilingExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData> >::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>>::*)() const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData> >::getValidTilingStrategies, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData> >::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::VPU5_0_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU5_0_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::LayerProperties_All_Devices file: line:125
		pybind11::class_<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>, std::shared_ptr<VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>>, PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_Default_LayerPropertiesData_t, VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>> cl(M("VPUNN"), "LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_Default_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>(); }, [](){ return new PyCallBack_VPUNN_LayerProperties_All_Devices_VPUNN_TilingExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_DefaultExecutionMode_VPUNN_Default_LayerPropertiesData_VPUNN_TilingStrategies_VPUNN_Default_LayerPropertiesData_t(); } ) );
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData> >::getValidDefaultExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData> >::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg("tensor"));
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData> >::getValidTilingExecutionMode, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData> >::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>,VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>>::*)() const) &VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData> >::getValidTilingStrategies, "C++: VPUNN::LayerProperties_All_Devices<VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>, VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData> >::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidTilingExecutionMode, "C++: VPUNN::TilingExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidDefaultExecutionMode, "C++: VPUNN::DefaultExecutionMode<VPUNN::Default_LayerPropertiesData>::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg(""));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::Default_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
}


// File: VPUNN_70.cpp
#include <array> // std::array
#include <bits/refwrap.h> // std::reference_wrapper
#include <fstream> // std::basic_fstream
#include <functional> // std::equal_to
#include <functional> // std::less
#include <iterator> // __gnu_cxx::__normal_iterator
#include <map> // std::map
#include <memory> // std::allocator
#include <memory> // std::shared_ptr
#include <optional> // std::nullopt_t
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string> // std::hash
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <unordered_map> // std::unordered_map
#include <unordered_set> // std::unordered_set
#include <utility> // std::pair
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::LayerProperties_Device20 file: line:155
struct PyCallBack_VPUNN_LayerProperties_Device20_VPUNN_TilingStrategies_VPUNN_VPU2_0_LayerPropertiesData_t : public VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>> {
	using VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>::LayerProperties_Device20;

	using _binder_ret_0 = const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >;
	_binder_ret_0 getValidTilingExecutionMode(const struct VPUNN::DPULayer & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>> *>(this), "getValidTilingExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
		}
		return LayerProperties_Device20::getValidTilingExecutionMode(a0);
	}
	enum VPUNN::ExecutionMode getValidDefaultExecutionMode(const class VPUNN::VPUTensor & a0) const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>> *>(this), "getValidDefaultExecutionMode");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
			if (pybind11::detail::cast_is_temporary_value_reference<enum VPUNN::ExecutionMode>::value) {
				static pybind11::detail::override_caster_t<enum VPUNN::ExecutionMode> caster;
				return pybind11::detail::cast_ref<enum VPUNN::ExecutionMode>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<enum VPUNN::ExecutionMode>(std::move(o));
		}
		return LayerProperties_Device20::getValidDefaultExecutionMode(a0);
	}
	using _binder_ret_1 = const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >;
	_binder_ret_1 getValidTilingStrategies() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>> *>(this), "getValidTilingStrategies");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_1>::value) {
				static pybind11::detail::override_caster_t<_binder_ret_1> caster;
				return pybind11::detail::cast_ref<_binder_ret_1>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<_binder_ret_1>(std::move(o));
		}
		return LayerProperties_Device20::getValidTilingStrategies();
	}
};

void bind_VPUNN_70(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::LayerProperties_Device20 file: line:155
		pybind11::class_<VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>, std::shared_ptr<VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>>, PyCallBack_VPUNN_LayerProperties_Device20_VPUNN_TilingStrategies_VPUNN_VPU2_0_LayerPropertiesData_t, VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>> cl(M("VPUNN"), "LayerProperties_Device20_VPUNN_TilingStrategies_VPUNN_VPU2_0_LayerPropertiesData_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>(); }, [](){ return new PyCallBack_VPUNN_LayerProperties_Device20_VPUNN_TilingStrategies_VPUNN_VPU2_0_LayerPropertiesData_t(); } ) );
		cl.def("getValidTilingExecutionMode", (const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> > (VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>::*)(const struct VPUNN::DPULayer &) const) &VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData> >::getValidTilingExecutionMode, "C++: VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData> >::getValidTilingExecutionMode(const struct VPUNN::DPULayer &) const --> const class std::vector<enum VPUNN::ExecutionMode, class std::allocator<enum VPUNN::ExecutionMode> >", pybind11::arg("wl"));
		cl.def("getValidDefaultExecutionMode", (enum VPUNN::ExecutionMode (VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>::*)(const class VPUNN::VPUTensor &) const) &VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData> >::getValidDefaultExecutionMode, "C++: VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData> >::getValidDefaultExecutionMode(const class VPUNN::VPUTensor &) const --> enum VPUNN::ExecutionMode", pybind11::arg("tensor"));
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>>::*)() const) &VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData> >::getValidTilingStrategies, "C++: VPUNN::LayerProperties_Device20<VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData> >::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
		cl.def("getValidTilingStrategies", (const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>::*)() const) &VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>::getValidTilingStrategies, "C++: VPUNN::TilingStrategies<VPUNN::VPU2_0_LayerPropertiesData>::getValidTilingStrategies() const --> const class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >");
	}
	{ // VPUNN::VPU2_0_LayerPropertiesData file: line:30
		pybind11::class_<VPUNN::VPU2_0_LayerPropertiesData, std::shared_ptr<VPUNN::VPU2_0_LayerPropertiesData>> cl(M("VPUNN"), "VPU2_0_LayerPropertiesData", "data holder for VPU 2.0/2.1 layer properties\n\n This class encapsulates device-specific static configuration data for VPU 2.0 and VPU 2.1.\n Its main purpose is to provide a central definition of valid tiling strategies for these devices.\n\n \n\n - This class is not intended for direct use by client code.\n - It is used as a template parameter for higher-level property classes (such as LayerProperties_Device20)\n   that implement the actual device-specific logic and interface for layer property queries.\n - The scope of this class is internal to the layer properties implementation for VPU 2.0/2.1.");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU2_0_LayerPropertiesData(); } ) );
	}
	{ // VPUNN::VPU2_7_LayerPropertiesData file: line:31
		pybind11::class_<VPUNN::VPU2_7_LayerPropertiesData, std::shared_ptr<VPUNN::VPU2_7_LayerPropertiesData>> cl(M("VPUNN"), "VPU2_7_LayerPropertiesData", "data holder for VPU 2.7 layer properties.\n\n This class encapsulates device-specific static configuration data for VPU 2.7.\n Its main purpose is to provide a central definition of valid tiling strategies,\n operation-to-execution-mode mappings, and the default execution mode for this device.\n\n \n\n - This class is not intended for direct use by client code.\n - It is used as a template parameter for higher-level property classes (such as LayerProperties_All_Devices)\n   that implement the actual device-specific logic and interface for layer property queries.\n - The scope of this class is internal to the layer properties implementation for VPU 2.7.");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU2_7_LayerPropertiesData(); } ) );
	}
	{ // VPUNN::VPU4_0_LayerPropertiesData file: line:31
		pybind11::class_<VPUNN::VPU4_0_LayerPropertiesData, std::shared_ptr<VPUNN::VPU4_0_LayerPropertiesData>> cl(M("VPUNN"), "VPU4_0_LayerPropertiesData", "data holder for VPU 4.0 layer properties.\n\n This struct encapsulates device-specific static configuration data for VPU 4.0.\n Its main purpose is to provide a central definition of valid tiling strategies,\n operation-to-execution-mode mappings, and the default execution mode for this device.\n\n \n\n - This struct is not intended for direct use by client code.\n - It is used as a template parameter for higher-level property classes (such as LayerProperties_All_Devices)\n   that implement the actual device-specific logic and interface for layer property queries.\n - The scope of this struct is internal to the layer properties implementation for VPU 4.0.");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU4_0_LayerPropertiesData(); } ) );
	}
	{ // VPUNN::VPU5_0_LayerPropertiesData file: line:31
		pybind11::class_<VPUNN::VPU5_0_LayerPropertiesData, std::shared_ptr<VPUNN::VPU5_0_LayerPropertiesData>> cl(M("VPUNN"), "VPU5_0_LayerPropertiesData", "data holder for VPU 5.0 and VPU 5.0_W layer properties.\n\n This struct encapsulates device-specific static configuration data for VPU 5.0 and VPU 5.0_W.\n Its main purpose is to provide a central definition of valid tiling strategies,\n operation-to-execution-mode mappings, and the default execution mode for these devices.\n\n \n\n - This struct is not intended for direct use by client code.\n - It is used as a template parameter for higher-level property classes (such as LayerProperties_All_Devices)\n   that implement the actual device-specific logic and interface for layer property queries.\n - The scope of this struct is internal to the layer properties implementation for VPU 5.0/5.0_W.");
		cl.def( pybind11::init( [](){ return new VPUNN::VPU5_0_LayerPropertiesData(); } ) );
	}
	{ // VPUNN::Default_LayerPropertiesData file: line:30
		pybind11::class_<VPUNN::Default_LayerPropertiesData, std::shared_ptr<VPUNN::Default_LayerPropertiesData>> cl(M("VPUNN"), "Default_LayerPropertiesData", "Internal static data holder for default (fallback) layer properties.\n\n This struct encapsulates static configuration data used as a fallback when no device-specific\n layer properties are available. It provides a central definition of valid tiling strategies,\n an (empty) operation-to-execution-mode mapping, and the default execution mode for unsupported or unknown devices.\n\n \n\n - This struct is not intended for direct use by client code.\n - It is used as a template parameter for higher-level property classes (such as LayerProperties_All_Devices)\n   that implement the actual logic and interface for layer property queries.\n - The scope of this struct is internal to the layer properties implementation for default/fallback cases.");
		cl.def( pybind11::init( [](){ return new VPUNN::Default_LayerPropertiesData(); } ) );
	}
	{ // VPUNN::LayerPropertiesHolder file: line:33
		pybind11::class_<VPUNN::LayerPropertiesHolder, std::shared_ptr<VPUNN::LayerPropertiesHolder>> cl(M("VPUNN"), "LayerPropertiesHolder", "Provides access to device-specific layer properties for supported VPU devices.\n\n This class offers an interface to retrieve layer property information\n (such as valid tiling strategies, execution modes, and other device-dependent characteristics)\n for a given VPU device. It internally manages a tuple of device-specific property implementations\n and returns the correct properties based on the device type.\n\n If the requested device is not supported, a default property implementation is returned and an error is logged.");
		cl.def( pybind11::init( [](){ return new VPUNN::LayerPropertiesHolder(); } ) );
	}
	{ // VPUNN::L2CostSerializationWrap file: line:20
		pybind11::class_<VPUNN::L2CostSerializationWrap, std::shared_ptr<VPUNN::L2CostSerializationWrap>, VPUNN::CostSerializationWrap> cl(M("VPUNN"), "L2CostSerializationWrap", ": make it a single class with more specialised functions (that will be reused as much as possible)\n        no sense to make a template class that will be inherited by each implementaiton");
		cl.def("serializeCyclesAndTilesCnt_closeLine", (void (VPUNN::L2CostSerializationWrap::*)(unsigned int, const unsigned long)) &VPUNN::L2CostSerializationWrap::serializeCyclesAndTilesCnt_closeLine, "vpunn_cycles, n_computed_tiles\n\nC++: VPUNN::L2CostSerializationWrap::serializeCyclesAndTilesCnt_closeLine(unsigned int, const unsigned long) --> void", pybind11::arg("cost"), pybind11::arg("computed_tiles"));
		cl.def("serializeCyclesAndLayerTilesInfo_closeLine", (void (VPUNN::L2CostSerializationWrap::*)(unsigned int, const unsigned long)) &VPUNN::L2CostSerializationWrap::serializeCyclesAndLayerTilesInfo_closeLine, "vpunn_cycles\n n_computed_tiles,level=layer, layer_uid\n\nC++: VPUNN::L2CostSerializationWrap::serializeCyclesAndLayerTilesInfo_closeLine(unsigned int, const unsigned long) --> void", pybind11::arg("cost"), pybind11::arg("computed_tiles"));
		cl.def("serializeLayerInformation_header_and_compute_layer_uid", (void (VPUNN::L2CostSerializationWrap::*)(const struct VPUNN::DPULayer &)) &VPUNN::L2CostSerializationWrap::serializeLayerInformation_header_and_compute_layer_uid, "generic layer info, no cost available\n n_requested_tiles, n_dpu, tiling_strategy, level=layer, layer_uid, info, name\n\nC++: VPUNN::L2CostSerializationWrap::serializeLayerInformation_header_and_compute_layer_uid(const struct VPUNN::DPULayer &) --> void", pybind11::arg("layer"));
		cl.def("serializeLayerSplitInfo", (void (VPUNN::L2CostSerializationWrap::*)(const unsigned long, const class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &)) &VPUNN::L2CostSerializationWrap::serializeLayerSplitInfo, "C++: VPUNN::L2CostSerializationWrap::serializeLayerSplitInfo(const unsigned long, const class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &) --> void", pybind11::arg("computed_tiles"), pybind11::arg("detailed_split"));

		{ // VPUNN::L2CostSerializationWrap::LayerSerializationContext file: line:22
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::L2CostSerializationWrap::LayerSerializationContext, std::shared_ptr<VPUNN::L2CostSerializationWrap::LayerSerializationContext>> cl(enclosing_class, "LayerSerializationContext", "");
			cl.def( pybind11::init( [](){ return new VPUNN::L2CostSerializationWrap::LayerSerializationContext(); } ) );
			cl.def( pybind11::init( [](VPUNN::L2CostSerializationWrap::LayerSerializationContext const &o){ return new VPUNN::L2CostSerializationWrap::LayerSerializationContext(o); } ) );
			cl.def_readwrite("nDPU", &VPUNN::L2CostSerializationWrap::LayerSerializationContext::nDPU);
			cl.def_readwrite("nTiles", &VPUNN::L2CostSerializationWrap::LayerSerializationContext::nTiles);
			cl.def_readwrite("strategy", &VPUNN::L2CostSerializationWrap::LayerSerializationContext::strategy);
			cl.def_readwrite("device", &VPUNN::L2CostSerializationWrap::LayerSerializationContext::device);
		}

	}
	{ // VPUNN::VPULayerCostModel file: line:46
		pybind11::class_<VPUNN::VPULayerCostModel, std::shared_ptr<VPUNN::VPULayerCostModel>> cl(M("VPUNN"), "VPULayerCostModel", "The VPUNN layer cost model (also called VPUNN Level2 API)");
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0){ return new VPUNN::VPULayerCostModel(a0); } ), "doc" , pybind11::arg("dma_cost_model"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1){ return new VPUNN::VPULayerCostModel(a0, a1); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2){ return new VPUNN::VPULayerCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4, const std::string & a5){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4, const std::string & a5, const std::string & a6){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4, const std::string & a5, const std::string & a6, bool const & a7){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"));
		cl.def( pybind11::init<const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *>, const std::string &, bool, const unsigned int, const unsigned int, const std::string &, const std::string &, bool, bool>(), pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"), pybind11::arg("tryToLoadPairedCache") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7, unsigned long const & a8){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7, unsigned long const & a8, const char * a9){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7, unsigned long const & a8, const char * a9, unsigned long const & a10){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"));
		cl.def( pybind11::init<const char *, unsigned long, bool, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *>, bool, const unsigned int, const unsigned int, const char *, unsigned long, const char *, unsigned long, bool>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"), pybind11::arg("use_shave_2_api") );

		cl.def( pybind11::init( [](){ return new VPUNN::VPULayerCostModel(); } ), "doc" );
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::VPULayerCostModel(a0); } ), "doc" , pybind11::arg("filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1){ return new VPUNN::VPULayerCostModel(a0, a1); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2){ return new VPUNN::VPULayerCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4, const std::string & a5){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4, const std::string & a5, bool const & a6){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"));
		cl.def( pybind11::init<const std::string &, bool, const unsigned int, const unsigned int, const std::string &, const std::string &, bool, bool>(), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"), pybind11::arg("tryToLoadPairedCache") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2){ return new VPUNN::VPULayerCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7, const char * a8){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7, const char * a8, unsigned long const & a9){ return new VPUNN::VPULayerCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"));
		cl.def( pybind11::init<const char *, unsigned long, bool, bool, const unsigned int, const unsigned int, const char *, unsigned long, const char *, unsigned long, bool>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"), pybind11::arg("use_shave_2_api") );

		cl.def( pybind11::init<class std::shared_ptr<class VPUNN::VPUCostModel>, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *>>(), pybind11::arg("dpu_cost_provider"), pybind11::arg("dma_cost_model") );

		cl.def( pybind11::init<class std::shared_ptr<class VPUNN::VPUCostModel>>(), pybind11::arg("dpu_cost_provider") );

		cl.def("get_cost_model", (class VPUNN::VPUCostModel & (VPUNN::VPULayerCostModel::*)()) &VPUNN::VPULayerCostModel::get_cost_model, "Get the CM, either base or a contained object or maybe a parametric attribute\n\nC++: VPUNN::VPULayerCostModel::get_cost_model() --> class VPUNN::VPUCostModel &", pybind11::return_value_policy::reference);
		cl.def("get_SHV_cost_model", (const class VPUNN::VPUCostModel & (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::get_SHV_cost_model, "C++: VPUNN::VPULayerCostModel::get_SHV_cost_model() const --> const class VPUNN::VPUCostModel &", pybind11::return_value_policy::reference);
		cl.def("get_TheoreticalDMA_cost_model", (const class VPUNN::VPUCostModel & (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::get_TheoreticalDMA_cost_model, "C++: VPUNN::VPULayerCostModel::get_TheoreticalDMA_cost_model() const --> const class VPUNN::VPUCostModel &", pybind11::return_value_policy::reference);
		cl.def("get_HWPerformance", (const class VPUNN::HWPerformanceModel & (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::get_HWPerformance, "C++: VPUNN::VPULayerCostModel::get_HWPerformance() const --> const class VPUNN::HWPerformanceModel &", pybind11::return_value_policy::reference);
		cl.def("get_cost_model_shared", (class std::shared_ptr<class VPUNN::VPUCostModel> (VPUNN::VPULayerCostModel::*)()) &VPUNN::VPULayerCostModel::get_cost_model_shared, "C++: VPUNN::VPULayerCostModel::get_cost_model_shared() --> class std::shared_ptr<class VPUNN::VPUCostModel>");
		cl.def("get_SHV_cost_model_shared", (const class std::shared_ptr<class VPUNN::VPUCostModel> (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::get_SHV_cost_model_shared, "C++: VPUNN::VPULayerCostModel::get_SHV_cost_model_shared() const --> const class std::shared_ptr<class VPUNN::VPUCostModel>");
		cl.def("get_TheoreticalDMA_cost_model_shared", (const class std::shared_ptr<class VPUNN::VPUCostModel> (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::get_TheoreticalDMA_cost_model_shared, "C++: VPUNN::VPULayerCostModel::get_TheoreticalDMA_cost_model_shared() const --> const class std::shared_ptr<class VPUNN::VPUCostModel>");
		cl.def("getDPUPreloadedCacheCounter", (const class VPUNN::AccessCounter & (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::getDPUPreloadedCacheCounter, "Shortcut to DPU counter.\n in the future handle also non existing case, or add aggregate counters\n Do not hold this reference, it may become obsolete if the Layer/DPU is reconfigured\n\nC++: VPUNN::VPULayerCostModel::getDPUPreloadedCacheCounter() const --> const class VPUNN::AccessCounter &", pybind11::return_value_policy::reference);
		cl.def("set_maxWorkloadsPerIntraTileSplit", (void (VPUNN::VPULayerCostModel::*)(unsigned int)) &VPUNN::VPULayerCostModel::set_maxWorkloadsPerIntraTileSplit, "limits the split of a tile (intra-tile split) to this number of individual workloads\n\nC++: VPUNN::VPULayerCostModel::set_maxWorkloadsPerIntraTileSplit(unsigned int) --> void", pybind11::arg("new_value"));
		cl.def("get_maxWorkloadsPerIntraTileSplit", (unsigned int (VPUNN::VPULayerCostModel::*)() const) &VPUNN::VPULayerCostModel::get_maxWorkloadsPerIntraTileSplit, "C++: VPUNN::VPULayerCostModel::get_maxWorkloadsPerIntraTileSplit() const --> unsigned int");
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy)) &VPUNN::VPULayerCostModel::Layer, "Compute the optimal cost of a DPULayer given a strategy and context\n\n \n the DPULayer\n \n\n the layer strategy, shaves do not matter\n \n\n  measured best cycles or error code . \n Cycles for error codes\n\nC++: VPUNN::VPULayerCostModel::Layer(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy) --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"));
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &)) &VPUNN::VPULayerCostModel::Layer, "C++: VPUNN::VPULayerCostModel::Layer(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &) --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("detailed_split"));
		cl.def("Layer_dCiM", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy)) &VPUNN::VPULayerCostModel::Layer_dCiM, "C++: VPUNN::VPULayerCostModel::Layer_dCiM(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy) --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"));
		cl.def("Layer_dCiM", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &)) &VPUNN::VPULayerCostModel::Layer_dCiM, "C++: VPUNN::VPULayerCostModel::Layer_dCiM(struct VPUNN::DPULayer &, struct VPUNN::VPULayerStrategy, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &) --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("detailed_split"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, enum VPUNN::VPUTilingStrategy const & a1) -> unsigned int { return o.Layer(a0, a1); }, "", pybind11::arg("layer"), pybind11::arg("strategy"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, enum VPUNN::VPUTilingStrategy const & a1, unsigned int const & a2) -> unsigned int { return o.Layer(a0, a1, a2); }, "", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("nDPU"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, enum VPUNN::VPUTilingStrategy const & a1, unsigned int const & a2, unsigned int const & a3) -> unsigned int { return o.Layer(a0, a1, a2, a3); }, "", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("nDPU"), pybind11::arg("nTiles"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, enum VPUNN::VPUTilingStrategy const & a1, unsigned int const & a2, unsigned int const & a3, bool const & a4) -> unsigned int { return o.Layer(a0, a1, a2, a3, a4); }, "", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, enum VPUNN::VPUTilingStrategy const & a1, unsigned int const & a2, unsigned int const & a3, bool const & a4, bool const & a5) -> unsigned int { return o.Layer(a0, a1, a2, a3, a4, a5); }, "", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"));
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, enum VPUNN::VPUTilingStrategy, unsigned int, unsigned int, bool, bool, bool)) &VPUNN::VPULayerCostModel::Layer, "Compute the optimal cost of a DPULayer using a specific strategy and context\n\n It splits on tiles(between tiles, using the strategy), then, for each tile , makes the intra-tile split on\n workloads and choses the best one\n\n \n the DPULayer\n \n\n the inter-tile tiling strategy to use\n \n\n the number of DPU (for each tile)\n \n\n the number of CMX tiles\n \n\n enable/disable input in DDR (require extra DMA to fetch data in CMX)\n \n\n enable/disable output in DDR (require extra DMA to spill data in CMX)\n \n\n If true it considers the weights are prefetched, if false\n will fetch the weights considering also sparsity\n takes in consideration the sparsity(enabled and value)\n \n\n measured best cycles or error code . \n Cycles for error codes\n\nC++: VPUNN::VPULayerCostModel::Layer(struct VPUNN::DPULayer &, enum VPUNN::VPUTilingStrategy, unsigned int, unsigned int, bool, bool, bool) --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"));
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, enum VPUNN::VPUTilingStrategy, unsigned int, unsigned int, bool, bool, bool, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &)) &VPUNN::VPULayerCostModel::Layer, "Compute the optimal cost of a DPULayer using a specific strategy and execution mode\n\n It splits on tiles(between tiles, using the strategy), then, for each tile , makes the intra-tile split on\n workloads and choses the best one\n\n \n the DPULayer\n \n\n the inter-tile tiling strategy to use\n \n\n the number of DPU (for each tile)\n \n\n the number of CMX tiles\n \n\n enable/disable input in DDR (require extra DMA to fetch data in CMX). Data fetch time is\n computed considering the full layer input tensor not he split ones\n \n\n enable/disable output in DDR (require extra DMA to spill data in CMX). Data fetch time is\n computed considering the full layer output tensor not he split ones\n \n\n  If true it considers the weights are prefetched, if false\n will fetch the weights considering also sparsity. Data fetch time is computed considering the split layers\n weights tensors, that are pipelined on all available DMA channels.\n \n\n [out] gives as output the information on how was split this layer and what is the best\n split on workloads\n \n\n measured best cycles or error code . \n Cycles for error codes\n\nC++: VPUNN::VPULayerCostModel::Layer(struct VPUNN::DPULayer &, enum VPUNN::VPUTilingStrategy, unsigned int, unsigned int, bool, bool, bool, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &) --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"), pybind11::arg("detailed_split"));
		cl.def("LayersPreSplit", [](VPUNN::VPULayerCostModel &o, const class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > & a0, unsigned int const & a1, bool const & a2, bool const & a3, bool const & a4, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > & a5) -> unsigned int { return o.LayersPreSplit(a0, a1, a2, a3, a4, a5); }, "", pybind11::arg("layers_pre_split"), pybind11::arg("nDPU"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"), pybind11::arg("detailed_split"));
		cl.def("LayersPreSplit", [](VPUNN::VPULayerCostModel &o, const class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > & a0, unsigned int const & a1, bool const & a2, bool const & a3, bool const & a4, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > & a5, const unsigned long & a6) -> unsigned int { return o.LayersPreSplit(a0, a1, a2, a3, a4, a5, a6); }, "", pybind11::arg("layers_pre_split"), pybind11::arg("nDPU"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"), pybind11::arg("detailed_split"), pybind11::arg("fullLayerHash"));
		cl.def("LayersPreSplit", (unsigned int (VPUNN::VPULayerCostModel::*)(const class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > &, unsigned int, bool, bool, bool, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &, const unsigned long, const class std::optional<enum VPUNN::VPUTilingStrategy>)) &VPUNN::VPULayerCostModel::LayersPreSplit, "Compute the optimal cost of a pre split layer. Layer is already split on tiles, only the intratile split\n si performed.\n\n For each tile , makes the intra-tile split on workloads and choses the best one\n\n \n the list of layers split on tiles, their number indicates the tiles. Full info has to be\n specified, as it is for a DPUWorkload\n \n\n the number of DPU (for each tile)\n\n \n enable/disable input in DDR (require extra DMA to fetch data in CMX). Data fetch time is\n computed considering the split layers input tensors, that are summed up.\n \n\n enable/disable output in DDR (require extra DMA to spill data in CMX). Data fetch time is\n computed considering the split layers output tensors, that are summed up.\n \n\n  If true it considers the weights are prefetched, if false\n will fetch the weights considering also sparsity. Data fetch time is computed considering the split layers\n weights tensors, that are pipelined on all available DMA channels.\n\n \n [out] gives as output the information on how was split this layer and what is the best\n split on workloads\n \n\n [in] is a hash computed by caller, should reflect the initial Layer. Will be used to group\n the splits in the statistics\n \n\n [in] is a strategy that was used to split the layer. Should be passed where the strategy\n is selected/decided(MC pass). If not available the vpunn might decide not to do any data serialization fro\n statistics at L2\n\n \n measured best cycles for the overall vector of layers or error code . \n Cycles for error codes\n\nC++: VPUNN::VPULayerCostModel::LayersPreSplit(const class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > &, unsigned int, bool, bool, bool, class std::vector<struct VPUNN::OneTileLayerInfo, class std::allocator<struct VPUNN::OneTileLayerInfo> > &, const unsigned long, const class std::optional<enum VPUNN::VPUTilingStrategy>) --> unsigned int", pybind11::arg("layers_pre_split"), pybind11::arg("nDPU"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"), pybind11::arg("detailed_split"), pybind11::arg("fullLayerHash"), pybind11::arg("strategyOfSplit"));
		cl.def("LayersPreSplit", (unsigned int (VPUNN::VPULayerCostModel::*)(const class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > &, unsigned int, bool, bool, bool)) &VPUNN::VPULayerCostModel::LayersPreSplit, "version without detailed split output parameter and no hash or tiling strategy.\n\nC++: VPUNN::VPULayerCostModel::LayersPreSplit(const class std::vector<struct VPUNN::DPULayer, class std::allocator<struct VPUNN::DPULayer> > &, unsigned int, bool, bool, bool) --> unsigned int", pybind11::arg("layers_pre_split"), pybind11::arg("nDPU"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"));
		cl.def("LayersPreSplit", (unsigned int (VPUNN::VPULayerCostModel::*)(const class std::vector<class VPUNN::SHAVEWorkload, class std::allocator<class VPUNN::SHAVEWorkload> > &, unsigned int, bool, bool)) &VPUNN::VPULayerCostModel::LayersPreSplit, "version without detailed split output parameter and no hash or tiling strategy.\n\nC++: VPUNN::VPULayerCostModel::LayersPreSplit(const class std::vector<class VPUNN::SHAVEWorkload, class std::allocator<class VPUNN::SHAVEWorkload> > &, unsigned int, bool, bool) --> unsigned int", pybind11::arg("layers_pre_split"), pybind11::arg("nSHV"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0) -> unsigned int { return o.Layer(a0); }, "", pybind11::arg("layer"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, unsigned int const & a1) -> unsigned int { return o.Layer(a0, a1); }, "", pybind11::arg("layer"), pybind11::arg("nDPU"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, unsigned int const & a1, unsigned int const & a2) -> unsigned int { return o.Layer(a0, a1, a2); }, "", pybind11::arg("layer"), pybind11::arg("nDPU"), pybind11::arg("nTiles"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, unsigned int const & a1, unsigned int const & a2, bool const & a3) -> unsigned int { return o.Layer(a0, a1, a2, a3); }, "", pybind11::arg("layer"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel &o, struct VPUNN::DPULayer & a0, unsigned int const & a1, unsigned int const & a2, bool const & a3, bool const & a4) -> unsigned int { return o.Layer(a0, a1, a2, a3, a4); }, "", pybind11::arg("layer"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"));
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(struct VPUNN::DPULayer &, unsigned int, unsigned int, bool, bool, bool)) &VPUNN::VPULayerCostModel::Layer, "Compute the optimal cost of a DPULayer, given a context but no strategy\n\n Analyses all strategies and selects the time o the fastest one\n\n \n the DPULayer\n \n\n the number of DPU\n \n\n the number of CMX tiles\n \n\n enable/disable input in DDR (require extra DMA to fetch data in CMX)\n \n\n enable/disable output in DDR (require extra DMA to spill data in CMX)\n \n\n enable/disable weight prefetching\n \n\n measured best cycles or error code . \n Cycles for error codes\n\nC++: VPUNN::VPULayerCostModel::Layer(struct VPUNN::DPULayer &, unsigned int, unsigned int, bool, bool, bool) --> unsigned int", pybind11::arg("layer"), pybind11::arg("nDPU"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"), pybind11::arg("prefetching"));
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(const class VPUNN::SHAVEWorkload &, const struct VPUNN::VPULayerStrategy &) const) &VPUNN::VPULayerCostModel::Layer, "Compute the optimal cost of a SHAVEWorkload\n\n \n the SHV kernel\n \n\n the layer strategy\n \n\n CyclesInterfaceType\n\nC++: VPUNN::VPULayerCostModel::Layer(const class VPUNN::SHAVEWorkload &, const struct VPUNN::VPULayerStrategy &) const --> unsigned int", pybind11::arg("layer"), pybind11::arg("strategy"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel const &o, const class VPUNN::SHAVEWorkload & a0) -> unsigned int { return o.Layer(a0); }, "", pybind11::arg("layer"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel const &o, const class VPUNN::SHAVEWorkload & a0, const unsigned int & a1) -> unsigned int { return o.Layer(a0, a1); }, "", pybind11::arg("layer"), pybind11::arg("nSHV"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel const &o, const class VPUNN::SHAVEWorkload & a0, const unsigned int & a1, const unsigned int & a2) -> unsigned int { return o.Layer(a0, a1, a2); }, "", pybind11::arg("layer"), pybind11::arg("nSHV"), pybind11::arg("nTiles"));
		cl.def("Layer", [](VPUNN::VPULayerCostModel const &o, const class VPUNN::SHAVEWorkload & a0, const unsigned int & a1, const unsigned int & a2, const bool & a3) -> unsigned int { return o.Layer(a0, a1, a2, a3); }, "", pybind11::arg("layer"), pybind11::arg("nSHV"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"));
		cl.def("Layer", (unsigned int (VPUNN::VPULayerCostModel::*)(const class VPUNN::SHAVEWorkload &, const unsigned int, const unsigned int, const bool, const bool) const) &VPUNN::VPULayerCostModel::Layer, "Compute the optimal cost of a SHV kernel\n\n \n the SHV kernel\n \n\n the number of SHV/tile\n \n\n the number of CMX tiles\n \n\n enable/disable input in DDR (require extra DMA to fetch data in CMX)\n \n\n enable/disable output in DDR (require extra DMA to spill data in CMX)\n \n\n CyclesInterfaceType\n\nC++: VPUNN::VPULayerCostModel::Layer(const class VPUNN::SHAVEWorkload &, const unsigned int, const unsigned int, const bool, const bool) const --> unsigned int", pybind11::arg("layer"), pybind11::arg("nSHV"), pybind11::arg("nTiles"), pybind11::arg("input_in_ddr"), pybind11::arg("output_in_ddr"));
		cl.def_static("getValidTilingStrategies", (class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> > (*)(const enum VPUNN::VPUDevice &)) &VPUNN::VPULayerCostModel::getValidTilingStrategies, "Get the valid tiling strategy for a device\n\n \n the VPUDevice\n \n\n std::vector<VPUTilingStrategy>\n\nC++: VPUNN::VPULayerCostModel::getValidTilingStrategies(const enum VPUNN::VPUDevice &) --> class std::vector<enum VPUNN::VPUTilingStrategy, class std::allocator<enum VPUNN::VPUTilingStrategy> >", pybind11::arg("device"));
	}
}


// File: VPUNN_71.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <list> // std::list
#include <memory> // std::allocator
#include <memory> // std::shared_ptr
#include <optional> // std::optional
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <variant> // std::variant
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_71(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPUComputeNode file: line:26
		pybind11::class_<VPUNN::VPUComputeNode, std::shared_ptr<VPUNN::VPUComputeNode>> cl(M("VPUNN"), "VPUComputeNode", "Base class that represent\n\n ");
		cl.def( pybind11::init<const class std::shared_ptr<struct VPUNN::DPULayer> &>(), pybind11::arg("dpu_op") );

		cl.def( pybind11::init<const class std::shared_ptr<class VPUNN::SHAVEWorkload> &>(), pybind11::arg("shv_op") );

		cl.def( pybind11::init( [](VPUNN::VPUComputeNode const &o){ return new VPUNN::VPUComputeNode(o); } ) );

		pybind11::enum_<VPUNN::VPUComputeNode::OpType>(cl, "OpType", "Node operation type enum\n\n     ")
			.value("DPU_COMPUTE_NODE", VPUNN::VPUComputeNode::OpType::DPU_COMPUTE_NODE)
			.value("SHV_COMPUTE_NODE", VPUNN::VPUComputeNode::OpType::SHV_COMPUTE_NODE);

		cl.def_readwrite("type", &VPUNN::VPUComputeNode::type);
		cl.def("cycles", (unsigned int (VPUNN::VPUComputeNode::*)(class VPUNN::VPULayerCostModel &, struct VPUNN::VPULayerStrategy &) const) &VPUNN::VPUComputeNode::cycles, "Compute the cycles of the VPUComputeNode\n\n \n a reference to a VPULayerCostModel object\n \n\n the strategy to be used.\n \n\n unsigned int execution cycles\n\nC++: VPUNN::VPUComputeNode::cycles(class VPUNN::VPULayerCostModel &, struct VPUNN::VPULayerStrategy &) const --> unsigned int", pybind11::arg("cost_model"), pybind11::arg("strategy"));
		cl.def("__eq__", (bool (VPUNN::VPUComputeNode::*)(const class VPUNN::VPUComputeNode &) const) &VPUNN::VPUComputeNode::operator==, "Operator == : compare this with rhs\n\n \n\n \n\n true\n \n\n false\n\nC++: VPUNN::VPUComputeNode::operator==(const class VPUNN::VPUComputeNode &) const --> bool", pybind11::arg("rhs"));
		cl.def("hash", (unsigned long (VPUNN::VPUComputeNode::*)() const) &VPUNN::VPUComputeNode::hash, "Generate a has for the node\n\n \n size_t\n\nC++: VPUNN::VPUComputeNode::hash() const --> unsigned long");
	}
	{ // VPUNN::VPUComputeHash file: line:113
		pybind11::class_<VPUNN::VPUComputeHash, std::shared_ptr<VPUNN::VPUComputeHash>> cl(M("VPUNN"), "VPUComputeHash", "An helper class to generate has for VPUComputeNode objects\n\n ");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUComputeHash(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUComputeHash const &o){ return new VPUNN::VPUComputeHash(o); } ) );
		cl.def("__call__", (unsigned long (VPUNN::VPUComputeHash::*)(class std::shared_ptr<class VPUNN::VPUComputeNode>) const) &VPUNN::VPUComputeHash::operator(), "a VPUComputeNode object\n \n\n size_t\n\nC++: VPUNN::VPUComputeHash::operator()(class std::shared_ptr<class VPUNN::VPUComputeNode>) const --> unsigned long", pybind11::arg("op"));
	}
	{ // VPUNN::VPUComputeNodeMap file: line:131
		pybind11::class_<VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>, std::shared_ptr<VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>>> cl(M("VPUNN"), "VPUComputeNodeMap_std_vector_std_shared_ptr_VPUNN_VPUComputeNode_std_allocator_std_shared_ptr_VPUNN_VPUComputeNode_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >> const &o){ return new VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>(o); } ) );
		cl.def("__getitem__", (class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > & (VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > > >::operator[], "C++: VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > > >::operator[](const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > &", pybind11::return_value_policy::reference, pybind11::arg("_key"));
		cl.def("exists", (bool (VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > > >::exists, "C++: VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > > >::exists(const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> bool", pybind11::arg("_key"));
		cl.def("assign", (class VPUNN::VPUComputeNodeMap<class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > > & (VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > >>::*)(const class VPUNN::VPUComputeNodeMap<class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > > &)) &VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > > >::operator=, "C++: VPUNN::VPUComputeNodeMap<std::vector<std::shared_ptr<VPUNN::VPUComputeNode>, std::allocator<std::shared_ptr<VPUNN::VPUComputeNode> > > >::operator=(const class VPUNN::VPUComputeNodeMap<class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > > &) --> class VPUNN::VPUComputeNodeMap<class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > > &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPUComputeNodeMap file: line:131
		pybind11::class_<VPUNN::VPUComputeNodeMap<unsigned int>, std::shared_ptr<VPUNN::VPUComputeNodeMap<unsigned int>>> cl(M("VPUNN"), "VPUComputeNodeMap_unsigned_int_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUComputeNodeMap<unsigned int>(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUComputeNodeMap<unsigned int> const &o){ return new VPUNN::VPUComputeNodeMap<unsigned int>(o); } ) );
		cl.def("__getitem__", (unsigned int & (VPUNN::VPUComputeNodeMap<unsigned int>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<unsigned int>::operator[], "C++: VPUNN::VPUComputeNodeMap<unsigned int>::operator[](const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> unsigned int &", pybind11::return_value_policy::reference, pybind11::arg("_key"));
		cl.def("exists", (bool (VPUNN::VPUComputeNodeMap<unsigned int>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<unsigned int>::exists, "C++: VPUNN::VPUComputeNodeMap<unsigned int>::exists(const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> bool", pybind11::arg("_key"));
		cl.def("assign", (class VPUNN::VPUComputeNodeMap<unsigned int> & (VPUNN::VPUComputeNodeMap<unsigned int>::*)(const class VPUNN::VPUComputeNodeMap<unsigned int> &)) &VPUNN::VPUComputeNodeMap<unsigned int>::operator=, "C++: VPUNN::VPUComputeNodeMap<unsigned int>::operator=(const class VPUNN::VPUComputeNodeMap<unsigned int> &) --> class VPUNN::VPUComputeNodeMap<unsigned int> &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPUComputeNodeMap file: line:131
		pybind11::class_<VPUNN::VPUComputeNodeMap<bool>, std::shared_ptr<VPUNN::VPUComputeNodeMap<bool>>> cl(M("VPUNN"), "VPUComputeNodeMap_bool_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUComputeNodeMap<bool>(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUComputeNodeMap<bool> const &o){ return new VPUNN::VPUComputeNodeMap<bool>(o); } ) );
		cl.def("__getitem__", (bool & (VPUNN::VPUComputeNodeMap<bool>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<bool>::operator[], "C++: VPUNN::VPUComputeNodeMap<bool>::operator[](const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> bool &", pybind11::return_value_policy::reference, pybind11::arg("_key"));
		cl.def("exists", (bool (VPUNN::VPUComputeNodeMap<bool>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<bool>::exists, "C++: VPUNN::VPUComputeNodeMap<bool>::exists(const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> bool", pybind11::arg("_key"));
		cl.def("assign", (class VPUNN::VPUComputeNodeMap<bool> & (VPUNN::VPUComputeNodeMap<bool>::*)(const class VPUNN::VPUComputeNodeMap<bool> &)) &VPUNN::VPUComputeNodeMap<bool>::operator=, "C++: VPUNN::VPUComputeNodeMap<bool>::operator=(const class VPUNN::VPUComputeNodeMap<bool> &) --> class VPUNN::VPUComputeNodeMap<bool> &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPUComputeNodeMap file: line:131
		pybind11::class_<VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>, std::shared_ptr<VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>>> cl(M("VPUNN"), "VPUComputeNodeMap_VPUNN_VPULayerStrategy_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy> const &o){ return new VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>(o); } ) );
		cl.def("__getitem__", (struct VPUNN::VPULayerStrategy & (VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::operator[], "C++: VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::operator[](const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> struct VPUNN::VPULayerStrategy &", pybind11::return_value_policy::reference, pybind11::arg("_key"));
		cl.def("exists", (bool (VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::exists, "C++: VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::exists(const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> bool", pybind11::arg("_key"));
		cl.def("assign", (class VPUNN::VPUComputeNodeMap<struct VPUNN::VPULayerStrategy> & (VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::*)(const class VPUNN::VPUComputeNodeMap<struct VPUNN::VPULayerStrategy> &)) &VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::operator=, "C++: VPUNN::VPUComputeNodeMap<VPUNN::VPULayerStrategy>::operator=(const class VPUNN::VPUComputeNodeMap<struct VPUNN::VPULayerStrategy> &) --> class VPUNN::VPUComputeNodeMap<struct VPUNN::VPULayerStrategy> &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPUComputationDAG file: line:152
		pybind11::class_<VPUNN::VPUComputationDAG, std::shared_ptr<VPUNN::VPUComputationDAG>> cl(M("VPUNN"), "VPUComputationDAG", "Represent the Computation DAG in a VPU device\n\n ");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUComputationDAG(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUComputationDAG const &o){ return new VPUNN::VPUComputationDAG(o); } ) );
		cl.def("addNode", (class VPUNN::VPUComputationDAG & (VPUNN::VPUComputationDAG::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode>)) &VPUNN::VPUComputationDAG::addNode, "Add a node to a VPUComputationDAG\n\n \n\n \n\n VPUComputationDAG&\n\nC++: VPUNN::VPUComputationDAG::addNode(const class std::shared_ptr<class VPUNN::VPUComputeNode>) --> class VPUNN::VPUComputationDAG &", pybind11::return_value_policy::reference, pybind11::arg("layer"));
		cl.def("has", (bool (VPUNN::VPUComputationDAG::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode>) const) &VPUNN::VPUComputationDAG::has, "Return true if a VPUComputeNode is in the VPUComputationDAG\n\n \n layer VPUComputeNode\n \n\n true\n \n\n false\n\nC++: VPUNN::VPUComputationDAG::has(const class std::shared_ptr<class VPUNN::VPUComputeNode>) const --> bool", pybind11::arg("layer"));
		cl.def("addEdge", (class VPUNN::VPUComputationDAG & (VPUNN::VPUComputationDAG::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode>, const class std::shared_ptr<class VPUNN::VPUComputeNode>)) &VPUNN::VPUComputationDAG::addEdge, "add and edge to a VPUComputationDAG\n\n \n the edge predecessor\n \n\n the edge successor\n \n\n VPUComputationDAG&\n\nC++: VPUNN::VPUComputationDAG::addEdge(const class std::shared_ptr<class VPUNN::VPUComputeNode>, const class std::shared_ptr<class VPUNN::VPUComputeNode>) --> class VPUNN::VPUComputationDAG &", pybind11::return_value_policy::reference, pybind11::arg("source"), pybind11::arg("sink"));
		cl.def("nodes", (unsigned long (VPUNN::VPUComputationDAG::*)() const) &VPUNN::VPUComputationDAG::nodes, "Returns the number of nodes\n\n \n size_t\n\nC++: VPUNN::VPUComputationDAG::nodes() const --> unsigned long");
		cl.def("edges", (unsigned long (VPUNN::VPUComputationDAG::*)()) &VPUNN::VPUComputationDAG::edges, "Returns the number of edges\n\n \n size_t\n\nC++: VPUNN::VPUComputationDAG::edges() --> unsigned long");
		cl.def("sources", (class std::list<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > (VPUNN::VPUComputationDAG::*)()) &VPUNN::VPUComputationDAG::sources, "Returns the list of DAG sources\n\n \n std::list<std::shared_ptr<VPUComputeNode>>\n\nC++: VPUNN::VPUComputationDAG::sources() --> class std::list<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > >");
		cl.def("get_layers", (class std::list<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > (VPUNN::VPUComputationDAG::*)()) &VPUNN::VPUComputationDAG::get_layers, "Return a reference to layers\n\n \n std::list<VPUComputeNode>\n\nC++: VPUNN::VPUComputationDAG::get_layers() --> class std::list<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > >");
		cl.def("get_successors", (class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > (VPUNN::VPUComputationDAG::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode>)) &VPUNN::VPUComputationDAG::get_successors, "Return a list of successors of a layer\n\n \n a pointer to a VPUComputeNode\n \n\n std::vector<std::shared_ptr<VPUComputeNode>>\n\nC++: VPUNN::VPUComputationDAG::get_successors(const class std::shared_ptr<class VPUNN::VPUComputeNode>) --> class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > >", pybind11::arg("layer"));
		cl.def("get_predecessors", (class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > > (VPUNN::VPUComputationDAG::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode>)) &VPUNN::VPUComputationDAG::get_predecessors, "Return a list of predecessors of a layer\n\n \n layer a pointer to a VPUComputeNode\n \n\n std::vector<std::shared_ptr<VPUComputeNode>>\n\nC++: VPUNN::VPUComputationDAG::get_predecessors(const class std::shared_ptr<class VPUNN::VPUComputeNode>) --> class std::vector<class std::shared_ptr<class VPUNN::VPUComputeNode>, class std::allocator<class std::shared_ptr<class VPUNN::VPUComputeNode> > >", pybind11::arg("layer"));
		cl.def("begin", (struct VPUNN::VPUComputationDAG::Iterator (VPUNN::VPUComputationDAG::*)()) &VPUNN::VPUComputationDAG::begin, "DAG Iterator begin\n\n \n Iterator\n\nC++: VPUNN::VPUComputationDAG::begin() --> struct VPUNN::VPUComputationDAG::Iterator");
		cl.def("end", (struct VPUNN::VPUComputationDAG::Iterator (VPUNN::VPUComputationDAG::*)()) &VPUNN::VPUComputationDAG::end, "DAG Iterator end\n\n \n Iterator\n\nC++: VPUNN::VPUComputationDAG::end() --> struct VPUNN::VPUComputationDAG::Iterator");
		cl.def("assign", (class VPUNN::VPUComputationDAG & (VPUNN::VPUComputationDAG::*)(const class VPUNN::VPUComputationDAG &)) &VPUNN::VPUComputationDAG::operator=, "C++: VPUNN::VPUComputationDAG::operator=(const class VPUNN::VPUComputationDAG &) --> class VPUNN::VPUComputationDAG &", pybind11::return_value_policy::reference, pybind11::arg(""));

		{ // VPUNN::VPUComputationDAG::Iterator file: line:282
			auto & enclosing_class = cl;
			pybind11::class_<VPUNN::VPUComputationDAG::Iterator, std::shared_ptr<VPUNN::VPUComputationDAG::Iterator>> cl(enclosing_class, "Iterator", "A DAG iterator\n\n     ");
			cl.def( pybind11::init( [](class VPUNN::VPUComputationDAG & a0){ return new VPUNN::VPUComputationDAG::Iterator(a0); } ), "doc" , pybind11::arg("dag"));
			cl.def( pybind11::init<class VPUNN::VPUComputationDAG &, bool>(), pybind11::arg("dag"), pybind11::arg("all_visited") );

			cl.def( pybind11::init( [](VPUNN::VPUComputationDAG::Iterator const &o){ return new VPUNN::VPUComputationDAG::Iterator(o); } ) );
			cl.def("dereference", (class std::shared_ptr<class VPUNN::VPUComputeNode> (VPUNN::VPUComputationDAG::Iterator::*)() const) &VPUNN::VPUComputationDAG::Iterator::operator*, "Dereference operator\n\n \n std::shared_ptr<VPUComputeNode>\n\nC++: VPUNN::VPUComputationDAG::Iterator::operator*() const --> class std::shared_ptr<class VPUNN::VPUComputeNode>");
			cl.def("arrow", (class std::shared_ptr<class VPUNN::VPUComputeNode> (VPUNN::VPUComputationDAG::Iterator::*)()) &VPUNN::VPUComputationDAG::Iterator::operator->, "Arrow operator\n\n \n std::shared_ptr<VPUComputeNode>\n\nC++: VPUNN::VPUComputationDAG::Iterator::operator->() --> class std::shared_ptr<class VPUNN::VPUComputeNode>");
			cl.def("pre_increment", (struct VPUNN::VPUComputationDAG::Iterator & (VPUNN::VPUComputationDAG::Iterator::*)()) &VPUNN::VPUComputationDAG::Iterator::operator++, "Prefix increment operator\n\n \n Iterator&\n\nC++: VPUNN::VPUComputationDAG::Iterator::operator++() --> struct VPUNN::VPUComputationDAG::Iterator &", pybind11::return_value_policy::reference);
			cl.def("post_increment", (struct VPUNN::VPUComputationDAG::Iterator (VPUNN::VPUComputationDAG::Iterator::*)(int)) &VPUNN::VPUComputationDAG::Iterator::operator++, "Postfix increment operator\n\n \n Iterator\n\nC++: VPUNN::VPUComputationDAG::Iterator::operator++(int) --> struct VPUNN::VPUComputationDAG::Iterator", pybind11::arg(""));
		}

	}
}


// File: VPUNN_72.cpp
#include <list> // std::list
#include <memory> // std::allocator
#include <memory> // std::shared_ptr
#include <sstream> // __str__
#include <vector> // std::vector
#include <vpu_network_cost_model.h> // VPUNN::VPUNetworkCostModel
#include <vpu_network_cost_model.h> // VPUNN::VPUNetworkStrategy

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_72(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::VPUNetworkStrategy file:vpu_network_cost_model.h line:22
		pybind11::class_<VPUNN::VPUNetworkStrategy, std::shared_ptr<VPUNN::VPUNetworkStrategy>> cl(M("VPUNN"), "VPUNetworkStrategy", "VPU Network strategy type\n\n ");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUNetworkStrategy(); } ) );
		cl.def( pybind11::init( [](VPUNN::VPUNetworkStrategy const &o){ return new VPUNN::VPUNetworkStrategy(o); } ) );
		cl.def("__getitem__", (struct VPUNN::VPULayerStrategy & (VPUNN::VPUNetworkStrategy::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUNetworkStrategy::operator[], "C++: VPUNN::VPUNetworkStrategy::operator[](const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> struct VPUNN::VPULayerStrategy &", pybind11::return_value_policy::reference, pybind11::arg("_key"));
		cl.def("exists", (bool (VPUNN::VPUNetworkStrategy::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &)) &VPUNN::VPUNetworkStrategy::exists, "C++: VPUNN::VPUNetworkStrategy::exists(const class std::shared_ptr<class VPUNN::VPUComputeNode> &) --> bool", pybind11::arg("_key"));
		cl.def("set", (class VPUNN::VPUNetworkStrategy & (VPUNN::VPUNetworkStrategy::*)(const class std::shared_ptr<class VPUNN::VPUComputeNode> &, const struct VPUNN::VPULayerStrategy &)) &VPUNN::VPUNetworkStrategy::set, "C++: VPUNN::VPUNetworkStrategy::set(const class std::shared_ptr<class VPUNN::VPUComputeNode> &, const struct VPUNN::VPULayerStrategy &) --> class VPUNN::VPUNetworkStrategy &", pybind11::return_value_policy::reference, pybind11::arg("_key"), pybind11::arg("val"));
		cl.def("assign", (class VPUNN::VPUNetworkStrategy & (VPUNN::VPUNetworkStrategy::*)(const class VPUNN::VPUNetworkStrategy &)) &VPUNN::VPUNetworkStrategy::operator=, "C++: VPUNN::VPUNetworkStrategy::operator=(const class VPUNN::VPUNetworkStrategy &) --> class VPUNN::VPUNetworkStrategy &", pybind11::return_value_policy::reference, pybind11::arg(""));
	}
	{ // VPUNN::VPUNetworkCostModel file:vpu_network_cost_model.h line:47
		pybind11::class_<VPUNN::VPUNetworkCostModel, std::shared_ptr<VPUNN::VPUNetworkCostModel>, VPUNN::VPULayerCostModel> cl(M("VPUNN"), "VPUNetworkCostModel", "The VPUNN network cost model (also called VPUNN Level3 API)\n\n ");
		cl.def( pybind11::init( [](){ return new VPUNN::VPUNetworkCostModel(); } ) );
		cl.def( pybind11::init<class std::shared_ptr<class VPUNN::VPUCostModel>>(), pybind11::arg("dpu_cost_provider") );

		cl.def( pybind11::init<class std::shared_ptr<class VPUNN::VPUCostModel>, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *>>(), pybind11::arg("dpu_cost_provider"), pybind11::arg("dma_cost_model") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7, const char * a8){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6, unsigned long const & a7, const char * a8, unsigned long const & a9){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"));
		cl.def( pybind11::init<const char *, unsigned long, bool, bool, const unsigned int, const unsigned int, const char *, unsigned long, const char *, unsigned long, bool>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"), pybind11::arg("use_shave_2_api") );

		cl.def( pybind11::init( [](){ return new VPUNN::VPUNetworkCostModel(); } ), "doc" );
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::VPUNetworkCostModel(a0); } ), "doc" , pybind11::arg("filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1){ return new VPUNN::VPUNetworkCostModel(a0, a1); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4, const std::string & a5){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3, const std::string & a4, const std::string & a5, bool const & a6){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"));
		cl.def( pybind11::init<const std::string &, bool, const unsigned int, const unsigned int, const std::string &, const std::string &, bool, bool>(), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"), pybind11::arg("tryToLoadPairedCache") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7, unsigned long const & a8){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7, unsigned long const & a8, const char * a9){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a3, bool const & a4, const unsigned int & a5, const unsigned int & a6, const char * a7, unsigned long const & a8, const char * a9, unsigned long const & a10){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"));
		cl.def( pybind11::init<const char *, unsigned long, bool, const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *>, bool, const unsigned int, const unsigned int, const char *, unsigned long, const char *, unsigned long, bool>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("dma_cost_model"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_data"), pybind11::arg("dpu_cache_data_length"), pybind11::arg("shave_cache_data"), pybind11::arg("shave_cache_data_length"), pybind11::arg("use_shave_2_api") );

		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0){ return new VPUNN::VPUNetworkCostModel(a0); } ), "doc" , pybind11::arg("dma_cost_model"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1){ return new VPUNN::VPUNetworkCostModel(a0, a1); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4, const std::string & a5){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4, const std::string & a5, const std::string & a6){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"));
		cl.def( pybind11::init( [](const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *> & a0, const std::string & a1, bool const & a2, const unsigned int & a3, const unsigned int & a4, const std::string & a5, const std::string & a6, bool const & a7){ return new VPUNN::VPUNetworkCostModel(a0, a1, a2, a3, a4, a5, a6, a7); } ), "doc" , pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"));
		cl.def( pybind11::init<const class std::variant<class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27> *, class VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50> *>, const std::string &, bool, const unsigned int, const unsigned int, const std::string &, const std::string &, bool, bool>(), pybind11::arg("dma_cost_model"), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("dpu_cache_filename"), pybind11::arg("shave_cache_filename"), pybind11::arg("use_shave_2_api"), pybind11::arg("tryToLoadPairedCache") );

		cl.def("Network", (unsigned long (VPUNN::VPUNetworkCostModel::*)(class VPUNN::VPUComputationDAG &, class VPUNN::VPUNetworkStrategy &)) &VPUNN::VPUNetworkCostModel::Network, "Compute the cost of executing a network with a specific per-layer strategy\n\n \n a VPUComputationDAG representing the network to estimate\n \n\n a per-layer strategy\n \n\n unsigned long int\n\nC++: VPUNN::VPUNetworkCostModel::Network(class VPUNN::VPUComputationDAG &, class VPUNN::VPUNetworkStrategy &) --> unsigned long", pybind11::arg("dag"), pybind11::arg("strategy"));
	}
}


// File: VPUNN_73.cpp
#include <array> // std::array
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_4718_4715_t : public VPUNN::SHVActivation<4718,4715> {
	using VPUNN::SHVActivation<4718,4715>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<4718,4715> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_441_5067_t : public VPUNN::SHVActivation<441,5067> {
	using VPUNN::SHVActivation<441,5067>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<441,5067> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_547_4956_t : public VPUNN::SHVActivation<547,4956> {
	using VPUNN::SHVActivation<547,4956>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<547,4956> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_836_10043_t : public VPUNN::SHVActivation<836,10043> {
	using VPUNN::SHVActivation<836,10043>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<836,10043> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_1000_0_t : public VPUNN::SHVActivation<1000,0> {
	using VPUNN::SHVActivation<1000,0>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<1000,0> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_855_3319_t : public VPUNN::SHVActivation<855,3319> {
	using VPUNN::SHVActivation<855,3319>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<855,3319> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_742_4432_t : public VPUNN::SHVActivation<742,4432> {
	using VPUNN::SHVActivation<742,4432>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<742,4432> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_17_5192_t : public VPUNN::SHVActivation<17,5192> {
	using VPUNN::SHVActivation<17,5192>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<17,5192> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_742_3914_t : public VPUNN::SHVActivation<742,3914> {
	using VPUNN::SHVActivation<742,3914>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<742,3914> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_742_3824_t : public VPUNN::SHVActivation<742,3824> {
	using VPUNN::SHVActivation<742,3824>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<742,3824> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

void bind_VPUNN_73(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<4718,4715>, std::shared_ptr<VPUNN::SHVActivation<4718,4715>>, PyCallBack_VPUNN_SHVActivation_4718_4715_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_4718_4715_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_4718_4715_t const &o){ return new PyCallBack_VPUNN_SHVActivation_4718_4715_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<4718,4715> const &o){ return new VPUNN::SHVActivation<4718,4715>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<4718,4715>::*)() const) &VPUNN::SHVActivation<4718, 4715>::getKernelEfficiency, "C++: VPUNN::SHVActivation<4718, 4715>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<4718,4715>::*)() const) &VPUNN::SHVActivation<4718, 4715>::getLatency, "C++: VPUNN::SHVActivation<4718, 4715>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<4718,4715>::*)() const) &VPUNN::SHVActivation<4718, 4715>::cycles, "C++: VPUNN::SHVActivation<4718, 4715>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<441,5067>, std::shared_ptr<VPUNN::SHVActivation<441,5067>>, PyCallBack_VPUNN_SHVActivation_441_5067_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_441_5067_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_441_5067_t const &o){ return new PyCallBack_VPUNN_SHVActivation_441_5067_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<441,5067> const &o){ return new VPUNN::SHVActivation<441,5067>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<441,5067>::*)() const) &VPUNN::SHVActivation<441, 5067>::getKernelEfficiency, "C++: VPUNN::SHVActivation<441, 5067>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<441,5067>::*)() const) &VPUNN::SHVActivation<441, 5067>::getLatency, "C++: VPUNN::SHVActivation<441, 5067>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<441,5067>::*)() const) &VPUNN::SHVActivation<441, 5067>::cycles, "C++: VPUNN::SHVActivation<441, 5067>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<547,4956>, std::shared_ptr<VPUNN::SHVActivation<547,4956>>, PyCallBack_VPUNN_SHVActivation_547_4956_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_547_4956_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_547_4956_t const &o){ return new PyCallBack_VPUNN_SHVActivation_547_4956_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<547,4956> const &o){ return new VPUNN::SHVActivation<547,4956>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<547,4956>::*)() const) &VPUNN::SHVActivation<547, 4956>::getKernelEfficiency, "C++: VPUNN::SHVActivation<547, 4956>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<547,4956>::*)() const) &VPUNN::SHVActivation<547, 4956>::getLatency, "C++: VPUNN::SHVActivation<547, 4956>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<547,4956>::*)() const) &VPUNN::SHVActivation<547, 4956>::cycles, "C++: VPUNN::SHVActivation<547, 4956>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<836,10043>, std::shared_ptr<VPUNN::SHVActivation<836,10043>>, PyCallBack_VPUNN_SHVActivation_836_10043_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_836_10043_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_836_10043_t const &o){ return new PyCallBack_VPUNN_SHVActivation_836_10043_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<836,10043> const &o){ return new VPUNN::SHVActivation<836,10043>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<836,10043>::*)() const) &VPUNN::SHVActivation<836, 10043>::getKernelEfficiency, "C++: VPUNN::SHVActivation<836, 10043>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<836,10043>::*)() const) &VPUNN::SHVActivation<836, 10043>::getLatency, "C++: VPUNN::SHVActivation<836, 10043>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<836,10043>::*)() const) &VPUNN::SHVActivation<836, 10043>::cycles, "C++: VPUNN::SHVActivation<836, 10043>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<1000,0>, std::shared_ptr<VPUNN::SHVActivation<1000,0>>, PyCallBack_VPUNN_SHVActivation_1000_0_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_1000_0_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_1000_0_t const &o){ return new PyCallBack_VPUNN_SHVActivation_1000_0_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<1000,0> const &o){ return new VPUNN::SHVActivation<1000,0>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<1000,0>::*)() const) &VPUNN::SHVActivation<1000, 0>::getKernelEfficiency, "C++: VPUNN::SHVActivation<1000, 0>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<1000,0>::*)() const) &VPUNN::SHVActivation<1000, 0>::getLatency, "C++: VPUNN::SHVActivation<1000, 0>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<1000,0>::*)() const) &VPUNN::SHVActivation<1000, 0>::cycles, "C++: VPUNN::SHVActivation<1000, 0>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<855,3319>, std::shared_ptr<VPUNN::SHVActivation<855,3319>>, PyCallBack_VPUNN_SHVActivation_855_3319_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_855_3319_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_855_3319_t const &o){ return new PyCallBack_VPUNN_SHVActivation_855_3319_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<855,3319> const &o){ return new VPUNN::SHVActivation<855,3319>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<855,3319>::*)() const) &VPUNN::SHVActivation<855, 3319>::getKernelEfficiency, "C++: VPUNN::SHVActivation<855, 3319>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<855,3319>::*)() const) &VPUNN::SHVActivation<855, 3319>::getLatency, "C++: VPUNN::SHVActivation<855, 3319>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<855,3319>::*)() const) &VPUNN::SHVActivation<855, 3319>::cycles, "C++: VPUNN::SHVActivation<855, 3319>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<742,4432>, std::shared_ptr<VPUNN::SHVActivation<742,4432>>, PyCallBack_VPUNN_SHVActivation_742_4432_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_742_4432_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_742_4432_t const &o){ return new PyCallBack_VPUNN_SHVActivation_742_4432_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<742,4432> const &o){ return new VPUNN::SHVActivation<742,4432>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<742,4432>::*)() const) &VPUNN::SHVActivation<742, 4432>::getKernelEfficiency, "C++: VPUNN::SHVActivation<742, 4432>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<742,4432>::*)() const) &VPUNN::SHVActivation<742, 4432>::getLatency, "C++: VPUNN::SHVActivation<742, 4432>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<742,4432>::*)() const) &VPUNN::SHVActivation<742, 4432>::cycles, "C++: VPUNN::SHVActivation<742, 4432>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<17,5192>, std::shared_ptr<VPUNN::SHVActivation<17,5192>>, PyCallBack_VPUNN_SHVActivation_17_5192_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_17_5192_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_17_5192_t const &o){ return new PyCallBack_VPUNN_SHVActivation_17_5192_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<17,5192> const &o){ return new VPUNN::SHVActivation<17,5192>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<17,5192>::*)() const) &VPUNN::SHVActivation<17, 5192>::getKernelEfficiency, "C++: VPUNN::SHVActivation<17, 5192>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<17,5192>::*)() const) &VPUNN::SHVActivation<17, 5192>::getLatency, "C++: VPUNN::SHVActivation<17, 5192>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<17,5192>::*)() const) &VPUNN::SHVActivation<17, 5192>::cycles, "C++: VPUNN::SHVActivation<17, 5192>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<742,3914>, std::shared_ptr<VPUNN::SHVActivation<742,3914>>, PyCallBack_VPUNN_SHVActivation_742_3914_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_742_3914_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_742_3914_t const &o){ return new PyCallBack_VPUNN_SHVActivation_742_3914_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<742,3914> const &o){ return new VPUNN::SHVActivation<742,3914>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<742,3914>::*)() const) &VPUNN::SHVActivation<742, 3914>::getKernelEfficiency, "C++: VPUNN::SHVActivation<742, 3914>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<742,3914>::*)() const) &VPUNN::SHVActivation<742, 3914>::getLatency, "C++: VPUNN::SHVActivation<742, 3914>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<742,3914>::*)() const) &VPUNN::SHVActivation<742, 3914>::cycles, "C++: VPUNN::SHVActivation<742, 3914>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<742,3824>, std::shared_ptr<VPUNN::SHVActivation<742,3824>>, PyCallBack_VPUNN_SHVActivation_742_3824_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_742_3824_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_742_3824_t const &o){ return new PyCallBack_VPUNN_SHVActivation_742_3824_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<742,3824> const &o){ return new VPUNN::SHVActivation<742,3824>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<742,3824>::*)() const) &VPUNN::SHVActivation<742, 3824>::getKernelEfficiency, "C++: VPUNN::SHVActivation<742, 3824>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<742,3824>::*)() const) &VPUNN::SHVActivation<742, 3824>::getLatency, "C++: VPUNN::SHVActivation<742, 3824>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<742,3824>::*)() const) &VPUNN::SHVActivation<742, 3824>::cycles, "C++: VPUNN::SHVActivation<742, 3824>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
}


// File: VPUNN_74.cpp
#include <array> // std::array
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_397_5138_t : public VPUNN::SHVActivation<397,5138> {
	using VPUNN::SHVActivation<397,5138>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<397,5138> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_742_3831_t : public VPUNN::SHVActivation<742,3831> {
	using VPUNN::SHVActivation<742,3831>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<742,3831> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_10_8482_t : public VPUNN::SHVActivation<10,8482> {
	using VPUNN::SHVActivation<10,8482>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<10,8482> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_291_6349_t : public VPUNN::SHVActivation<291,6349> {
	using VPUNN::SHVActivation<291,6349>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<291,6349> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_69_27428_t : public VPUNN::SHVActivation<69,27428> {
	using VPUNN::SHVActivation<69,27428>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<69,27428> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_830_2810_t : public VPUNN::SHVActivation<830,2810> {
	using VPUNN::SHVActivation<830,2810>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<830,2810> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVActivation file: line:27
struct PyCallBack_VPUNN_SHVActivation_306_8391_t : public VPUNN::SHVActivation<306,8391> {
	using VPUNN::SHVActivation<306,8391>::SHVActivation;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVActivation<306,8391> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVDataMovement file: line:27
struct PyCallBack_VPUNN_SHVDataMovement_1000_0_t : public VPUNN::SHVDataMovement<1000,0> {
	using VPUNN::SHVDataMovement<1000,0>::SHVDataMovement;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVDataMovement<1000,0> *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVSigmoid file: line:10
struct PyCallBack_VPUNN_SHVSigmoid : public VPUNN::SHVSigmoid {
	using VPUNN::SHVSigmoid::SHVSigmoid;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSigmoid *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVELU file: line:10
struct PyCallBack_VPUNN_SHVELU : public VPUNN::SHVELU {
	using VPUNN::SHVELU::SHVELU;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVELU *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVHardSigmoid file: line:10
struct PyCallBack_VPUNN_SHVHardSigmoid : public VPUNN::SHVHardSigmoid {
	using VPUNN::SHVHardSigmoid::SHVHardSigmoid;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVHardSigmoid *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSoftmax file: line:10
struct PyCallBack_VPUNN_SHVSoftmax : public VPUNN::SHVSoftmax {
	using VPUNN::SHVSoftmax::SHVSoftmax;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSoftmax *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

void bind_VPUNN_74(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<397,5138>, std::shared_ptr<VPUNN::SHVActivation<397,5138>>, PyCallBack_VPUNN_SHVActivation_397_5138_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_397_5138_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_397_5138_t const &o){ return new PyCallBack_VPUNN_SHVActivation_397_5138_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<397,5138> const &o){ return new VPUNN::SHVActivation<397,5138>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<397,5138>::*)() const) &VPUNN::SHVActivation<397, 5138>::getKernelEfficiency, "C++: VPUNN::SHVActivation<397, 5138>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<397,5138>::*)() const) &VPUNN::SHVActivation<397, 5138>::getLatency, "C++: VPUNN::SHVActivation<397, 5138>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<397,5138>::*)() const) &VPUNN::SHVActivation<397, 5138>::cycles, "C++: VPUNN::SHVActivation<397, 5138>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<742,3831>, std::shared_ptr<VPUNN::SHVActivation<742,3831>>, PyCallBack_VPUNN_SHVActivation_742_3831_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_742_3831_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_742_3831_t const &o){ return new PyCallBack_VPUNN_SHVActivation_742_3831_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<742,3831> const &o){ return new VPUNN::SHVActivation<742,3831>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<742,3831>::*)() const) &VPUNN::SHVActivation<742, 3831>::getKernelEfficiency, "C++: VPUNN::SHVActivation<742, 3831>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<742,3831>::*)() const) &VPUNN::SHVActivation<742, 3831>::getLatency, "C++: VPUNN::SHVActivation<742, 3831>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<742,3831>::*)() const) &VPUNN::SHVActivation<742, 3831>::cycles, "C++: VPUNN::SHVActivation<742, 3831>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<10,8482>, std::shared_ptr<VPUNN::SHVActivation<10,8482>>, PyCallBack_VPUNN_SHVActivation_10_8482_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_10_8482_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_10_8482_t const &o){ return new PyCallBack_VPUNN_SHVActivation_10_8482_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<10,8482> const &o){ return new VPUNN::SHVActivation<10,8482>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<10,8482>::*)() const) &VPUNN::SHVActivation<10, 8482>::getKernelEfficiency, "C++: VPUNN::SHVActivation<10, 8482>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<10,8482>::*)() const) &VPUNN::SHVActivation<10, 8482>::getLatency, "C++: VPUNN::SHVActivation<10, 8482>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<10,8482>::*)() const) &VPUNN::SHVActivation<10, 8482>::cycles, "C++: VPUNN::SHVActivation<10, 8482>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<291,6349>, std::shared_ptr<VPUNN::SHVActivation<291,6349>>, PyCallBack_VPUNN_SHVActivation_291_6349_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_291_6349_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_291_6349_t const &o){ return new PyCallBack_VPUNN_SHVActivation_291_6349_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<291,6349> const &o){ return new VPUNN::SHVActivation<291,6349>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<291,6349>::*)() const) &VPUNN::SHVActivation<291, 6349>::getKernelEfficiency, "C++: VPUNN::SHVActivation<291, 6349>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<291,6349>::*)() const) &VPUNN::SHVActivation<291, 6349>::getLatency, "C++: VPUNN::SHVActivation<291, 6349>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<291,6349>::*)() const) &VPUNN::SHVActivation<291, 6349>::cycles, "C++: VPUNN::SHVActivation<291, 6349>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<69,27428>, std::shared_ptr<VPUNN::SHVActivation<69,27428>>, PyCallBack_VPUNN_SHVActivation_69_27428_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_69_27428_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_69_27428_t const &o){ return new PyCallBack_VPUNN_SHVActivation_69_27428_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<69,27428> const &o){ return new VPUNN::SHVActivation<69,27428>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<69,27428>::*)() const) &VPUNN::SHVActivation<69, 27428>::getKernelEfficiency, "C++: VPUNN::SHVActivation<69, 27428>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<69,27428>::*)() const) &VPUNN::SHVActivation<69, 27428>::getLatency, "C++: VPUNN::SHVActivation<69, 27428>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<69,27428>::*)() const) &VPUNN::SHVActivation<69, 27428>::cycles, "C++: VPUNN::SHVActivation<69, 27428>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<830,2810>, std::shared_ptr<VPUNN::SHVActivation<830,2810>>, PyCallBack_VPUNN_SHVActivation_830_2810_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_830_2810_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_830_2810_t const &o){ return new PyCallBack_VPUNN_SHVActivation_830_2810_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<830,2810> const &o){ return new VPUNN::SHVActivation<830,2810>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<830,2810>::*)() const) &VPUNN::SHVActivation<830, 2810>::getKernelEfficiency, "C++: VPUNN::SHVActivation<830, 2810>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<830,2810>::*)() const) &VPUNN::SHVActivation<830, 2810>::getLatency, "C++: VPUNN::SHVActivation<830, 2810>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<830,2810>::*)() const) &VPUNN::SHVActivation<830, 2810>::cycles, "C++: VPUNN::SHVActivation<830, 2810>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVActivation file: line:27
		pybind11::class_<VPUNN::SHVActivation<306,8391>, std::shared_ptr<VPUNN::SHVActivation<306,8391>>, PyCallBack_VPUNN_SHVActivation_306_8391_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVActivation_306_8391_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVActivation_306_8391_t const &o){ return new PyCallBack_VPUNN_SHVActivation_306_8391_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVActivation<306,8391> const &o){ return new VPUNN::SHVActivation<306,8391>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVActivation<306,8391>::*)() const) &VPUNN::SHVActivation<306, 8391>::getKernelEfficiency, "C++: VPUNN::SHVActivation<306, 8391>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVActivation<306,8391>::*)() const) &VPUNN::SHVActivation<306, 8391>::getLatency, "C++: VPUNN::SHVActivation<306, 8391>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVActivation<306,8391>::*)() const) &VPUNN::SHVActivation<306, 8391>::cycles, "C++: VPUNN::SHVActivation<306, 8391>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVDataMovement file: line:27
		pybind11::class_<VPUNN::SHVDataMovement<1000,0>, std::shared_ptr<VPUNN::SHVDataMovement<1000,0>>, PyCallBack_VPUNN_SHVDataMovement_1000_0_t, VPUNN::SWOperation> cl(M("VPUNN"), "SHVDataMovement_1000_0_t", "");
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVDataMovement_1000_0_t const &o){ return new PyCallBack_VPUNN_SHVDataMovement_1000_0_t(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVDataMovement<1000,0> const &o){ return new VPUNN::SHVDataMovement<1000,0>(o); } ) );
		cl.def("getKernelEfficiency", (float (VPUNN::SHVDataMovement<1000,0>::*)() const) &VPUNN::SHVDataMovement<1000, 0>::getKernelEfficiency, "C++: VPUNN::SHVDataMovement<1000, 0>::getKernelEfficiency() const --> float");
		cl.def("getLatency", (unsigned int (VPUNN::SHVDataMovement<1000,0>::*)() const) &VPUNN::SHVDataMovement<1000, 0>::getLatency, "C++: VPUNN::SHVDataMovement<1000, 0>::getLatency() const --> unsigned int");
		cl.def("cycles", (unsigned int (VPUNN::SHVDataMovement<1000,0>::*)() const) &VPUNN::SHVDataMovement<1000, 0>::cycles, "C++: VPUNN::SHVDataMovement<1000, 0>::cycles() const --> unsigned int");
		cl.def_readwrite("device", &VPUNN::SWOperation::device);
		cl.def_readonly("inputs", &VPUNN::SWOperation::inputs);
		cl.def_readonly("outputs", &VPUNN::SWOperation::outputs);
		cl.def_readonly("loc_name", &VPUNN::SWOperation::loc_name);
		cl.def("cycles", (unsigned int (VPUNN::SWOperation::*)() const) &VPUNN::SWOperation::cycles, "Return the number of cycles of the sw operation\n\n \n unsigned int\n\nC++: VPUNN::SWOperation::cycles() const --> unsigned int");
	}
	{ // VPUNN::SHVSigmoid file: line:10
		pybind11::class_<VPUNN::SHVSigmoid, std::shared_ptr<VPUNN::SHVSigmoid>, PyCallBack_VPUNN_SHVSigmoid, VPUNN::SHVActivation<4718,4715>> cl(M("VPUNN"), "SHVSigmoid", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSigmoid const &o){ return new PyCallBack_VPUNN_SHVSigmoid(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSigmoid const &o){ return new VPUNN::SHVSigmoid(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVELU file: line:10
		pybind11::class_<VPUNN::SHVELU, std::shared_ptr<VPUNN::SHVELU>, PyCallBack_VPUNN_SHVELU, VPUNN::SHVActivation<441,5067>> cl(M("VPUNN"), "SHVELU", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVELU const &o){ return new PyCallBack_VPUNN_SHVELU(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVELU const &o){ return new VPUNN::SHVELU(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVHardSigmoid file: line:10
		pybind11::class_<VPUNN::SHVHardSigmoid, std::shared_ptr<VPUNN::SHVHardSigmoid>, PyCallBack_VPUNN_SHVHardSigmoid, VPUNN::SHVActivation<547,4956>> cl(M("VPUNN"), "SHVHardSigmoid", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVHardSigmoid const &o){ return new PyCallBack_VPUNN_SHVHardSigmoid(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVHardSigmoid const &o){ return new VPUNN::SHVHardSigmoid(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSoftmax file: line:10
		pybind11::class_<VPUNN::SHVSoftmax, std::shared_ptr<VPUNN::SHVSoftmax>, PyCallBack_VPUNN_SHVSoftmax, VPUNN::SHVActivation<836,10043>> cl(M("VPUNN"), "SHVSoftmax", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSoftmax const &o){ return new PyCallBack_VPUNN_SHVSoftmax(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSoftmax const &o){ return new VPUNN::SHVSoftmax(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
}


// File: VPUNN_75.cpp
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SHVHardSwish file: line:10
struct PyCallBack_VPUNN_SHVHardSwish : public VPUNN::SHVHardSwish {
	using VPUNN::SHVHardSwish::SHVHardSwish;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVHardSwish *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVClamp file: line:10
struct PyCallBack_VPUNN_SHVClamp : public VPUNN::SHVClamp {
	using VPUNN::SHVClamp::SHVClamp;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVClamp *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVFakeQuantize file: line:10
struct PyCallBack_VPUNN_SHVFakeQuantize : public VPUNN::SHVFakeQuantize {
	using VPUNN::SHVFakeQuantize::SHVFakeQuantize;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVFakeQuantize *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVQuantizeCast file: line:10
struct PyCallBack_VPUNN_SHVQuantizeCast : public VPUNN::SHVQuantizeCast {
	using VPUNN::SHVQuantizeCast::SHVQuantizeCast;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVQuantizeCast *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVTanh file: line:10
struct PyCallBack_VPUNN_SHVTanh : public VPUNN::SHVTanh {
	using VPUNN::SHVTanh::SHVTanh;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVTanh *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSin file: line:10
struct PyCallBack_VPUNN_SHVSin : public VPUNN::SHVSin {
	using VPUNN::SHVSin::SHVSin;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSin *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVCos file: line:10
struct PyCallBack_VPUNN_SHVCos : public VPUNN::SHVCos {
	using VPUNN::SHVCos::SHVCos;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVCos *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSqrt file: line:10
struct PyCallBack_VPUNN_SHVSqrt : public VPUNN::SHVSqrt {
	using VPUNN::SHVSqrt::SHVSqrt;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSqrt *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSinh file: line:10
struct PyCallBack_VPUNN_SHVSinh : public VPUNN::SHVSinh {
	using VPUNN::SHVSinh::SHVSinh;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSinh *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVCosh file: line:10
struct PyCallBack_VPUNN_SHVCosh : public VPUNN::SHVCosh {
	using VPUNN::SHVCosh::SHVCosh;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVCosh *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAsinh file: line:10
struct PyCallBack_VPUNN_SHVAsinh : public VPUNN::SHVAsinh {
	using VPUNN::SHVAsinh::SHVAsinh;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAsinh *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAcosh file: line:10
struct PyCallBack_VPUNN_SHVAcosh : public VPUNN::SHVAcosh {
	using VPUNN::SHVAcosh::SHVAcosh;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAcosh *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAbs file: line:10
struct PyCallBack_VPUNN_SHVAbs : public VPUNN::SHVAbs {
	using VPUNN::SHVAbs::SHVAbs;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAbs *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAtan file: line:10
struct PyCallBack_VPUNN_SHVAtan : public VPUNN::SHVAtan {
	using VPUNN::SHVAtan::SHVAtan;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAtan *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAsin file: line:10
struct PyCallBack_VPUNN_SHVAsin : public VPUNN::SHVAsin {
	using VPUNN::SHVAsin::SHVAsin;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAsin *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAcos file: line:10
struct PyCallBack_VPUNN_SHVAcos : public VPUNN::SHVAcos {
	using VPUNN::SHVAcos::SHVAcos;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAcos *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVAtanh file: line:10
struct PyCallBack_VPUNN_SHVAtanh : public VPUNN::SHVAtanh {
	using VPUNN::SHVAtanh::SHVAtanh;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAtanh *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVLog file: line:10
struct PyCallBack_VPUNN_SHVLog : public VPUNN::SHVLog {
	using VPUNN::SHVLog::SHVLog;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVLog *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSelu file: line:10
struct PyCallBack_VPUNN_SHVSelu : public VPUNN::SHVSelu {
	using VPUNN::SHVSelu::SHVSelu;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSelu *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVGelu file: line:10
struct PyCallBack_VPUNN_SHVGelu : public VPUNN::SHVGelu {
	using VPUNN::SHVGelu::SHVGelu;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVGelu *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVExp file: line:10
struct PyCallBack_VPUNN_SHVExp : public VPUNN::SHVExp {
	using VPUNN::SHVExp::SHVExp;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVExp *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVFloor file: line:10
struct PyCallBack_VPUNN_SHVFloor : public VPUNN::SHVFloor {
	using VPUNN::SHVFloor::SHVFloor;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVFloor *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVRound file: line:10
struct PyCallBack_VPUNN_SHVRound : public VPUNN::SHVRound {
	using VPUNN::SHVRound::SHVRound;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVRound *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVMish file: line:10
struct PyCallBack_VPUNN_SHVMish : public VPUNN::SHVMish {
	using VPUNN::SHVMish::SHVMish;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVMish *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVErf file: line:10
struct PyCallBack_VPUNN_SHVErf : public VPUNN::SHVErf {
	using VPUNN::SHVErf::SHVErf;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVErf *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVNegative file: line:10
struct PyCallBack_VPUNN_SHVNegative : public VPUNN::SHVNegative {
	using VPUNN::SHVNegative::SHVNegative;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVNegative *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSign file: line:10
struct PyCallBack_VPUNN_SHVSign : public VPUNN::SHVSign {
	using VPUNN::SHVSign::SHVSign;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSign *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVScaleShift file: line:10
struct PyCallBack_VPUNN_SHVScaleShift : public VPUNN::SHVScaleShift {
	using VPUNN::SHVScaleShift::SHVScaleShift;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVScaleShift *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

void bind_VPUNN_75(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::SHVHardSwish file: line:10
		pybind11::class_<VPUNN::SHVHardSwish, std::shared_ptr<VPUNN::SHVHardSwish>, PyCallBack_VPUNN_SHVHardSwish, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVHardSwish", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVHardSwish const &o){ return new PyCallBack_VPUNN_SHVHardSwish(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVHardSwish const &o){ return new VPUNN::SHVHardSwish(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVClamp file: line:10
		pybind11::class_<VPUNN::SHVClamp, std::shared_ptr<VPUNN::SHVClamp>, PyCallBack_VPUNN_SHVClamp, VPUNN::SHVActivation<855,3319>> cl(M("VPUNN"), "SHVClamp", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVClamp const &o){ return new PyCallBack_VPUNN_SHVClamp(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVClamp const &o){ return new VPUNN::SHVClamp(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVFakeQuantize file: line:10
		pybind11::class_<VPUNN::SHVFakeQuantize, std::shared_ptr<VPUNN::SHVFakeQuantize>, PyCallBack_VPUNN_SHVFakeQuantize, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVFakeQuantize", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVFakeQuantize const &o){ return new PyCallBack_VPUNN_SHVFakeQuantize(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVFakeQuantize const &o){ return new VPUNN::SHVFakeQuantize(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVQuantizeCast file: line:10
		pybind11::class_<VPUNN::SHVQuantizeCast, std::shared_ptr<VPUNN::SHVQuantizeCast>, PyCallBack_VPUNN_SHVQuantizeCast, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVQuantizeCast", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVQuantizeCast const &o){ return new PyCallBack_VPUNN_SHVQuantizeCast(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVQuantizeCast const &o){ return new VPUNN::SHVQuantizeCast(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVTanh file: line:10
		pybind11::class_<VPUNN::SHVTanh, std::shared_ptr<VPUNN::SHVTanh>, PyCallBack_VPUNN_SHVTanh, VPUNN::SHVActivation<742,4432>> cl(M("VPUNN"), "SHVTanh", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVTanh const &o){ return new PyCallBack_VPUNN_SHVTanh(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVTanh const &o){ return new VPUNN::SHVTanh(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSin file: line:10
		pybind11::class_<VPUNN::SHVSin, std::shared_ptr<VPUNN::SHVSin>, PyCallBack_VPUNN_SHVSin, VPUNN::SHVActivation<17,5192>> cl(M("VPUNN"), "SHVSin", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSin const &o){ return new PyCallBack_VPUNN_SHVSin(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSin const &o){ return new VPUNN::SHVSin(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVCos file: line:10
		pybind11::class_<VPUNN::SHVCos, std::shared_ptr<VPUNN::SHVCos>, PyCallBack_VPUNN_SHVCos, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVCos", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVCos const &o){ return new PyCallBack_VPUNN_SHVCos(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVCos const &o){ return new VPUNN::SHVCos(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSqrt file: line:10
		pybind11::class_<VPUNN::SHVSqrt, std::shared_ptr<VPUNN::SHVSqrt>, PyCallBack_VPUNN_SHVSqrt, VPUNN::SHVActivation<742,3914>> cl(M("VPUNN"), "SHVSqrt", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSqrt const &o){ return new PyCallBack_VPUNN_SHVSqrt(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSqrt const &o){ return new VPUNN::SHVSqrt(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSinh file: line:10
		pybind11::class_<VPUNN::SHVSinh, std::shared_ptr<VPUNN::SHVSinh>, PyCallBack_VPUNN_SHVSinh, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVSinh", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSinh const &o){ return new PyCallBack_VPUNN_SHVSinh(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSinh const &o){ return new VPUNN::SHVSinh(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVCosh file: line:10
		pybind11::class_<VPUNN::SHVCosh, std::shared_ptr<VPUNN::SHVCosh>, PyCallBack_VPUNN_SHVCosh, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVCosh", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVCosh const &o){ return new PyCallBack_VPUNN_SHVCosh(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVCosh const &o){ return new VPUNN::SHVCosh(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAsinh file: line:10
		pybind11::class_<VPUNN::SHVAsinh, std::shared_ptr<VPUNN::SHVAsinh>, PyCallBack_VPUNN_SHVAsinh, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAsinh", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAsinh const &o){ return new PyCallBack_VPUNN_SHVAsinh(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAsinh const &o){ return new VPUNN::SHVAsinh(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAcosh file: line:10
		pybind11::class_<VPUNN::SHVAcosh, std::shared_ptr<VPUNN::SHVAcosh>, PyCallBack_VPUNN_SHVAcosh, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAcosh", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAcosh const &o){ return new PyCallBack_VPUNN_SHVAcosh(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAcosh const &o){ return new VPUNN::SHVAcosh(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAbs file: line:10
		pybind11::class_<VPUNN::SHVAbs, std::shared_ptr<VPUNN::SHVAbs>, PyCallBack_VPUNN_SHVAbs, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAbs", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAbs const &o){ return new PyCallBack_VPUNN_SHVAbs(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAbs const &o){ return new VPUNN::SHVAbs(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAtan file: line:10
		pybind11::class_<VPUNN::SHVAtan, std::shared_ptr<VPUNN::SHVAtan>, PyCallBack_VPUNN_SHVAtan, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAtan", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAtan const &o){ return new PyCallBack_VPUNN_SHVAtan(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAtan const &o){ return new VPUNN::SHVAtan(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAsin file: line:10
		pybind11::class_<VPUNN::SHVAsin, std::shared_ptr<VPUNN::SHVAsin>, PyCallBack_VPUNN_SHVAsin, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAsin", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAsin const &o){ return new PyCallBack_VPUNN_SHVAsin(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAsin const &o){ return new VPUNN::SHVAsin(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAcos file: line:10
		pybind11::class_<VPUNN::SHVAcos, std::shared_ptr<VPUNN::SHVAcos>, PyCallBack_VPUNN_SHVAcos, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAcos", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAcos const &o){ return new PyCallBack_VPUNN_SHVAcos(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAcos const &o){ return new VPUNN::SHVAcos(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAtanh file: line:10
		pybind11::class_<VPUNN::SHVAtanh, std::shared_ptr<VPUNN::SHVAtanh>, PyCallBack_VPUNN_SHVAtanh, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVAtanh", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAtanh const &o){ return new PyCallBack_VPUNN_SHVAtanh(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAtanh const &o){ return new VPUNN::SHVAtanh(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVLog file: line:10
		pybind11::class_<VPUNN::SHVLog, std::shared_ptr<VPUNN::SHVLog>, PyCallBack_VPUNN_SHVLog, VPUNN::SHVActivation<742,3824>> cl(M("VPUNN"), "SHVLog", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVLog const &o){ return new PyCallBack_VPUNN_SHVLog(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVLog const &o){ return new VPUNN::SHVLog(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSelu file: line:10
		pybind11::class_<VPUNN::SHVSelu, std::shared_ptr<VPUNN::SHVSelu>, PyCallBack_VPUNN_SHVSelu, VPUNN::SHVActivation<397,5138>> cl(M("VPUNN"), "SHVSelu", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSelu const &o){ return new PyCallBack_VPUNN_SHVSelu(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSelu const &o){ return new VPUNN::SHVSelu(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVGelu file: line:10
		pybind11::class_<VPUNN::SHVGelu, std::shared_ptr<VPUNN::SHVGelu>, PyCallBack_VPUNN_SHVGelu, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVGelu", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVGelu const &o){ return new PyCallBack_VPUNN_SHVGelu(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVGelu const &o){ return new VPUNN::SHVGelu(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVExp file: line:10
		pybind11::class_<VPUNN::SHVExp, std::shared_ptr<VPUNN::SHVExp>, PyCallBack_VPUNN_SHVExp, VPUNN::SHVActivation<742,3831>> cl(M("VPUNN"), "SHVExp", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVExp const &o){ return new PyCallBack_VPUNN_SHVExp(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVExp const &o){ return new VPUNN::SHVExp(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVFloor file: line:10
		pybind11::class_<VPUNN::SHVFloor, std::shared_ptr<VPUNN::SHVFloor>, PyCallBack_VPUNN_SHVFloor, VPUNN::SHVActivation<10,8482>> cl(M("VPUNN"), "SHVFloor", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVFloor const &o){ return new PyCallBack_VPUNN_SHVFloor(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVFloor const &o){ return new VPUNN::SHVFloor(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVRound file: line:10
		pybind11::class_<VPUNN::SHVRound, std::shared_ptr<VPUNN::SHVRound>, PyCallBack_VPUNN_SHVRound, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVRound", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVRound const &o){ return new PyCallBack_VPUNN_SHVRound(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVRound const &o){ return new VPUNN::SHVRound(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVMish file: line:10
		pybind11::class_<VPUNN::SHVMish, std::shared_ptr<VPUNN::SHVMish>, PyCallBack_VPUNN_SHVMish, VPUNN::SHVActivation<291,6349>> cl(M("VPUNN"), "SHVMish", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVMish const &o){ return new PyCallBack_VPUNN_SHVMish(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVMish const &o){ return new VPUNN::SHVMish(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVErf file: line:10
		pybind11::class_<VPUNN::SHVErf, std::shared_ptr<VPUNN::SHVErf>, PyCallBack_VPUNN_SHVErf, VPUNN::SHVActivation<69,27428>> cl(M("VPUNN"), "SHVErf", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVErf const &o){ return new PyCallBack_VPUNN_SHVErf(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVErf const &o){ return new VPUNN::SHVErf(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVNegative file: line:10
		pybind11::class_<VPUNN::SHVNegative, std::shared_ptr<VPUNN::SHVNegative>, PyCallBack_VPUNN_SHVNegative, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVNegative", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVNegative const &o){ return new PyCallBack_VPUNN_SHVNegative(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVNegative const &o){ return new VPUNN::SHVNegative(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSign file: line:10
		pybind11::class_<VPUNN::SHVSign, std::shared_ptr<VPUNN::SHVSign>, PyCallBack_VPUNN_SHVSign, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVSign", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSign const &o){ return new PyCallBack_VPUNN_SHVSign(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSign const &o){ return new VPUNN::SHVSign(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVScaleShift file: line:10
		pybind11::class_<VPUNN::SHVScaleShift, std::shared_ptr<VPUNN::SHVScaleShift>, PyCallBack_VPUNN_SHVScaleShift, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVScaleShift", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVScaleShift const &o){ return new PyCallBack_VPUNN_SHVScaleShift(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVScaleShift const &o){ return new VPUNN::SHVScaleShift(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
}


// File: VPUNN_76.cpp
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SHVYuvToRgb file: line:10
struct PyCallBack_VPUNN_SHVYuvToRgb : public VPUNN::SHVYuvToRgb {
	using VPUNN::SHVYuvToRgb::SHVYuvToRgb;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVYuvToRgb *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSoftPlus file: line:10
struct PyCallBack_VPUNN_SHVSoftPlus : public VPUNN::SHVSoftPlus {
	using VPUNN::SHVSoftPlus::SHVSoftPlus;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSoftPlus *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVSwish file: line:10
struct PyCallBack_VPUNN_SHVSwish : public VPUNN::SHVSwish {
	using VPUNN::SHVSwish::SHVSwish;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSwish *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVMVN file: line:10
struct PyCallBack_VPUNN_SHVMVN : public VPUNN::SHVMVN {
	using VPUNN::SHVMVN::SHVMVN;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVMVN *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVCeiling file: line:10
struct PyCallBack_VPUNN_SHVCeiling : public VPUNN::SHVCeiling {
	using VPUNN::SHVCeiling::SHVCeiling;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVCeiling *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVActivation::cycles();
	}
};

// VPUNN::SHVPower file: line:10
struct PyCallBack_VPUNN_SHVPower : public VPUNN::SHVPower {
	using VPUNN::SHVPower::SHVPower;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVPower *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVAdd file: line:10
struct PyCallBack_VPUNN_SHVAdd : public VPUNN::SHVAdd {
	using VPUNN::SHVAdd::SHVAdd;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAdd *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVDivide file: line:10
struct PyCallBack_VPUNN_SHVDivide : public VPUNN::SHVDivide {
	using VPUNN::SHVDivide::SHVDivide;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVDivide *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVSquaredDiff file: line:10
struct PyCallBack_VPUNN_SHVSquaredDiff : public VPUNN::SHVSquaredDiff {
	using VPUNN::SHVSquaredDiff::SHVSquaredDiff;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSquaredDiff *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVFloorMod file: line:10
struct PyCallBack_VPUNN_SHVFloorMod : public VPUNN::SHVFloorMod {
	using VPUNN::SHVFloorMod::SHVFloorMod;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVFloorMod *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVLess file: line:10
struct PyCallBack_VPUNN_SHVLess : public VPUNN::SHVLess {
	using VPUNN::SHVLess::SHVLess;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVLess *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVLessEqual file: line:10
struct PyCallBack_VPUNN_SHVLessEqual : public VPUNN::SHVLessEqual {
	using VPUNN::SHVLessEqual::SHVLessEqual;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVLessEqual *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVGreater file: line:10
struct PyCallBack_VPUNN_SHVGreater : public VPUNN::SHVGreater {
	using VPUNN::SHVGreater::SHVGreater;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVGreater *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVGreaterEqual file: line:10
struct PyCallBack_VPUNN_SHVGreaterEqual : public VPUNN::SHVGreaterEqual {
	using VPUNN::SHVGreaterEqual::SHVGreaterEqual;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVGreaterEqual *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVLogicalOr file: line:10
struct PyCallBack_VPUNN_SHVLogicalOr : public VPUNN::SHVLogicalOr {
	using VPUNN::SHVLogicalOr::SHVLogicalOr;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVLogicalOr *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVLogicalNot file: line:10
struct PyCallBack_VPUNN_SHVLogicalNot : public VPUNN::SHVLogicalNot {
	using VPUNN::SHVLogicalNot::SHVLogicalNot;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVLogicalNot *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVLogicalXor file: line:10
struct PyCallBack_VPUNN_SHVLogicalXor : public VPUNN::SHVLogicalXor {
	using VPUNN::SHVLogicalXor::SHVLogicalXor;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVLogicalXor *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVMultiply file: line:10
struct PyCallBack_VPUNN_SHVMultiply : public VPUNN::SHVMultiply {
	using VPUNN::SHVMultiply::SHVMultiply;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVMultiply *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVAnd file: line:10
struct PyCallBack_VPUNN_SHVAnd : public VPUNN::SHVAnd {
	using VPUNN::SHVAnd::SHVAnd;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAnd *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVMinimum file: line:10
struct PyCallBack_VPUNN_SHVMinimum : public VPUNN::SHVMinimum {
	using VPUNN::SHVMinimum::SHVMinimum;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVMinimum *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVMaximum file: line:10
struct PyCallBack_VPUNN_SHVMaximum : public VPUNN::SHVMaximum {
	using VPUNN::SHVMaximum::SHVMaximum;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVMaximum *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVSubtract file: line:10
struct PyCallBack_VPUNN_SHVSubtract : public VPUNN::SHVSubtract {
	using VPUNN::SHVSubtract::SHVSubtract;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSubtract *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVNotEqual file: line:10
struct PyCallBack_VPUNN_SHVNotEqual : public VPUNN::SHVNotEqual {
	using VPUNN::SHVNotEqual::SHVNotEqual;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVNotEqual *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVEqual file: line:10
struct PyCallBack_VPUNN_SHVEqual : public VPUNN::SHVEqual {
	using VPUNN::SHVEqual::SHVEqual;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVEqual *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVElementwise::cycles();
	}
};

// VPUNN::SHVRoll file: line:10
struct PyCallBack_VPUNN_SHVRoll : public VPUNN::SHVRoll {
	using VPUNN::SHVRoll::SHVRoll;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVRoll *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

void bind_VPUNN_76(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::SHVYuvToRgb file: line:10
		pybind11::class_<VPUNN::SHVYuvToRgb, std::shared_ptr<VPUNN::SHVYuvToRgb>, PyCallBack_VPUNN_SHVYuvToRgb, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVYuvToRgb", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVYuvToRgb const &o){ return new PyCallBack_VPUNN_SHVYuvToRgb(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVYuvToRgb const &o){ return new VPUNN::SHVYuvToRgb(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSoftPlus file: line:10
		pybind11::class_<VPUNN::SHVSoftPlus, std::shared_ptr<VPUNN::SHVSoftPlus>, PyCallBack_VPUNN_SHVSoftPlus, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVSoftPlus", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSoftPlus const &o){ return new PyCallBack_VPUNN_SHVSoftPlus(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSoftPlus const &o){ return new VPUNN::SHVSoftPlus(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSwish file: line:10
		pybind11::class_<VPUNN::SHVSwish, std::shared_ptr<VPUNN::SHVSwish>, PyCallBack_VPUNN_SHVSwish, VPUNN::SHVActivation<1000,0>> cl(M("VPUNN"), "SHVSwish", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSwish const &o){ return new PyCallBack_VPUNN_SHVSwish(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSwish const &o){ return new VPUNN::SHVSwish(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVMVN file: line:10
		pybind11::class_<VPUNN::SHVMVN, std::shared_ptr<VPUNN::SHVMVN>, PyCallBack_VPUNN_SHVMVN, VPUNN::SHVActivation<830,2810>> cl(M("VPUNN"), "SHVMVN", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVMVN const &o){ return new PyCallBack_VPUNN_SHVMVN(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVMVN const &o){ return new VPUNN::SHVMVN(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVCeiling file: line:10
		pybind11::class_<VPUNN::SHVCeiling, std::shared_ptr<VPUNN::SHVCeiling>, PyCallBack_VPUNN_SHVCeiling, VPUNN::SHVActivation<306,8391>> cl(M("VPUNN"), "SHVCeiling", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVCeiling const &o){ return new PyCallBack_VPUNN_SHVCeiling(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVCeiling const &o){ return new VPUNN::SHVCeiling(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVPower file: line:10
		pybind11::class_<VPUNN::SHVPower, std::shared_ptr<VPUNN::SHVPower>, PyCallBack_VPUNN_SHVPower, VPUNN::SHVElementwise<4,15829>> cl(M("VPUNN"), "SHVPower", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVPower const &o){ return new PyCallBack_VPUNN_SHVPower(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVPower const &o){ return new VPUNN::SHVPower(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAdd file: line:10
		pybind11::class_<VPUNN::SHVAdd, std::shared_ptr<VPUNN::SHVAdd>, PyCallBack_VPUNN_SHVAdd, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVAdd", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAdd const &o){ return new PyCallBack_VPUNN_SHVAdd(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAdd const &o){ return new VPUNN::SHVAdd(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVDivide file: line:10
		pybind11::class_<VPUNN::SHVDivide, std::shared_ptr<VPUNN::SHVDivide>, PyCallBack_VPUNN_SHVDivide, VPUNN::SHVElementwise<12,11587>> cl(M("VPUNN"), "SHVDivide", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVDivide const &o){ return new PyCallBack_VPUNN_SHVDivide(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVDivide const &o){ return new VPUNN::SHVDivide(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSquaredDiff file: line:10
		pybind11::class_<VPUNN::SHVSquaredDiff, std::shared_ptr<VPUNN::SHVSquaredDiff>, PyCallBack_VPUNN_SHVSquaredDiff, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVSquaredDiff", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSquaredDiff const &o){ return new PyCallBack_VPUNN_SHVSquaredDiff(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSquaredDiff const &o){ return new VPUNN::SHVSquaredDiff(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVFloorMod file: line:10
		pybind11::class_<VPUNN::SHVFloorMod, std::shared_ptr<VPUNN::SHVFloorMod>, PyCallBack_VPUNN_SHVFloorMod, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVFloorMod", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVFloorMod const &o){ return new PyCallBack_VPUNN_SHVFloorMod(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVFloorMod const &o){ return new VPUNN::SHVFloorMod(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVLess file: line:10
		pybind11::class_<VPUNN::SHVLess, std::shared_ptr<VPUNN::SHVLess>, PyCallBack_VPUNN_SHVLess, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVLess", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVLess const &o){ return new PyCallBack_VPUNN_SHVLess(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVLess const &o){ return new VPUNN::SHVLess(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVLessEqual file: line:10
		pybind11::class_<VPUNN::SHVLessEqual, std::shared_ptr<VPUNN::SHVLessEqual>, PyCallBack_VPUNN_SHVLessEqual, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVLessEqual", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVLessEqual const &o){ return new PyCallBack_VPUNN_SHVLessEqual(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVLessEqual const &o){ return new VPUNN::SHVLessEqual(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVGreater file: line:10
		pybind11::class_<VPUNN::SHVGreater, std::shared_ptr<VPUNN::SHVGreater>, PyCallBack_VPUNN_SHVGreater, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVGreater", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVGreater const &o){ return new PyCallBack_VPUNN_SHVGreater(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVGreater const &o){ return new VPUNN::SHVGreater(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVGreaterEqual file: line:10
		pybind11::class_<VPUNN::SHVGreaterEqual, std::shared_ptr<VPUNN::SHVGreaterEqual>, PyCallBack_VPUNN_SHVGreaterEqual, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVGreaterEqual", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVGreaterEqual const &o){ return new PyCallBack_VPUNN_SHVGreaterEqual(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVGreaterEqual const &o){ return new VPUNN::SHVGreaterEqual(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVLogicalOr file: line:10
		pybind11::class_<VPUNN::SHVLogicalOr, std::shared_ptr<VPUNN::SHVLogicalOr>, PyCallBack_VPUNN_SHVLogicalOr, VPUNN::SHVElementwise<8,13192>> cl(M("VPUNN"), "SHVLogicalOr", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVLogicalOr const &o){ return new PyCallBack_VPUNN_SHVLogicalOr(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVLogicalOr const &o){ return new VPUNN::SHVLogicalOr(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVLogicalNot file: line:10
		pybind11::class_<VPUNN::SHVLogicalNot, std::shared_ptr<VPUNN::SHVLogicalNot>, PyCallBack_VPUNN_SHVLogicalNot, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVLogicalNot", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVLogicalNot const &o){ return new PyCallBack_VPUNN_SHVLogicalNot(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVLogicalNot const &o){ return new VPUNN::SHVLogicalNot(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVLogicalXor file: line:10
		pybind11::class_<VPUNN::SHVLogicalXor, std::shared_ptr<VPUNN::SHVLogicalXor>, PyCallBack_VPUNN_SHVLogicalXor, VPUNN::SHVElementwise<8,13036>> cl(M("VPUNN"), "SHVLogicalXor", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVLogicalXor const &o){ return new PyCallBack_VPUNN_SHVLogicalXor(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVLogicalXor const &o){ return new VPUNN::SHVLogicalXor(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVMultiply file: line:10
		pybind11::class_<VPUNN::SHVMultiply, std::shared_ptr<VPUNN::SHVMultiply>, PyCallBack_VPUNN_SHVMultiply, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVMultiply", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVMultiply const &o){ return new PyCallBack_VPUNN_SHVMultiply(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVMultiply const &o){ return new VPUNN::SHVMultiply(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAnd file: line:10
		pybind11::class_<VPUNN::SHVAnd, std::shared_ptr<VPUNN::SHVAnd>, PyCallBack_VPUNN_SHVAnd, VPUNN::SHVElementwise<45,30591>> cl(M("VPUNN"), "SHVAnd", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAnd const &o){ return new PyCallBack_VPUNN_SHVAnd(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAnd const &o){ return new VPUNN::SHVAnd(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVMinimum file: line:10
		pybind11::class_<VPUNN::SHVMinimum, std::shared_ptr<VPUNN::SHVMinimum>, PyCallBack_VPUNN_SHVMinimum, VPUNN::SHVElementwise<15,11047>> cl(M("VPUNN"), "SHVMinimum", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVMinimum const &o){ return new PyCallBack_VPUNN_SHVMinimum(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVMinimum const &o){ return new VPUNN::SHVMinimum(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVMaximum file: line:10
		pybind11::class_<VPUNN::SHVMaximum, std::shared_ptr<VPUNN::SHVMaximum>, PyCallBack_VPUNN_SHVMaximum, VPUNN::SHVElementwise<15,11000>> cl(M("VPUNN"), "SHVMaximum", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVMaximum const &o){ return new PyCallBack_VPUNN_SHVMaximum(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVMaximum const &o){ return new VPUNN::SHVMaximum(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSubtract file: line:10
		pybind11::class_<VPUNN::SHVSubtract, std::shared_ptr<VPUNN::SHVSubtract>, PyCallBack_VPUNN_SHVSubtract, VPUNN::SHVElementwise<789,12946>> cl(M("VPUNN"), "SHVSubtract", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSubtract const &o){ return new PyCallBack_VPUNN_SHVSubtract(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSubtract const &o){ return new VPUNN::SHVSubtract(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVNotEqual file: line:10
		pybind11::class_<VPUNN::SHVNotEqual, std::shared_ptr<VPUNN::SHVNotEqual>, PyCallBack_VPUNN_SHVNotEqual, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVNotEqual", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVNotEqual const &o){ return new PyCallBack_VPUNN_SHVNotEqual(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVNotEqual const &o){ return new VPUNN::SHVNotEqual(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVEqual file: line:10
		pybind11::class_<VPUNN::SHVEqual, std::shared_ptr<VPUNN::SHVEqual>, PyCallBack_VPUNN_SHVEqual, VPUNN::SHVElementwise<1000,0>> cl(M("VPUNN"), "SHVEqual", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVEqual const &o){ return new PyCallBack_VPUNN_SHVEqual(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVEqual const &o){ return new VPUNN::SHVEqual(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class std::vector<class VPUNN::VPUTensor, class std::allocator<class VPUNN::VPUTensor> > &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("inputs"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVRoll file: line:10
		pybind11::class_<VPUNN::SHVRoll, std::shared_ptr<VPUNN::SHVRoll>, PyCallBack_VPUNN_SHVRoll, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVRoll", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVRoll const &o){ return new PyCallBack_VPUNN_SHVRoll(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVRoll const &o){ return new VPUNN::SHVRoll(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
}


// File: VPUNN_77.cpp
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

// VPUNN::SHVShuffleChannels file: line:10
struct PyCallBack_VPUNN_SHVShuffleChannels : public VPUNN::SHVShuffleChannels {
	using VPUNN::SHVShuffleChannels::SHVShuffleChannels;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVShuffleChannels *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVGather file: line:10
struct PyCallBack_VPUNN_SHVGather : public VPUNN::SHVGather {
	using VPUNN::SHVGather::SHVGather;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVGather *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVScatterNDUpdate file: line:10
struct PyCallBack_VPUNN_SHVScatterNDUpdate : public VPUNN::SHVScatterNDUpdate {
	using VPUNN::SHVScatterNDUpdate::SHVScatterNDUpdate;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVScatterNDUpdate *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVScatterUpdate file: line:10
struct PyCallBack_VPUNN_SHVScatterUpdate : public VPUNN::SHVScatterUpdate {
	using VPUNN::SHVScatterUpdate::SHVScatterUpdate;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVScatterUpdate *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVReshape file: line:10
struct PyCallBack_VPUNN_SHVReshape : public VPUNN::SHVReshape {
	using VPUNN::SHVReshape::SHVReshape;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVReshape *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVSqueeze file: line:10
struct PyCallBack_VPUNN_SHVSqueeze : public VPUNN::SHVSqueeze {
	using VPUNN::SHVSqueeze::SHVSqueeze;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSqueeze *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVUnsqueeze file: line:10
struct PyCallBack_VPUNN_SHVUnsqueeze : public VPUNN::SHVUnsqueeze {
	using VPUNN::SHVUnsqueeze::SHVUnsqueeze;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVUnsqueeze *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVBroadcast file: line:10
struct PyCallBack_VPUNN_SHVBroadcast : public VPUNN::SHVBroadcast {
	using VPUNN::SHVBroadcast::SHVBroadcast;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVBroadcast *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVTranspose file: line:10
struct PyCallBack_VPUNN_SHVTranspose : public VPUNN::SHVTranspose {
	using VPUNN::SHVTranspose::SHVTranspose;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVTranspose *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVConcat file: line:10
struct PyCallBack_VPUNN_SHVConcat : public VPUNN::SHVConcat {
	using VPUNN::SHVConcat::SHVConcat;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVConcat *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVAffineReshape file: line:10
struct PyCallBack_VPUNN_SHVAffineReshape : public VPUNN::SHVAffineReshape {
	using VPUNN::SHVAffineReshape::SHVAffineReshape;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVAffineReshape *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVPermuteQuantize file: line:10
struct PyCallBack_VPUNN_SHVPermuteQuantize : public VPUNN::SHVPermuteQuantize {
	using VPUNN::SHVPermuteQuantize::SHVPermuteQuantize;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVPermuteQuantize *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVDepthToSpace file: line:10
struct PyCallBack_VPUNN_SHVDepthToSpace : public VPUNN::SHVDepthToSpace {
	using VPUNN::SHVDepthToSpace::SHVDepthToSpace;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVDepthToSpace *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVSpaceToDepthOp file: line:10
struct PyCallBack_VPUNN_SHVSpaceToDepthOp : public VPUNN::SHVSpaceToDepthOp {
	using VPUNN::SHVSpaceToDepthOp::SHVSpaceToDepthOp;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVSpaceToDepthOp *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVMemPermute file: line:10
struct PyCallBack_VPUNN_SHVMemPermute : public VPUNN::SHVMemPermute {
	using VPUNN::SHVMemPermute::SHVMemPermute;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVMemPermute *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

// VPUNN::SHVPermuteCast file: line:10
struct PyCallBack_VPUNN_SHVPermuteCast : public VPUNN::SHVPermuteCast {
	using VPUNN::SHVPermuteCast::SHVPermuteCast;

	unsigned int cycles() const override {
		pybind11::gil_scoped_acquire gil;
		pybind11::function overload = pybind11::get_overload(static_cast<const VPUNN::SHVPermuteCast *>(this), "cycles");
		if (overload) {
			auto o = overload.operator()<pybind11::return_value_policy::reference>();
			if (pybind11::detail::cast_is_temporary_value_reference<unsigned int>::value) {
				static pybind11::detail::override_caster_t<unsigned int> caster;
				return pybind11::detail::cast_ref<unsigned int>(std::move(o), caster);
			}
			else return pybind11::detail::cast_safe<unsigned int>(std::move(o));
		}
		return SHVDataMovement::cycles();
	}
};

void bind_VPUNN_77(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::SHVShuffleChannels file: line:10
		pybind11::class_<VPUNN::SHVShuffleChannels, std::shared_ptr<VPUNN::SHVShuffleChannels>, PyCallBack_VPUNN_SHVShuffleChannels, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVShuffleChannels", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVShuffleChannels const &o){ return new PyCallBack_VPUNN_SHVShuffleChannels(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVShuffleChannels const &o){ return new VPUNN::SHVShuffleChannels(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVGather file: line:10
		pybind11::class_<VPUNN::SHVGather, std::shared_ptr<VPUNN::SHVGather>, PyCallBack_VPUNN_SHVGather, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVGather", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVGather const &o){ return new PyCallBack_VPUNN_SHVGather(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVGather const &o){ return new VPUNN::SHVGather(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVScatterNDUpdate file: line:10
		pybind11::class_<VPUNN::SHVScatterNDUpdate, std::shared_ptr<VPUNN::SHVScatterNDUpdate>, PyCallBack_VPUNN_SHVScatterNDUpdate, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVScatterNDUpdate", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVScatterNDUpdate const &o){ return new PyCallBack_VPUNN_SHVScatterNDUpdate(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVScatterNDUpdate const &o){ return new VPUNN::SHVScatterNDUpdate(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVScatterUpdate file: line:10
		pybind11::class_<VPUNN::SHVScatterUpdate, std::shared_ptr<VPUNN::SHVScatterUpdate>, PyCallBack_VPUNN_SHVScatterUpdate, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVScatterUpdate", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVScatterUpdate const &o){ return new PyCallBack_VPUNN_SHVScatterUpdate(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVScatterUpdate const &o){ return new VPUNN::SHVScatterUpdate(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVReshape file: line:10
		pybind11::class_<VPUNN::SHVReshape, std::shared_ptr<VPUNN::SHVReshape>, PyCallBack_VPUNN_SHVReshape, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVReshape", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVReshape const &o){ return new PyCallBack_VPUNN_SHVReshape(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVReshape const &o){ return new VPUNN::SHVReshape(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSqueeze file: line:10
		pybind11::class_<VPUNN::SHVSqueeze, std::shared_ptr<VPUNN::SHVSqueeze>, PyCallBack_VPUNN_SHVSqueeze, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVSqueeze", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSqueeze const &o){ return new PyCallBack_VPUNN_SHVSqueeze(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSqueeze const &o){ return new VPUNN::SHVSqueeze(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVUnsqueeze file: line:10
		pybind11::class_<VPUNN::SHVUnsqueeze, std::shared_ptr<VPUNN::SHVUnsqueeze>, PyCallBack_VPUNN_SHVUnsqueeze, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVUnsqueeze", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVUnsqueeze const &o){ return new PyCallBack_VPUNN_SHVUnsqueeze(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVUnsqueeze const &o){ return new VPUNN::SHVUnsqueeze(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVBroadcast file: line:10
		pybind11::class_<VPUNN::SHVBroadcast, std::shared_ptr<VPUNN::SHVBroadcast>, PyCallBack_VPUNN_SHVBroadcast, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVBroadcast", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVBroadcast const &o){ return new PyCallBack_VPUNN_SHVBroadcast(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVBroadcast const &o){ return new VPUNN::SHVBroadcast(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVTranspose file: line:10
		pybind11::class_<VPUNN::SHVTranspose, std::shared_ptr<VPUNN::SHVTranspose>, PyCallBack_VPUNN_SHVTranspose, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVTranspose", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVTranspose const &o){ return new PyCallBack_VPUNN_SHVTranspose(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVTranspose const &o){ return new VPUNN::SHVTranspose(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVConcat file: line:10
		pybind11::class_<VPUNN::SHVConcat, std::shared_ptr<VPUNN::SHVConcat>, PyCallBack_VPUNN_SHVConcat, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVConcat", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVConcat const &o){ return new PyCallBack_VPUNN_SHVConcat(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVConcat const &o){ return new VPUNN::SHVConcat(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVAffineReshape file: line:10
		pybind11::class_<VPUNN::SHVAffineReshape, std::shared_ptr<VPUNN::SHVAffineReshape>, PyCallBack_VPUNN_SHVAffineReshape, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVAffineReshape", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVAffineReshape const &o){ return new PyCallBack_VPUNN_SHVAffineReshape(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVAffineReshape const &o){ return new VPUNN::SHVAffineReshape(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVPermuteQuantize file: line:10
		pybind11::class_<VPUNN::SHVPermuteQuantize, std::shared_ptr<VPUNN::SHVPermuteQuantize>, PyCallBack_VPUNN_SHVPermuteQuantize, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVPermuteQuantize", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVPermuteQuantize const &o){ return new PyCallBack_VPUNN_SHVPermuteQuantize(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVPermuteQuantize const &o){ return new VPUNN::SHVPermuteQuantize(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVDepthToSpace file: line:10
		pybind11::class_<VPUNN::SHVDepthToSpace, std::shared_ptr<VPUNN::SHVDepthToSpace>, PyCallBack_VPUNN_SHVDepthToSpace, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVDepthToSpace", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVDepthToSpace const &o){ return new PyCallBack_VPUNN_SHVDepthToSpace(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVDepthToSpace const &o){ return new VPUNN::SHVDepthToSpace(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVSpaceToDepthOp file: line:10
		pybind11::class_<VPUNN::SHVSpaceToDepthOp, std::shared_ptr<VPUNN::SHVSpaceToDepthOp>, PyCallBack_VPUNN_SHVSpaceToDepthOp, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVSpaceToDepthOp", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVSpaceToDepthOp const &o){ return new PyCallBack_VPUNN_SHVSpaceToDepthOp(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVSpaceToDepthOp const &o){ return new VPUNN::SHVSpaceToDepthOp(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVMemPermute file: line:10
		pybind11::class_<VPUNN::SHVMemPermute, std::shared_ptr<VPUNN::SHVMemPermute>, PyCallBack_VPUNN_SHVMemPermute, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVMemPermute", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVMemPermute const &o){ return new PyCallBack_VPUNN_SHVMemPermute(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVMemPermute const &o){ return new VPUNN::SHVMemPermute(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::SHVPermuteCast file: line:10
		pybind11::class_<VPUNN::SHVPermuteCast, std::shared_ptr<VPUNN::SHVPermuteCast>, PyCallBack_VPUNN_SHVPermuteCast, VPUNN::SHVDataMovement<1000,0>> cl(M("VPUNN"), "SHVPermuteCast", "");
		cl.def( pybind11::init( [](PyCallBack_VPUNN_SHVPermuteCast const &o){ return new PyCallBack_VPUNN_SHVPermuteCast(o); } ) );
		cl.def( pybind11::init( [](VPUNN::SHVPermuteCast const &o){ return new VPUNN::SHVPermuteCast(o); } ) );
		cl.def( pybind11::init<const enum VPUNN::VPUDevice &, const class VPUNN::VPUTensor &, const class VPUNN::VPUTensor &>(), pybind11::arg("device"), pybind11::arg("input"), pybind11::arg("output") );

	}
	{ // VPUNN::DMACostModel file: line:14
		pybind11::class_<VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>, std::shared_ptr<VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>>> cl(M("VPUNN"), "DMACostModel_VPUNN_DMANNWorkload_NPU27_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(); } ), "doc" );
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0); } ), "doc" , pybind11::arg("filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2, a3); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init<const std::string &, bool, const unsigned int, const unsigned int, const std::string &>(), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("cache_filename") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("cache_data"));
		cl.def( pybind11::init<const char *, unsigned long, bool, bool, const unsigned int, const unsigned int, const char *, unsigned long>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("cache_data"), pybind11::arg("cache_data_length") );

		cl.def("nn_initialized", (bool (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::nn_initialized, "Check if the internal VPUNN is initialized\n\n \n true the VPUNN neural network is initialized\n \n\n false the VPUNN neural network is not initialized\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::nn_initialized() const --> bool");
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::*)() const) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval, "provides the value interval where the NN raw outputs are considered valid and will be used to further\n compute information\n\n \n a pair containing (minimum_valid_value maximum_valid_value)\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
		cl.def("computeCycles", (unsigned int (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeCycles, "Return the number of cycles needed to compute a workload\n\n Important: If no NN is available it will return Cycles::ERROR_INFERENCE_NOT_POSSIBLE. Check if NN is loaded with\n nn_initialized()\n\n A sanity check will be performed: NO\n\n List of Error codes is available in CyclesInterfaceType doc.\n\n A sanity check will be performed also on the NN output, in case the NN  raw value is not reliable it will not be\n returned but an error code will be given, e.g. ERROR_INVALID_OUTPUT_RANGE\n\n To see the limits of valid NN values interval , use \n get_NN_Valid_interval().  Zero is a value that will NOT\n be filtered out.\n\n Behind the DPU computation is a trained Neural Network that might give unexpected results in case is asked about\n a workload that is odd/(not well formed) or was not trained in that area or workloads.\n The workload passed as parameter for inference should be a valid one, a one that makes sense, we are checking\n some sanity, but ,for now, not a strict/extensive sanity check is performed. A workload with unrealistic\n combinations of  parameters  will not be detected.\n\n In case the wl configuration is unrealistic the network will give undefined(aberrant) results (it was not trained\n on invalid data). The NN raw output is filtered for  generic valid interval  but the user can also be aware of\n this behavior and use its own narrower ranges\n\n e.g.  Depending on the wl a cycle values of 10 might be unrealistic, also a value of 100milion cycles (@1Ghz is\n ~100ms),  The user should be aware that not all aberrant/unrealistic NN outputs are handled inside.\n\n \n a workload to be evaluated.\n \n\n unsigned int workload execution cycles or an error code.\n\n \n out_of_range : cache problems, cannot pre-process data , generate the NN descriptor due to data unknown\n \n\n runtime_error: cannot generate the NN descriptor, e.g expected sizes do not match\n\n     \n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeCycles(const struct VPUNN::DMANNWorkload_NPU27 &) --> unsigned int", pybind11::arg("wl"));
		cl.def("computeCyclesMsg", (class std::tuple<unsigned int, std::string > (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::*)(struct VPUNN::DMANNWorkload_NPU27)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeCyclesMsg, "same like  \n computeCycles(DMANNWorkload wl) , the extra param is to have as output the textual\n errors/findings discovered when handling the workload\n \n\n the workload to infer on\n \n\n will collect error info regarding wl checking.\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeCyclesMsg(struct VPUNN::DMANNWorkload_NPU27) --> class std::tuple<unsigned int, std::string >", pybind11::arg("wl"));
		cl.def("computeCycles", (unsigned int (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::*)(const struct VPUNN::DMANNWorkload_NPU27 &, std::string &)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeCycles, "same like  \n computeCycles(DMANNWorkload wl) , the extra param is to have as output the textual\n errors/findings discovered when handling the workload\n \n\n the workload to infer on\n \n\n [out] will collect error info regarding wl checking.\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeCycles(const struct VPUNN::DMANNWorkload_NPU27 &, std::string &) --> unsigned int", pybind11::arg("wl"), pybind11::arg("info"));
		cl.def("computeBandwidthMsg", (class std::tuple<float, std::string > (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::*)(struct VPUNN::DMANNWorkload_NPU27)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeBandwidthMsg, "C++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU27>::computeBandwidthMsg(struct VPUNN::DMANNWorkload_NPU27) --> class std::tuple<float, std::string >", pybind11::arg("wl"));
	}
}


// File: VPUNN_78.cpp
#include <array> // std::array
#include <iterator> // __gnu_cxx::__normal_iterator
#include <memory> // std::allocator
#include <sstream> // __str__
#include <string> // std::basic_string
#include <string> // std::char_traits
#include <string_view> // std::basic_string_view
#include <tuple> // std::tuple
#include <utility> // std::pair
#include <vector> // std::vector

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <vpu_cost_model.h>
#include <vpu_network_cost_model.h>
#include <vpu/shave/layers.h>
#include <vpu_dma_cost_model.h>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_VPUNN_78(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // VPUNN::DMACostModel file: line:15
		pybind11::class_<VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>, std::shared_ptr<VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>>> cl(M("VPUNN"), "DMACostModel_VPUNN_DMANNWorkload_NPU40_50_t", "");
		cl.def( pybind11::init( [](){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(); } ), "doc" );
		cl.def( pybind11::init( [](const std::string & a0){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0); } ), "doc" , pybind11::arg("filename"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const std::string & a0, bool const & a1, const unsigned int & a2, const unsigned int & a3){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2, a3); } ), "doc" , pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init<const std::string &, bool, const unsigned int, const unsigned int, const std::string &>(), pybind11::arg("filename"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("cache_filename") );

		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2, a3); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2, a3, a4); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2, a3, a4, a5); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"));
		cl.def( pybind11::init( [](const char * a0, unsigned long const & a1, bool const & a2, bool const & a3, const unsigned int & a4, const unsigned int & a5, const char * a6){ return new VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>(a0, a1, a2, a3, a4, a5, a6); } ), "doc" , pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("cache_data"));
		cl.def( pybind11::init<const char *, unsigned long, bool, bool, const unsigned int, const unsigned int, const char *, unsigned long>(), pybind11::arg("model_data"), pybind11::arg("model_data_length"), pybind11::arg("copy_model_data"), pybind11::arg("profile"), pybind11::arg("cache_size"), pybind11::arg("batch_size"), pybind11::arg("cache_data"), pybind11::arg("cache_data_length") );

		cl.def("nn_initialized", (bool (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::nn_initialized, "Check if the internal VPUNN is initialized\n\n \n true the VPUNN neural network is initialized\n \n\n false the VPUNN neural network is not initialized\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::nn_initialized() const --> bool");
		cl.def("get_NN_Valid_interval", (struct std::pair<float, float> (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::*)() const) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval, "provides the value interval where the NN raw outputs are considered valid and will be used to further\n compute information\n\n \n a pair containing (minimum_valid_value maximum_valid_value)\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::get_NN_Valid_interval() const --> struct std::pair<float, float>");
		cl.def("computeCycles", (unsigned int (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeCycles, "Return the number of cycles needed to compute a workload\n\n Important: If no NN is available it will return Cycles::ERROR_INFERENCE_NOT_POSSIBLE. Check if NN is loaded with\n nn_initialized()\n\n A sanity check will be performed: NO\n\n List of Error codes is available in CyclesInterfaceType doc.\n\n A sanity check will be performed also on the NN output, in case the NN  raw value is not reliable it will not be\n returned but an error code will be given, e.g. ERROR_INVALID_OUTPUT_RANGE\n\n To see the limits of valid NN values interval , use \n get_NN_Valid_interval().  Zero is a value that will NOT\n be filtered out.\n\n Behind the DPU computation is a trained Neural Network that might give unexpected results in case is asked about\n a workload that is odd/(not well formed) or was not trained in that area or workloads.\n The workload passed as parameter for inference should be a valid one, a one that makes sense, we are checking\n some sanity, but ,for now, not a strict/extensive sanity check is performed. A workload with unrealistic\n combinations of  parameters  will not be detected.\n\n In case the wl configuration is unrealistic the network will give undefined(aberrant) results (it was not trained\n on invalid data). The NN raw output is filtered for  generic valid interval  but the user can also be aware of\n this behavior and use its own narrower ranges\n\n e.g.  Depending on the wl a cycle values of 10 might be unrealistic, also a value of 100milion cycles (@1Ghz is\n ~100ms),  The user should be aware that not all aberrant/unrealistic NN outputs are handled inside.\n\n \n a workload to be evaluated.\n \n\n unsigned int workload execution cycles or an error code.\n\n \n out_of_range : cache problems, cannot pre-process data , generate the NN descriptor due to data unknown\n \n\n runtime_error: cannot generate the NN descriptor, e.g expected sizes do not match\n\n     \n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeCycles(const struct VPUNN::DMANNWorkload_NPU40_50 &) --> unsigned int", pybind11::arg("wl"));
		cl.def("computeCyclesMsg", (class std::tuple<unsigned int, std::string > (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::*)(struct VPUNN::DMANNWorkload_NPU40_50)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeCyclesMsg, "same like  \n computeCycles(DMANNWorkload wl) , the extra param is to have as output the textual\n errors/findings discovered when handling the workload\n \n\n the workload to infer on\n \n\n will collect error info regarding wl checking.\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeCyclesMsg(struct VPUNN::DMANNWorkload_NPU40_50) --> class std::tuple<unsigned int, std::string >", pybind11::arg("wl"));
		cl.def("computeCycles", (unsigned int (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::*)(const struct VPUNN::DMANNWorkload_NPU40_50 &, std::string &)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeCycles, "same like  \n computeCycles(DMANNWorkload wl) , the extra param is to have as output the textual\n errors/findings discovered when handling the workload\n \n\n the workload to infer on\n \n\n [out] will collect error info regarding wl checking.\n\nC++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeCycles(const struct VPUNN::DMANNWorkload_NPU40_50 &, std::string &) --> unsigned int", pybind11::arg("wl"), pybind11::arg("info"));
		cl.def("computeBandwidthMsg", (class std::tuple<float, std::string > (VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::*)(struct VPUNN::DMANNWorkload_NPU40_50)) &VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeBandwidthMsg, "C++: VPUNN::DMACostModel<VPUNN::DMANNWorkload_NPU40_50>::computeBandwidthMsg(struct VPUNN::DMANNWorkload_NPU40_50) --> class std::tuple<float, std::string >", pybind11::arg("wl"));
	}
}


#include <map>
#include <algorithm>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>

#include <pybind11/pybind11.h>

typedef std::function< pybind11::module & (std::string const &) > ModuleGetter;

void bind_VPUNN_0(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_1(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_2(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_3(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_4(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_5(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_6(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_7(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_8(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_9(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_10(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_11(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_12(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_13(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_14(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_15(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_16(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_17(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_18(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_19(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_20(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_21(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_22(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_23(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_24(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_25(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_26(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_27(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_28(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_29(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_30(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_31(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_32(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_33(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_34(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_35(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_36(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_37(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_38(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_39(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_40(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_41(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_42(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_43(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_44(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_45(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_46(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_47(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_48(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_49(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_50(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_51(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_52(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_53(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_54(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_55(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_56(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_57(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_58(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_59(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_60(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_61(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_62(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_63(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_64(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_65(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_66(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_67(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_68(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_69(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_70(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_71(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_72(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_73(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_74(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_75(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_76(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_77(std::function< pybind11::module &(std::string const &namespace_) > &M);
void bind_VPUNN_78(std::function< pybind11::module &(std::string const &namespace_) > &M);


PYBIND11_MODULE(VPUNN, root_module) {
	root_module.doc() = "VPUNN module";

	std::map <std::string, pybind11::module> modules;
	ModuleGetter M = [&](std::string const &namespace_) -> pybind11::module & {
		auto it = modules.find(namespace_);
		if( it == modules.end() ) throw std::runtime_error("Attempt to access pybind11::module for namespace " + namespace_ + " before it was created!!!");
		return it->second;
	};

	modules[""] = root_module;

	static std::vector<std::string> const reserved_python_words {"nonlocal", "global", };

	auto mangle_namespace_name(
		[](std::string const &ns) -> std::string {
			if ( std::find(reserved_python_words.begin(), reserved_python_words.end(), ns) == reserved_python_words.end() ) return ns;
			else return ns+'_';
		}
	);

	std::vector< std::pair<std::string, std::string> > sub_modules {
		{"", "VPUNN"},
		{"VPUNN", "Dim"},
		{"VPUNN", "intf_01"},
		{"VPUNN", "intf_11"},
		{"VPUNN", "intf_12"},
		{"VPUNN", "intf_13"},
		{"VPUNN", "intf_14"},
		{"VPUNN", "intf_15"},
		{"VPUNN", "intf_dma_01x"},
		{"", "std"},
		{"std", "chrono"},
	};
	for(auto &p : sub_modules ) modules[p.first.size() ? p.first+"::"+p.second : p.second] = modules[p.first].def_submodule( mangle_namespace_name(p.second).c_str(), ("Bindings for " + p.first + "::" + p.second + " namespace").c_str() );

	//pybind11::class_<std::shared_ptr<void>>(M(""), "_encapsulated_data_");

	bind_VPUNN_0(M);
	bind_VPUNN_1(M);
	bind_VPUNN_2(M);
	bind_VPUNN_3(M);
	bind_VPUNN_4(M);
	bind_VPUNN_5(M);
	bind_VPUNN_6(M);
	bind_VPUNN_7(M);
	bind_VPUNN_8(M);
	bind_VPUNN_9(M);
	bind_VPUNN_10(M);
	bind_VPUNN_11(M);
	bind_VPUNN_12(M);
	bind_VPUNN_13(M);
	bind_VPUNN_14(M);
	bind_VPUNN_15(M);
	bind_VPUNN_16(M);
	bind_VPUNN_17(M);
	bind_VPUNN_18(M);
	bind_VPUNN_19(M);
	bind_VPUNN_20(M);
	bind_VPUNN_21(M);
	bind_VPUNN_22(M);
	bind_VPUNN_23(M);
	bind_VPUNN_24(M);
	bind_VPUNN_25(M);
	bind_VPUNN_26(M);
	bind_VPUNN_27(M);
	bind_VPUNN_28(M);
	bind_VPUNN_29(M);
	bind_VPUNN_30(M);
	bind_VPUNN_31(M);
	bind_VPUNN_32(M);
	bind_VPUNN_33(M);
	bind_VPUNN_34(M);
	bind_VPUNN_35(M);
	bind_VPUNN_36(M);
	bind_VPUNN_37(M);
	bind_VPUNN_38(M);
	bind_VPUNN_39(M);
	bind_VPUNN_40(M);
	bind_VPUNN_41(M);
	bind_VPUNN_42(M);
	bind_VPUNN_43(M);
	bind_VPUNN_44(M);
	bind_VPUNN_45(M);
	bind_VPUNN_46(M);
	bind_VPUNN_47(M);
	bind_VPUNN_48(M);
	bind_VPUNN_49(M);
	bind_VPUNN_50(M);
	bind_VPUNN_51(M);
	bind_VPUNN_52(M);
	bind_VPUNN_53(M);
	bind_VPUNN_54(M);
	bind_VPUNN_55(M);
	bind_VPUNN_56(M);
	bind_VPUNN_57(M);
	bind_VPUNN_58(M);
	bind_VPUNN_59(M);
	bind_VPUNN_60(M);
	bind_VPUNN_61(M);
	bind_VPUNN_62(M);
	bind_VPUNN_63(M);
	bind_VPUNN_64(M);
	bind_VPUNN_65(M);
	bind_VPUNN_66(M);
	bind_VPUNN_67(M);
	bind_VPUNN_68(M);
	bind_VPUNN_69(M);
	bind_VPUNN_70(M);
	bind_VPUNN_71(M);
	bind_VPUNN_72(M);
	bind_VPUNN_73(M);
	bind_VPUNN_74(M);
	bind_VPUNN_75(M);
	bind_VPUNN_76(M);
	bind_VPUNN_77(M);
	bind_VPUNN_78(M);

}

// Source list file: /home/ppistril/repo_costmodel/libraries.performance.modeling.vpu.nn-cost-model/src/python/VPUNN.sources
// VPUNN.cpp
// VPUNN_0.cpp
// VPUNN_1.cpp
// VPUNN_2.cpp
// VPUNN_3.cpp
// VPUNN_4.cpp
// VPUNN_5.cpp
// VPUNN_6.cpp
// VPUNN_7.cpp
// VPUNN_8.cpp
// VPUNN_9.cpp
// VPUNN_10.cpp
// VPUNN_11.cpp
// VPUNN_12.cpp
// VPUNN_13.cpp
// VPUNN_14.cpp
// VPUNN_15.cpp
// VPUNN_16.cpp
// VPUNN_17.cpp
// VPUNN_18.cpp
// VPUNN_19.cpp
// VPUNN_20.cpp
// VPUNN_21.cpp
// VPUNN_22.cpp
// VPUNN_23.cpp
// VPUNN_24.cpp
// VPUNN_25.cpp
// VPUNN_26.cpp
// VPUNN_27.cpp
// VPUNN_28.cpp
// VPUNN_29.cpp
// VPUNN_30.cpp
// VPUNN_31.cpp
// VPUNN_32.cpp
// VPUNN_33.cpp
// VPUNN_34.cpp
// VPUNN_35.cpp
// VPUNN_36.cpp
// VPUNN_37.cpp
// VPUNN_38.cpp
// VPUNN_39.cpp
// VPUNN_40.cpp
// VPUNN_41.cpp
// VPUNN_42.cpp
// VPUNN_43.cpp
// VPUNN_44.cpp
// VPUNN_45.cpp
// VPUNN_46.cpp
// VPUNN_47.cpp
// VPUNN_48.cpp
// VPUNN_49.cpp
// VPUNN_50.cpp
// VPUNN_51.cpp
// VPUNN_52.cpp
// VPUNN_53.cpp
// VPUNN_54.cpp
// VPUNN_55.cpp
// VPUNN_56.cpp
// VPUNN_57.cpp
// VPUNN_58.cpp
// VPUNN_59.cpp
// VPUNN_60.cpp
// VPUNN_61.cpp
// VPUNN_62.cpp
// VPUNN_63.cpp
// VPUNN_64.cpp
// VPUNN_65.cpp
// VPUNN_66.cpp
// VPUNN_67.cpp
// VPUNN_68.cpp
// VPUNN_69.cpp
// VPUNN_70.cpp
// VPUNN_71.cpp
// VPUNN_72.cpp
// VPUNN_73.cpp
// VPUNN_74.cpp
// VPUNN_75.cpp
// VPUNN_76.cpp
// VPUNN_77.cpp
// VPUNN_78.cpp

// Modules list file: /home/ppistril/repo_costmodel/libraries.performance.modeling.vpu.nn-cost-model/src/python/VPUNN.modules
// VPUNN VPUNN.Dim VPUNN.intf_01 VPUNN.intf_11 VPUNN.intf_12 VPUNN.intf_13 VPUNN.intf_14 VPUNN.intf_15 VPUNN.intf_dma_01x std std.chrono 
